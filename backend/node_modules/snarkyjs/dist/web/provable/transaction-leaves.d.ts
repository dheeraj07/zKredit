import { Field, Bool } from '../lib/core.js';
import { UInt32, UInt64, Sign } from '../lib/int.js';
import { PublicKey } from '../lib/signature.js';
export { PublicKey, Field, Bool, AuthRequired, UInt64, UInt32, Sign, TokenId };
export { Events, Actions, ZkappUri, TokenSymbol, ActionState, ReceiptChainHash, StateHash, };
type AuthRequired = {
    constant: Bool;
    signatureNecessary: Bool;
    signatureSufficient: Bool;
};
type TokenId = Field;
type StateHash = Field;
type TokenSymbol = {
    symbol: string;
    field: Field;
};
type ZkappUri = {
    data: string;
    hash: Field;
};
declare const TokenId: {
    emptyValue(): Field;
    toJSON(x: Field): string;
    fromJSON(x: string): Field;
    toFields: (x: Field) => Field[];
    toAuxiliary: (x?: Field | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => Field;
    sizeInFields(): number;
    check: (x: Field) => void;
    toInput: (x: Field) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
}, StateHash: {
    toJSON(x: Field): string;
    fromJSON(x: string): Field;
    toFields: (x: Field) => Field[];
    toAuxiliary: (x?: Field | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => Field;
    sizeInFields(): number;
    check: (x: Field) => void;
    toInput: (x: Field) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    emptyValue?: (() => Field) | undefined;
}, TokenSymbol: {
    toInput({ field }: {
        symbol: string;
        field: Field;
    }): import("./generic.js").GenericHashInput<Field>;
    toJSON({ symbol }: {
        symbol: string;
        field: Field;
    }): string;
    fromJSON(symbol: string): {
        symbol: string;
        field: Field;
    };
    toFields: (x: {
        field: Field;
        symbol: string;
    }) => Field[];
    toAuxiliary: (x?: {
        field: Field;
        symbol: string;
    } | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => {
        field: Field;
        symbol: string;
    };
    sizeInFields(): number;
    check: (x: {
        field: Field;
        symbol: string;
    }) => void;
    emptyValue?: (() => {
        field: Field;
        symbol: string;
    }) | undefined;
}, AuthRequired: {
    emptyValue(): {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    };
    toJSON(x: {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    }): import("./transaction-leaves-json.js").AuthRequired;
    fromJSON(json: import("./transaction-leaves-json.js").AuthRequired): {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    };
    toFields: (x: {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    }) => Field[];
    toAuxiliary: (x?: {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    } | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    };
    sizeInFields(): number;
    check: (x: {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    }) => void;
    toInput: (x: {
        constant: Bool;
        signatureNecessary: Bool;
        signatureSufficient: Bool;
    }) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
}, ZkappUri: import("./generic.js").GenericProvable<{
    data: string;
    hash: Field;
}, Field> & {
    toInput: (x: {
        data: string;
        hash: Field;
    }) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    toJSON: (x: {
        data: string;
        hash: Field;
    }) => string;
    fromJSON: (x: string) => {
        data: string;
        hash: Field;
    };
    emptyValue?: (() => {
        data: string;
        hash: Field;
    }) | undefined;
} & {
    emptyValue(): {
        data: string;
        hash: Field;
    };
};
type Event = Field[];
type Events = {
    hash: Field;
    data: Event[];
};
type Actions = Events;
declare const Events: {
    toFields: (x: {
        data: Field[][];
        hash: Field;
    }) => Field[];
    toAuxiliary: (x?: {
        data: Field[][];
        hash: Field;
    } | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => {
        data: Field[][];
        hash: Field;
    };
    sizeInFields(): number;
    check: (x: {
        data: Field[][];
        hash: Field;
    }) => void;
    toInput: (x: {
        data: Field[][];
        hash: Field;
    }) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    toJSON: (x: {
        data: Field[][];
        hash: Field;
    }) => string[][];
    fromJSON: (x: string[][]) => {
        data: Field[][];
        hash: Field;
    };
    emptyValue: (() => {
        data: Field[][];
        hash: Field;
    }) & (() => {
        data: Field[][];
        hash: Field;
    });
    empty(): {
        hash: Field;
        data: Field[][];
    };
    pushEvent(events: {
        hash: Field;
        data: Field[][];
    }, event: Field[]): {
        hash: Field;
        data: Field[][];
    };
    fromList(events: Field[][]): {
        hash: Field;
        data: Field[][];
    };
    hash(events: Field[][]): Field;
}, Actions: {
    toFields: (x: {
        data: Field[][];
        hash: Field;
    }) => Field[];
    toAuxiliary: (x?: {
        data: Field[][];
        hash: Field;
    } | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => {
        data: Field[][];
        hash: Field;
    };
    sizeInFields(): number;
    check: (x: {
        data: Field[][];
        hash: Field;
    }) => void;
    toInput: (x: {
        data: Field[][];
        hash: Field;
    }) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    toJSON: (x: {
        data: Field[][];
        hash: Field;
    }) => string[][];
    fromJSON: (x: string[][]) => {
        data: Field[][];
        hash: Field;
    };
    emptyValue: (() => {
        data: Field[][];
        hash: Field;
    }) & (() => {
        data: Field[][];
        hash: Field;
    });
    empty(): {
        hash: Field;
        data: Field[][];
    };
    pushEvent(actions: {
        hash: Field;
        data: Field[][];
    }, event: Field[]): {
        hash: Field;
        data: Field[][];
    };
    fromList(events: Field[][]): {
        hash: Field;
        data: Field[][];
    };
    hash(events: Field[][]): Field;
    emptyActionState(): Field;
    updateSequenceState(state: Field, sequenceEventsHash: Field): Field;
};
type ActionState = Field;
declare const ActionState: {
    emptyValue: () => Field;
    toFields: (x: Field) => Field[];
    toAuxiliary: (x?: Field | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => Field;
    sizeInFields(): number;
    check: (x: Field) => void;
    toInput: (x: Field) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    toJSON: (x: Field) => string;
    fromJSON: (x: string) => Field;
};
type ReceiptChainHash = Field;
declare const ReceiptChainHash: {
    emptyValue: () => Field;
    toFields: (x: Field) => Field[];
    toAuxiliary: (x?: Field | undefined) => any[];
    fromFields: (x: Field[], aux: any[]) => Field;
    sizeInFields(): number;
    check: (x: Field) => void;
    toInput: (x: Field) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    toJSON: (x: Field) => string;
    fromJSON: (x: string) => Field;
};
