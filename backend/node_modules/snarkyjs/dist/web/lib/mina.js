import { Circuit, Ledger } from '../snarky.js';
import { Field } from './core.js';
import { UInt32, UInt64 } from './int.js';
import { PrivateKey, PublicKey } from './signature.js';
import { addMissingProofs, addMissingSignatures, ZkappCommand, AccountUpdate, ZkappPublicInput, TokenId, CallForest, Authorization, Actions, } from './account_update.js';
import * as Fetch from './fetch.js';
import { assertPreconditionInvariants } from './precondition.js';
import { cloneCircuitValue, toConstant } from './circuit_value.js';
import { verify } from './proof_system.js';
import { Context } from './global-context.js';
import { SmartContract } from './zkapp.js';
import { invalidTransactionError } from './errors.js';
import { Types } from '../provable/types.js';
import { Account } from './mina/account.js';
export { createTransaction, BerkeleyQANet, Network, LocalBlockchain, currentTransaction, Transaction, activeInstance, setActiveInstance, transaction, sender, currentSlot, getAccount, hasAccount, getBalance, getNetworkState, accountCreationFee, sendTransaction, fetchEvents, fetchActions, getActions, faucet, waitForFunding, getProofsEnabled, 
// for internal testing only
filterGroups, };
const Transaction = {
    fromJSON(json) {
        let transaction = ZkappCommand.fromJSON(json);
        return newTransaction(transaction, activeInstance.proofsEnabled);
    },
};
let currentTransaction = Context.create();
function reportGetAccountError(publicKey, tokenId) {
    if (tokenId === TokenId.toBase58(TokenId.default)) {
        return `getAccount: Could not find account for public key ${publicKey}`;
    }
    else {
        return `getAccount: Could not find account for public key ${publicKey} with the tokenId ${tokenId}`;
    }
}
function createTransaction(feePayer, f, numberOfRuns, { fetchMode = 'cached', isFinalRunOutsideCircuit = true, proofsEnabled = true, } = {}) {
    if (currentTransaction.has()) {
        throw new Error('Cannot start new transaction within another transaction');
    }
    let feePayerSpec;
    if (feePayer === undefined) {
        feePayerSpec = {};
    }
    else if (feePayer instanceof PrivateKey) {
        feePayerSpec = { feePayerKey: feePayer, sender: feePayer.toPublicKey() };
    }
    else if (feePayer instanceof PublicKey) {
        feePayerSpec = { sender: feePayer };
    }
    else {
        feePayerSpec = feePayer;
        if (feePayerSpec.sender === undefined)
            feePayerSpec.sender = feePayerSpec.feePayerKey?.toPublicKey();
    }
    let { feePayerKey, sender, fee, memo = '', nonce } = feePayerSpec;
    let transactionId = currentTransaction.enter({
        sender,
        accountUpdates: [],
        fetchMode,
        isFinalRunOutsideCircuit,
        numberOfRuns,
    });
    // run circuit
    // we have this while(true) loop because one of the smart contracts we're calling inside `f` might be calling
    // SmartContract.analyzeMethods, which would be running its methods again inside `Circuit.constraintSystem`, which
    // would throw an error when nested inside `Circuit.runAndCheck`. So if that happens, we have to run `analyzeMethods` first
    // and retry `Circuit.runAndCheck(f)`. Since at this point in the function, we don't know which smart contracts are involved,
    // we created that hack with a `bootstrap()` function that analyzeMethods sticks on the error, to call itself again.
    try {
        let err;
        while (true) {
            if (err !== undefined)
                err.bootstrap();
            try {
                if (fetchMode === 'test') {
                    Circuit.runUnchecked(() => {
                        f();
                        Circuit.asProver(() => {
                            let tx = currentTransaction.get();
                            tx.accountUpdates = CallForest.map(tx.accountUpdates, (a) => toConstant(AccountUpdate, a));
                        });
                    });
                }
                else {
                    f();
                }
                break;
            }
            catch (err_) {
                if (err_?.bootstrap)
                    err = err_;
                else
                    throw err_;
            }
        }
    }
    catch (err) {
        currentTransaction.leave(transactionId);
        throw err;
    }
    let accountUpdates = currentTransaction.get().accountUpdates;
    // TODO: I'll be back
    // CallForest.addCallers(accountUpdates);
    accountUpdates = CallForest.toFlatList(accountUpdates);
    try {
        // check that on-chain values weren't used without setting a precondition
        for (let accountUpdate of accountUpdates) {
            assertPreconditionInvariants(accountUpdate);
        }
    }
    catch (err) {
        currentTransaction.leave(transactionId);
        throw err;
    }
    let feePayerAccountUpdate;
    if (sender !== undefined) {
        // if senderKey is provided, fetch account to get nonce and mark to be signed
        let nonce_;
        let senderAccount = getAccount(sender, TokenId.default);
        if (nonce === undefined) {
            nonce_ = senderAccount.nonce;
        }
        else {
            nonce_ = UInt32.from(nonce);
            senderAccount.nonce = nonce_;
            Fetch.addCachedAccount(senderAccount);
        }
        feePayerAccountUpdate = AccountUpdate.defaultFeePayer(sender, nonce_);
        if (feePayerKey !== undefined)
            feePayerAccountUpdate.lazyAuthorization.privateKey = feePayerKey;
        if (fee !== undefined) {
            feePayerAccountUpdate.body.fee =
                fee instanceof UInt64 ? fee : UInt64.from(String(fee));
        }
    }
    else {
        // otherwise use a dummy fee payer that has to be filled in later
        feePayerAccountUpdate = AccountUpdate.dummyFeePayer();
    }
    let transaction = {
        accountUpdates,
        feePayer: feePayerAccountUpdate,
        memo,
    };
    currentTransaction.leave(transactionId);
    return newTransaction(transaction, proofsEnabled);
}
function newTransaction(transaction, proofsEnabled) {
    let self = {
        transaction,
        sign(additionalKeys) {
            self.transaction = addMissingSignatures(self.transaction, additionalKeys);
            return self;
        },
        async prove() {
            let { zkappCommand, proofs } = await addMissingProofs(self.transaction, {
                proofsEnabled,
            });
            self.transaction = zkappCommand;
            return proofs;
        },
        toJSON() {
            let json = ZkappCommand.toJSON(self.transaction);
            return JSON.stringify(json);
        },
        toPretty() {
            return ZkappCommand.toPretty(self.transaction);
        },
        toGraphqlQuery() {
            return Fetch.sendZkappQuery(self.toJSON());
        },
        async send() {
            return await sendTransaction(self);
        },
    };
    return self;
}
const defaultAccountCreationFee = 1000000000;
/**
 * A mock Mina blockchain running locally and useful for testing.
 */
function LocalBlockchain({ accountCreationFee = defaultAccountCreationFee, proofsEnabled = true, enforceTransactionLimits = true, } = {}) {
    const slotTime = 3 * 60 * 1000;
    const startTime = Date.now();
    const genesisTimestamp = UInt64.from(startTime);
    const ledger = Ledger.create([]);
    let networkState = defaultNetworkState();
    function addAccount(pk, balance) {
        ledger.addAccount(pk, balance);
    }
    let testAccounts = [];
    for (let i = 0; i < 10; ++i) {
        let MINA = 10n ** 9n;
        const largeValue = 1000n * MINA;
        const k = PrivateKey.random();
        const pk = k.toPublicKey();
        addAccount(pk, largeValue.toString());
        testAccounts.push({ privateKey: k, publicKey: pk });
    }
    const events = {};
    const actions = {};
    return {
        proofsEnabled,
        accountCreationFee: () => UInt64.from(accountCreationFee),
        getNetworkConstants() {
            return {
                genesisTimestamp,
                accountCreationFee: UInt64.from(accountCreationFee),
                slotTime: UInt64.from(slotTime),
            };
        },
        currentSlot() {
            return UInt32.from(Math.ceil((new Date().valueOf() - startTime) / slotTime));
        },
        hasAccount(publicKey, tokenId = TokenId.default) {
            return !!ledger.getAccount(publicKey, tokenId);
        },
        getAccount(publicKey, tokenId = TokenId.default) {
            let accountJson = ledger.getAccount(publicKey, tokenId);
            if (accountJson === undefined) {
                throw new Error(reportGetAccountError(publicKey.toBase58(), TokenId.toBase58(tokenId)));
            }
            return Types.Account.fromJSON(accountJson);
        },
        getNetworkState() {
            return networkState;
        },
        async sendTransaction(txn) {
            txn.sign();
            let commitments = Ledger.transactionCommitments(JSON.stringify(ZkappCommand.toJSON(txn.transaction)));
            if (enforceTransactionLimits)
                verifyTransactionLimits(txn.transaction.accountUpdates);
            for (const update of txn.transaction.accountUpdates) {
                let accountJson = ledger.getAccount(update.body.publicKey, update.body.tokenId);
                if (accountJson) {
                    let account = Account.fromJSON(accountJson);
                    await verifyAccountUpdate(account, update, commitments, proofsEnabled);
                }
            }
            let zkappCommandJson = ZkappCommand.toJSON(txn.transaction);
            try {
                ledger.applyJsonTransaction(JSON.stringify(zkappCommandJson), String(accountCreationFee), JSON.stringify(networkState));
            }
            catch (err) {
                try {
                    // reverse errors so they match order of account updates
                    // TODO: label updates, and try to give precise explanations about what went wrong
                    let errors = JSON.parse(err.message);
                    err.message = invalidTransactionError(txn.transaction, errors, {
                        accountCreationFee,
                    });
                }
                finally {
                    throw err;
                }
            }
            // fetches all events from the transaction and stores them
            // events are identified and associated with a publicKey and tokenId
            txn.transaction.accountUpdates.forEach((p, i) => {
                var _a, _b;
                let pJson = zkappCommandJson.accountUpdates[i];
                let addr = pJson.body.publicKey;
                let tokenId = pJson.body.tokenId;
                events[addr] ?? (events[addr] = {});
                if (p.body.events.data.length > 0) {
                    (_a = events[addr])[tokenId] ?? (_a[tokenId] = []);
                    let updatedEvents = p.body.events.data.map((data) => {
                        return {
                            data,
                            transactionInfo: {
                                transactionHash: '',
                                transactionStatus: '',
                                transactionMemo: '',
                            },
                        };
                    });
                    events[addr][tokenId].push({
                        events: updatedEvents,
                        blockHeight: networkState.blockchainLength,
                        globalSlot: networkState.globalSlotSinceGenesis,
                        // The following fields are fetched from the Mina network. For now, we mock these values out
                        // since networkState does not contain these fields.
                        blockHash: '',
                        parentBlockHash: '',
                        chainStatus: '',
                    });
                }
                // actions/sequencing events
                // most recent action state
                let storedActions = actions[addr]?.[tokenId];
                let latestActionState_ = storedActions?.[storedActions.length - 1]?.hash;
                // if there exists no hash, this means we initialize our latest hash with the empty state
                let latestActionState = latestActionState_ !== undefined
                    ? Field(latestActionState_)
                    : Actions.emptyActionState();
                actions[addr] ?? (actions[addr] = {});
                if (p.body.actions.data.length > 0) {
                    let newActionState = Actions.updateSequenceState(latestActionState, p.body.actions.hash);
                    (_b = actions[addr])[tokenId] ?? (_b[tokenId] = []);
                    actions[addr][tokenId].push({
                        actions: pJson.body.actions,
                        hash: newActionState.toString(),
                    });
                }
            });
            return {
                isSuccess: true,
                wait: async (_options) => {
                    console.log('Info: Waiting for inclusion in a block is not supported for LocalBlockchain.');
                },
                hash: () => {
                    const message = 'Info: Txn Hash retrieving is not supported for LocalBlockchain.';
                    console.log(message);
                    return message;
                },
            };
        },
        async transaction(sender, f) {
            // bad hack: run transaction just to see whether it creates proofs
            // if it doesn't, this is the last chance to run SmartContract.runOutsideCircuit, which is supposed to run only once
            // TODO: this has obvious holes if multiple zkapps are involved, but not relevant currently because we can't prove with multiple account updates
            // and hopefully with upcoming work by Matt we can just run everything in the prover, and nowhere else
            let tx = createTransaction(sender, f, 0, {
                isFinalRunOutsideCircuit: false,
                proofsEnabled,
                fetchMode: 'test',
            });
            let hasProofs = tx.transaction.accountUpdates.some(Authorization.hasLazyProof);
            return createTransaction(sender, f, 1, {
                isFinalRunOutsideCircuit: !hasProofs,
                proofsEnabled,
            });
        },
        applyJsonTransaction(json) {
            return ledger.applyJsonTransaction(json, String(accountCreationFee), JSON.stringify(networkState));
        },
        async fetchEvents(publicKey, tokenId = TokenId.default) {
            return events?.[publicKey.toBase58()]?.[TokenId.toBase58(tokenId)] ?? [];
        },
        async fetchActions(publicKey, actionStates, tokenId = TokenId.default) {
            return this.getActions(publicKey, actionStates, tokenId);
        },
        getActions(publicKey, actionStates, tokenId = TokenId.default) {
            let currentActions = actions?.[publicKey.toBase58()]?.[TokenId.toBase58(tokenId)] ?? [];
            let { fromActionState, endActionState } = actionStates ?? {};
            let start = fromActionState
                ?.equals(Actions.emptyActionState())
                .toBoolean()
                ? undefined
                : fromActionState?.toString();
            let end = endActionState?.toString();
            let startIndex = 0;
            if (start) {
                let i = currentActions.findIndex((e) => e.hash === start);
                if (i === -1)
                    throw Error(`getActions: fromActionState not found.`);
                startIndex = i + 1;
            }
            let endIndex;
            if (end) {
                let i = currentActions.findIndex((e) => e.hash === end);
                if (i === -1)
                    throw Error(`getActions: endActionState not found.`);
                endIndex = i + 1;
            }
            return currentActions.slice(startIndex, endIndex);
        },
        addAccount,
        /**
         * An array of 10 test accounts that have been pre-filled with
         * 30000000000 units of currency.
         */
        testAccounts,
        setGlobalSlot(slot) {
            networkState.globalSlotSinceGenesis = UInt32.from(slot);
            let difference = networkState.globalSlotSinceGenesis.sub(slot);
        },
        incrementGlobalSlot(increment) {
            networkState.globalSlotSinceGenesis =
                networkState.globalSlotSinceGenesis.add(increment);
        },
        setBlockchainLength(height) {
            networkState.blockchainLength = height;
        },
        setTotalCurrency(currency) {
            networkState.totalCurrency = currency;
        },
        setProofsEnabled(newProofsEnabled) {
            proofsEnabled = newProofsEnabled;
        },
    };
}
// assert type compatibility without preventing LocalBlockchain to return additional properties / methods
LocalBlockchain;
function Network(input) {
    let accountCreationFee = UInt64.from(defaultAccountCreationFee);
    let graphqlEndpoint;
    let archiveEndpoint;
    if (input && typeof input === 'string') {
        graphqlEndpoint = input;
        Fetch.setGraphqlEndpoint(graphqlEndpoint);
    }
    else if (input && typeof input === 'object') {
        graphqlEndpoint = input.mina;
        archiveEndpoint = input.archive;
        Fetch.setGraphqlEndpoint(graphqlEndpoint);
        Fetch.setArchiveGraphqlEndpoint(archiveEndpoint);
    }
    else {
        throw new Error("Network: malformed input. Please provide a string or an object with 'mina' and 'archive' endpoints.");
    }
    // copied from mina/genesis_ledgers/berkeley.json
    // TODO fetch from graphql instead of hardcoding
    const genesisTimestampString = '2023-02-23T20:00:01Z';
    const genesisTimestamp = UInt64.from(Date.parse(genesisTimestampString.slice(0, -1) + '+00:00'));
    // TODO also fetch from graphql
    const slotTime = UInt64.from(3 * 60 * 1000);
    return {
        accountCreationFee: () => accountCreationFee,
        getNetworkConstants() {
            return {
                genesisTimestamp,
                slotTime,
                accountCreationFee,
            };
        },
        currentSlot() {
            throw Error('currentSlot() is not implemented yet for remote blockchains.');
        },
        hasAccount(publicKey, tokenId = TokenId.default) {
            if (!currentTransaction.has() ||
                currentTransaction.get().fetchMode === 'cached') {
                return !!Fetch.getCachedAccount(publicKey, tokenId, graphqlEndpoint);
            }
            return false;
        },
        getAccount(publicKey, tokenId = TokenId.default) {
            if (currentTransaction()?.fetchMode === 'test') {
                Fetch.markAccountToBeFetched(publicKey, tokenId, graphqlEndpoint);
                let account = Fetch.getCachedAccount(publicKey, tokenId, graphqlEndpoint);
                return account ?? dummyAccount(publicKey);
            }
            if (!currentTransaction.has() ||
                currentTransaction.get().fetchMode === 'cached') {
                let account = Fetch.getCachedAccount(publicKey, tokenId, graphqlEndpoint);
                if (account !== undefined)
                    return account;
            }
            throw Error(`${reportGetAccountError(publicKey.toBase58(), TokenId.toBase58(tokenId))}\nGraphql endpoint: ${graphqlEndpoint}`);
        },
        getNetworkState() {
            if (currentTransaction()?.fetchMode === 'test') {
                Fetch.markNetworkToBeFetched(graphqlEndpoint);
                let network = Fetch.getCachedNetwork(graphqlEndpoint);
                return network ?? defaultNetworkState();
            }
            if (!currentTransaction.has() ||
                currentTransaction.get().fetchMode === 'cached') {
                let network = Fetch.getCachedNetwork(graphqlEndpoint);
                if (network !== undefined)
                    return network;
            }
            throw Error(`getNetworkState: Could not fetch network state from graphql endpoint ${graphqlEndpoint}`);
        },
        async sendTransaction(txn) {
            txn.sign();
            verifyTransactionLimits(txn.transaction.accountUpdates);
            let [response, error] = await Fetch.sendZkapp(txn.toJSON());
            let errors;
            if (error === undefined) {
                if (response.data === null && response.errors?.length > 0) {
                    console.log('got graphql errors', JSON.stringify(response.errors, null, 2));
                    errors = response.errors;
                }
            }
            else {
                console.log('got fetch error', error);
                errors = [error];
            }
            let isSuccess = errors === undefined;
            let maxAttempts;
            let attempts = 0;
            let interval;
            return {
                isSuccess,
                data: response?.data,
                errors,
                async wait(options) {
                    if (!isSuccess) {
                        console.warn('Transaction.wait(): returning immediately because the transaction was not successful.');
                        return;
                    }
                    // default is 45 attempts * 20s each = 15min
                    // the block time on berkeley is currently longer than the average 3-4min, so its better to target a higher block time
                    // fetching an update every 20s is more than enough with a current block time of 3min
                    maxAttempts = options?.maxAttempts ?? 45;
                    interval = options?.interval ?? 20000;
                    const executePoll = async (resolve, reject) => {
                        let txId = response?.data?.sendZkapp?.zkapp?.id;
                        let res;
                        try {
                            res = await Fetch.fetchTransactionStatus(txId);
                        }
                        catch (error) {
                            return reject(error);
                        }
                        attempts++;
                        if (res === 'INCLUDED') {
                            return resolve();
                        }
                        else if (maxAttempts && attempts === maxAttempts) {
                            return reject(new Error(`Exceeded max attempts. TransactionId: ${txId}, attempts: ${attempts}, last received status: ${res}`));
                        }
                        else {
                            setTimeout(executePoll, interval, resolve, reject);
                        }
                    };
                    return new Promise(executePoll);
                },
                hash() {
                    return response?.data?.sendZkapp?.zkapp?.hash;
                },
            };
        },
        async transaction(sender, f) {
            let tx = createTransaction(sender, f, 0, {
                fetchMode: 'test',
                isFinalRunOutsideCircuit: false,
            });
            await Fetch.fetchMissingData(graphqlEndpoint, archiveEndpoint);
            let hasProofs = tx.transaction.accountUpdates.some(Authorization.hasLazyProof);
            return createTransaction(sender, f, 1, {
                fetchMode: 'cached',
                isFinalRunOutsideCircuit: !hasProofs,
            });
        },
        async fetchEvents(publicKey, tokenId = TokenId.default, filterOptions = {}) {
            let pubKey = publicKey.toBase58();
            let token = TokenId.toBase58(tokenId);
            return Fetch.fetchEvents({ publicKey: pubKey, tokenId: token }, archiveEndpoint, filterOptions);
        },
        async fetchActions(publicKey, actionStates, tokenId = TokenId.default) {
            let pubKey = publicKey.toBase58();
            let token = TokenId.toBase58(tokenId);
            let { fromActionState, endActionState } = actionStates ?? {};
            let fromActionStateBase58 = fromActionState
                ? fromActionState.toString()
                : undefined;
            let endActionStateBase58 = endActionState
                ? endActionState.toString()
                : undefined;
            return Fetch.fetchActions({
                publicKey: pubKey,
                actionStates: {
                    fromActionState: fromActionStateBase58,
                    endActionState: endActionStateBase58,
                },
                tokenId: token,
            }, archiveEndpoint);
        },
        getActions(publicKey, actionStates, tokenId = TokenId.default) {
            if (currentTransaction()?.fetchMode === 'test') {
                Fetch.markActionsToBeFetched(publicKey, tokenId, archiveEndpoint, actionStates);
                let actions = Fetch.getCachedActions(publicKey, tokenId);
                return actions ?? [];
            }
            if (!currentTransaction.has() ||
                currentTransaction.get().fetchMode === 'cached') {
                let actions = Fetch.getCachedActions(publicKey, tokenId);
                if (actions !== undefined)
                    return actions;
            }
            throw Error(`getActions: Could not find actions for the public key ${publicKey}`);
        },
        proofsEnabled: true,
    };
}
/**
 *
 * @deprecated This is deprecated in favor of {@link Mina.Network}, which is exactly the same function.
 * The name `BerkeleyQANet` was misleading because it suggested that this is specific to a particular network.
 */
function BerkeleyQANet(graphqlEndpoint) {
    return Network(graphqlEndpoint);
}
let activeInstance = {
    accountCreationFee: () => UInt64.from(defaultAccountCreationFee),
    getNetworkConstants() {
        throw new Error('must call Mina.setActiveInstance first');
    },
    currentSlot: () => {
        throw new Error('must call Mina.setActiveInstance first');
    },
    hasAccount(publicKey, tokenId = TokenId.default) {
        if (!currentTransaction.has() ||
            currentTransaction.get().fetchMode === 'cached') {
            return !!Fetch.getCachedAccount(publicKey, tokenId, Fetch.defaultGraphqlEndpoint);
        }
        return false;
    },
    getAccount(publicKey, tokenId = TokenId.default) {
        if (currentTransaction()?.fetchMode === 'test') {
            Fetch.markAccountToBeFetched(publicKey, tokenId, Fetch.defaultGraphqlEndpoint);
            return dummyAccount(publicKey);
        }
        if (!currentTransaction.has() ||
            currentTransaction.get().fetchMode === 'cached') {
            let account = Fetch.getCachedAccount(publicKey, tokenId, Fetch.defaultGraphqlEndpoint);
            if (account === undefined)
                throw Error(`${reportGetAccountError(publicKey.toBase58(), TokenId.toBase58(tokenId))}\n\nEither call Mina.setActiveInstance first or explicitly add the account with addCachedAccount`);
            return account;
        }
        throw new Error('must call Mina.setActiveInstance first');
    },
    getNetworkState() {
        throw new Error('must call Mina.setActiveInstance first');
    },
    sendTransaction() {
        throw new Error('must call Mina.setActiveInstance first');
    },
    async transaction(sender, f) {
        return createTransaction(sender, f, 0);
    },
    fetchEvents(_publicKey, _tokenId = TokenId.default) {
        throw Error('must call Mina.setActiveInstance first');
    },
    fetchActions(_publicKey, _actionStates, _tokenId = TokenId.default) {
        throw Error('must call Mina.setActiveInstance first');
    },
    getActions(_publicKey, _actionStates, _tokenId = TokenId.default) {
        throw Error('must call Mina.setActiveInstance first');
    },
    proofsEnabled: true,
};
/**
 * Set the currently used Mina instance.
 */
function setActiveInstance(m) {
    activeInstance = m;
}
function transaction(senderOrF, fOrUndefined) {
    let sender;
    let f;
    if (fOrUndefined !== undefined) {
        sender = senderOrF;
        f = fOrUndefined;
    }
    else {
        sender = undefined;
        f = senderOrF;
    }
    return activeInstance.transaction(sender, f);
}
/**
 * Returns the public key of the current transaction's sender account.
 *
 * Throws an error if not inside a transaction, or the sender wasn't passed in.
 */
function sender() {
    let tx = currentTransaction();
    if (tx === undefined)
        throw Error(`The sender is not available outside a transaction. Make sure you only use it within \`Mina.transaction\` blocks or smart contract methods.`);
    let sender = currentTransaction()?.sender;
    if (sender === undefined)
        throw Error(`The sender is not available, because the transaction block was created without the optional \`sender\` argument.
Here's an example for how to pass in the sender and make it available:

Mina.transaction(sender, // <-- pass in sender's public key here
() => {
  // methods can use this.sender
});
`);
    return sender;
}
/**
 * @return The current slot number, according to the active Mina instance.
 */
function currentSlot() {
    return activeInstance.currentSlot();
}
/**
 * @return The account data associated to the given public key.
 */
function getAccount(publicKey, tokenId) {
    return activeInstance.getAccount(publicKey, tokenId);
}
/**
 * Checks if an account exists within the ledger.
 */
function hasAccount(publicKey, tokenId) {
    return activeInstance.hasAccount(publicKey, tokenId);
}
/**
 * @return Data associated with the current state of the Mina network.
 */
function getNetworkState() {
    return activeInstance.getNetworkState();
}
/**
 * @return The balance associated to the given public key.
 */
function getBalance(publicKey, tokenId) {
    return activeInstance.getAccount(publicKey, tokenId).balance;
}
/**
 * Returns the default account creation fee.
 */
function accountCreationFee() {
    return activeInstance.accountCreationFee();
}
async function sendTransaction(txn) {
    return await activeInstance.sendTransaction(txn);
}
/**
 * @return A list of emitted events associated to the given public key.
 */
async function fetchEvents(publicKey, tokenId, filterOptions = {}) {
    return await activeInstance.fetchEvents(publicKey, tokenId, filterOptions);
}
/**
 * @return A list of emitted sequencing actions associated to the given public key.
 */
async function fetchActions(publicKey, actionStates, tokenId) {
    return await activeInstance.fetchActions(publicKey, actionStates, tokenId);
}
/**
 * @return A list of emitted sequencing actions associated to the given public key.
 */
function getActions(publicKey, actionStates, tokenId) {
    return activeInstance.getActions(publicKey, actionStates, tokenId);
}
function getProofsEnabled() {
    return activeInstance.proofsEnabled;
}
function dummyAccount(pubkey) {
    let dummy = Types.Account.emptyValue();
    if (pubkey)
        dummy.publicKey = pubkey;
    return dummy;
}
function defaultNetworkState() {
    let epochData = {
        ledger: { hash: Field(0), totalCurrency: UInt64.zero },
        seed: Field(0),
        startCheckpoint: Field(0),
        lockCheckpoint: Field(0),
        epochLength: UInt32.zero,
    };
    return {
        snarkedLedgerHash: Field(0),
        blockchainLength: UInt32.zero,
        minWindowDensity: UInt32.zero,
        totalCurrency: UInt64.zero,
        globalSlotSinceGenesis: UInt32.zero,
        stakingEpochData: epochData,
        nextEpochData: cloneCircuitValue(epochData),
    };
}
async function verifyAccountUpdate(account, accountUpdate, transactionCommitments, proofsEnabled) {
    // check that that top-level updates have mayUseToken = No
    // (equivalent check exists in the Mina node)
    if (accountUpdate.body.callDepth === 0 &&
        !AccountUpdate.MayUseToken.isNo(accountUpdate).toBoolean()) {
        throw Error('Top-level account update can not use or pass on token permissions. Make sure that\n' +
            'accountUpdate.body.mayUseToken = AccountUpdate.MayUseToken.No;');
    }
    let perm = account.permissions;
    let { commitment, fullCommitment } = transactionCommitments;
    // we are essentially only checking if the update is empty or an actual update
    function includesChange(val) {
        if (Array.isArray(val)) {
            return !val.every((v) => v === null);
        }
        else {
            return val !== null;
        }
    }
    function permissionForUpdate(key) {
        switch (key) {
            case 'appState':
                return perm.editState;
            case 'delegate':
                return perm.setDelegate;
            case 'verificationKey':
                return perm.setVerificationKey;
            case 'permissions':
                return perm.setPermissions;
            case 'zkappUri':
                return perm.setZkappUri;
            case 'tokenSymbol':
                return perm.setTokenSymbol;
            case 'timing':
                return perm.setTiming;
            case 'votingFor':
                return perm.setVotingFor;
            case 'actions':
                return perm.editActionState;
            case 'incrementNonce':
                return perm.incrementNonce;
            case 'send':
                return perm.send;
            case 'receive':
                return perm.receive;
            default:
                throw Error(`Invalid permission for field ${key}: does not exist.`);
        }
    }
    const update = accountUpdate.toJSON().body.update;
    let errorTrace = '';
    let isValidProof = false;
    let isValidSignature = false;
    // we don't check if proofs aren't enabled
    if (!proofsEnabled)
        isValidProof = true;
    if (accountUpdate.authorization.proof && proofsEnabled) {
        try {
            let publicInput = accountUpdate.toPublicInput();
            let publicInputFields = ZkappPublicInput.toFields(publicInput);
            const proof = SmartContract.Proof().fromJSON({
                maxProofsVerified: 2,
                proof: accountUpdate.authorization.proof,
                publicInput: publicInputFields.map((f) => f.toString()),
            });
            let verificationKey = account.zkapp?.verificationKey?.data;
            isValidProof = await verify(proof.toJSON(), verificationKey);
            if (!isValidProof) {
                throw Error(`Invalid proof for account update\n${JSON.stringify(update)}`);
            }
        }
        catch (error) {
            errorTrace += '\n\n' + error.message;
            isValidProof = false;
        }
    }
    if (accountUpdate.authorization.signature) {
        let txC = accountUpdate.body.useFullCommitment.toBoolean()
            ? fullCommitment
            : commitment;
        // checking permissions and authorization for each party individually
        try {
            isValidSignature = Ledger.checkAccountUpdateSignature(JSON.stringify(accountUpdate.toJSON()), txC);
        }
        catch (error) {
            errorTrace += '\n\n' + error.message;
            isValidSignature = false;
        }
    }
    let verified = false;
    function checkPermission(p0, field) {
        let p = Types.AuthRequired.toJSON(p0);
        if (p === 'None')
            return;
        if (p === 'Impossible') {
            throw Error(`Transaction verification failed: Cannot update field '${field}' because permission for this field is '${p}'`);
        }
        if (p === 'Signature' || p === 'Either') {
            verified || (verified = isValidSignature);
        }
        if (p === 'Proof' || p === 'Either') {
            verified || (verified = isValidProof);
        }
        if (!verified) {
            throw Error(`Transaction verification failed: Cannot update field '${field}' because permission for this field is '${p}', but the required authorization was not provided or is invalid.
        ${errorTrace !== '' ? 'Error trace: ' + errorTrace : ''}`);
        }
    }
    // goes through the update field on a transaction
    Object.entries(update).forEach(([key, value]) => {
        if (includesChange(value)) {
            let p = permissionForUpdate(key);
            checkPermission(p, key);
        }
    });
    // checks the sequence events (which result in an updated sequence state)
    if (accountUpdate.body.actions.data.length > 0) {
        let p = permissionForUpdate('actions');
        checkPermission(p, 'actions');
    }
    if (accountUpdate.body.incrementNonce.toBoolean()) {
        let p = permissionForUpdate('incrementNonce');
        checkPermission(p, 'incrementNonce');
    }
    // this checks for an edge case where an account update can be approved using proofs but
    // a) the proof is invalid (bad verification key)
    // and b) there are no state changes initiate so no permissions will be checked
    // however, if the verification key changes, the proof should still be invalid
    if (errorTrace && !verified) {
        throw Error(`One or more proofs were invalid and no other form of authorization was provided.\n${errorTrace}`);
    }
}
function verifyTransactionLimits(accountUpdates) {
    // constants used to calculate cost of a transaction - originally defined in the genesis_constants file in the mina repo
    const proofCost = 10.26;
    const signedPairCost = 10.08;
    const signedSingleCost = 9.14;
    const costLimit = 69.45;
    // constants that define the maximum number of events in one transaction
    const maxActionElements = 16;
    const maxEventElements = 16;
    let eventElements = { events: 0, actions: 0 };
    let authTypes = filterGroups(accountUpdates.map((update) => {
        let json = update.toJSON();
        eventElements.events += countEventElements(update.body.events);
        eventElements.actions += countEventElements(update.body.actions);
        return json.body.authorizationKind;
    }));
    /*
    np := proof
    n2 := signedPair
    n1 := signedSingle
    
    formula used to calculate how expensive a zkapp transaction is
  
    10.26*np + 10.08*n2 + 9.14*n1 < 69.45
    */
    let totalTimeRequired = proofCost * authTypes.proof +
        signedPairCost * authTypes.signedPair +
        signedSingleCost * authTypes.signedSingle;
    let isWithinCostLimit = totalTimeRequired < costLimit;
    let isWithinEventsLimit = eventElements.events <= maxEventElements;
    let isWithinActionsLimit = eventElements.actions <= maxActionElements;
    let error = '';
    if (!isWithinCostLimit) {
        // TODO: we should add a link to the docs explaining the reasoning behind it once we have such an explainer
        error += `Error: The transaction is too expensive, try reducing the number of AccountUpdates that are attached to the transaction.
Each transaction needs to be processed by the snark workers on the network.
Certain layouts of AccountUpdates require more proving time than others, and therefore are too expensive.

${JSON.stringify(authTypes)}
\n\n`;
    }
    if (!isWithinEventsLimit) {
        error += `Error: The account updates in your transaction are trying to emit too much event data. The maximum allowed number of field elements in events is ${maxEventElements}, but you tried to emit ${eventElements.events}.\n\n`;
    }
    if (!isWithinActionsLimit) {
        error += `Error: The account updates in your transaction are trying to emit too much action data. The maximum allowed number of field elements in actions is ${maxActionElements}, but you tried to emit ${eventElements.actions}.\n\n`;
    }
    if (error)
        throw Error('Error during transaction sending:\n\n' + error);
}
function countEventElements({ data }) {
    return data.reduce((acc, ev) => acc + ev.length, 0);
}
const isPair = (a, b) => !a.isProved && !b.isProved;
function filterPairs(xs) {
    if (xs.length <= 1)
        return { xs, pairs: 0 };
    if (isPair(xs[0], xs[1])) {
        let rec = filterPairs(xs.slice(2));
        return { xs: rec.xs, pairs: rec.pairs + 1 };
    }
    else {
        let rec = filterPairs(xs.slice(1));
        return { xs: [xs[0]].concat(rec.xs), pairs: rec.pairs };
    }
}
function filterGroups(xs) {
    let pairs = filterPairs(xs);
    xs = pairs.xs;
    let singleCount = 0;
    let proofCount = 0;
    xs.forEach((t) => {
        if (t.isProved)
            proofCount++;
        else
            singleCount++;
    });
    return {
        signedPair: pairs.pairs,
        signedSingle: singleCount,
        proof: proofCount,
    };
}
async function waitForFunding(address) {
    let attempts = 0;
    let maxAttempts = 30;
    let interval = 30000;
    const executePoll = async (resolve, reject) => {
        let { account } = await Fetch.fetchAccount({ publicKey: address });
        attempts++;
        if (account) {
            return resolve();
        }
        else if (maxAttempts && attempts === maxAttempts) {
            return reject(new Error(`Exceeded max attempts`));
        }
        else {
            setTimeout(executePoll, interval, resolve, reject);
        }
    };
    return new Promise(executePoll);
}
/**
 * Requests the [testnet faucet](https://faucet.minaprotocol.com/api/v1/faucet) to fund a public key.
 */
async function faucet(pub, network = 'berkeley-qanet') {
    let address = pub.toBase58();
    let response = await fetch('https://faucet.minaprotocol.com/api/v1/faucet', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            network,
            address: address,
        }),
    });
    response = await response.json();
    if (response.status.toString() !== 'success') {
        throw new Error(`Error funding account ${address}, got response status: ${response.status}, text: ${response.statusText}`);
    }
    await waitForFunding(address);
}
//# sourceMappingURL=mina.js.map