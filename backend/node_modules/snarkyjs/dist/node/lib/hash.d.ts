import { HashInput } from './circuit_value.js';
import { Poseidon as Poseidon_, Field } from '../snarky.js';
export { Poseidon, TokenSymbol };
export { HashInput, Hash, prefixes, emptyHashWithPrefix, hashWithPrefix, salt, packToFields, emptyReceiptChainHash, };
declare class Sponge {
    private sponge;
    constructor();
    absorb(x: Field): void;
    squeeze(): Field;
}
declare const Poseidon: {
    hash(input: Field[]): Field;
    update(state: [Field, Field, Field], input: Field[]): [Field, Field, Field];
    initialState(): [Field, Field, Field];
    Sponge: typeof Sponge;
};
declare const Hash: {
    salt: (prefix: string) => Field[];
    emptyHashWithPrefix: (prefix: string) => Field;
    hashWithPrefix: (prefix: string, input: Field[]) => Field;
};
declare let salt: (prefix: string) => Field[], emptyHashWithPrefix: (prefix: string) => Field, hashWithPrefix: (prefix: string, input: Field[]) => Field;
declare const prefixes: typeof Poseidon_.prefixes;
/**
 * Convert the {fields, packed} hash input representation to a list of field elements
 * Random_oracle_input.Chunked.pack_to_fields
 */
declare function packToFields({ fields, packed }: HashInput): Field[];
declare const TokenSymbol_base: (new (value: {
    symbol: string;
    field: Field;
}) => {
    symbol: string;
    field: Field;
}) & {
    _isStruct: true;
} & import("../snarky.js").Provable<{
    symbol: string;
    field: Field;
}> & {
    toInput: (x: {
        symbol: string;
        field: Field;
    }) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    toJSON: (x: {
        symbol: string;
        field: Field;
    }) => string;
    fromJSON: (x: string) => {
        symbol: string;
        field: Field;
    };
};
declare class TokenSymbol extends TokenSymbol_base {
    static get empty(): {
        symbol: string;
        field: Field;
    };
    static from(symbol: string): TokenSymbol;
}
declare function emptyReceiptChainHash(): Field;
