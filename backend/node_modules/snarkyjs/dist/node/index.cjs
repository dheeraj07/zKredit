"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// dist/node/index.js
var node_exports = {};
__export(node_exports, {
  Account: () => Account4,
  AccountUpdate: () => AccountUpdate2,
  Bool: () => Bool,
  Character: () => Character,
  Circuit: () => Circuit,
  CircuitString: () => CircuitString,
  CircuitValue: () => CircuitValue,
  Encoding: () => encoding_exports,
  Encryption: () => encryption_exports,
  Experimental: () => Experimental,
  Field: () => Field,
  Group: () => Group,
  Int64: () => Int64,
  Ledger: () => Ledger,
  MerkleMap: () => MerkleMap,
  MerkleMapWitness: () => MerkleMapWitness,
  MerkleTree: () => MerkleTree,
  MerkleWitness: () => MerkleWitness,
  Mina: () => mina_exports,
  Permissions: () => Permissions,
  Poseidon: () => Poseidon2,
  PrivateKey: () => PrivateKey2,
  Proof: () => Proof,
  PublicKey: () => PublicKey2,
  Reducer: () => Reducer,
  Scalar: () => Scalar,
  SelfProof: () => SelfProof,
  Sign: () => Sign3,
  Signature: () => Signature2,
  SmartContract: () => SmartContract,
  State: () => State,
  Struct: () => Struct,
  Token: () => Token,
  TokenSymbol: () => TokenSymbol,
  Types: () => transaction_exports,
  UInt32: () => UInt322,
  UInt64: () => UInt642,
  VerificationKey: () => VerificationKey,
  ZkappPublicInput: () => ZkappPublicInput,
  addCachedAccount: () => addCachedAccount,
  arrayProp: () => arrayProp,
  circuitMain: () => circuitMain,
  declareMethods: () => declareMethods,
  declareState: () => declareState,
  fetchAccount: () => fetchAccount,
  fetchEvents: () => fetchEvents,
  fetchLastBlock: () => fetchLastBlock,
  fetchTransactionStatus: () => fetchTransactionStatus,
  getSrs: () => getSrs,
  isReady: () => isReady,
  matrixProp: () => matrixProp,
  method: () => method,
  prop: () => prop,
  provable: () => provable2,
  provablePure: () => provablePure,
  public_: () => public_,
  recoverVerificationKey: () => recoverVerificationKey,
  sendZkapp: () => sendZkapp,
  serializeVerificationKey: () => serializeVerificationKey,
  setArchiveGraphqlEndpoint: () => setArchiveGraphqlEndpoint,
  setGraphqlEndpoint: () => setGraphqlEndpoint,
  shutdown: () => shutdown,
  signFeePayer: () => signFeePayer,
  state: () => state,
  verify: () => verify
});
module.exports = __toCommonJS(node_exports);

// dist/node/snarky/wrapper.js
var import_snarky_js_node_bc = __toESM(require("./_node_bindings/snarky_js_node.bc.cjs"), 1);
var getSnarky = () => import_snarky_js_node_bc.default;
var snarky_ready = import_snarky_js_node_bc.default.snarky_ready;
function getWasm() {
  return globalThis.jsoo_runtime.plonk_wasm;
}
async function shutdown() {
  process.exit(0);
}

// dist/node/snarky/snarky-class-spec.js
var snarky_class_spec_default = [
  {
    name: "Field",
    props: [
      {
        name: "one",
        type: "object"
      },
      {
        name: "zero",
        type: "object"
      },
      {
        name: "minusOne",
        type: "object"
      },
      {
        name: "ORDER",
        type: "bigint"
      },
      {
        name: "random",
        type: "function"
      },
      {
        name: "add",
        type: "function"
      },
      {
        name: "sub",
        type: "function"
      },
      {
        name: "mul",
        type: "function"
      },
      {
        name: "div",
        type: "function"
      },
      {
        name: "neg",
        type: "function"
      },
      {
        name: "inv",
        type: "function"
      },
      {
        name: "square",
        type: "function"
      },
      {
        name: "sqrt",
        type: "function"
      },
      {
        name: "toString",
        type: "function"
      },
      {
        name: "sizeInFields",
        type: "function"
      },
      {
        name: "toFields",
        type: "function"
      },
      {
        name: "fromFields",
        type: "function"
      },
      {
        name: "assertEqual",
        type: "function"
      },
      {
        name: "assertBool",
        type: "function"
      },
      {
        name: "assertBoolean",
        type: "function"
      },
      {
        name: "isZero",
        type: "function"
      },
      {
        name: "fromBits",
        type: "function"
      },
      {
        name: "toBits",
        type: "function"
      },
      {
        name: "equal",
        type: "function"
      },
      {
        name: "toJSON",
        type: "function"
      },
      {
        name: "fromJSON",
        type: "function"
      },
      {
        name: "fromNumber",
        type: "function"
      },
      {
        name: "fromString",
        type: "function"
      },
      {
        name: "fromBigInt",
        type: "function"
      },
      {
        name: "check",
        type: "function"
      }
    ]
  },
  {
    name: "Bool",
    props: [
      {
        name: "true",
        type: "object"
      },
      {
        name: "false",
        type: "object"
      },
      {
        name: "toField",
        type: "function"
      },
      {
        name: "Unsafe",
        type: "object"
      },
      {
        name: "not",
        type: "function"
      },
      {
        name: "and",
        type: "function"
      },
      {
        name: "or",
        type: "function"
      },
      {
        name: "assertEqual",
        type: "function"
      },
      {
        name: "equal",
        type: "function"
      },
      {
        name: "count",
        type: "function"
      },
      {
        name: "sizeInFields",
        type: "function"
      },
      {
        name: "toFields",
        type: "function"
      },
      {
        name: "fromFields",
        type: "function"
      },
      {
        name: "check",
        type: "function"
      },
      {
        name: "toJSON",
        type: "function"
      },
      {
        name: "fromJSON",
        type: "function"
      }
    ]
  },
  {
    name: "Circuit",
    props: [
      {
        name: "runAndCheck",
        type: "function"
      },
      {
        name: "runUnchecked",
        type: "function"
      },
      {
        name: "_constraintSystem",
        type: "function"
      },
      {
        name: "asProver",
        type: "function"
      },
      {
        name: "_witness",
        type: "function"
      },
      {
        name: "array",
        type: "function"
      },
      {
        name: "generateKeypair",
        type: "function"
      },
      {
        name: "prove",
        type: "function"
      },
      {
        name: "verify",
        type: "function"
      },
      {
        name: "assertEqual",
        type: "function"
      },
      {
        name: "equal",
        type: "function"
      },
      {
        name: "toFields",
        type: "function"
      },
      {
        name: "inProver",
        type: "function"
      },
      {
        name: "inCheckedComputation",
        type: "function"
      },
      {
        name: "if",
        type: "function"
      },
      {
        name: "getVerificationKey",
        type: "function"
      }
    ]
  },
  {
    name: "Poseidon",
    props: [
      {
        name: "hash",
        type: "function"
      },
      {
        name: "update",
        type: "function"
      },
      {
        name: "prefixes",
        type: "object"
      },
      {
        name: "spongeCreate",
        type: "function"
      },
      {
        name: "spongeAbsorb",
        type: "function"
      },
      {
        name: "spongeSqueeze",
        type: "function"
      }
    ]
  },
  {
    name: "Group",
    props: [
      {
        name: "generator",
        type: "object"
      },
      {
        name: "add",
        type: "function"
      },
      {
        name: "sub",
        type: "function"
      },
      {
        name: "neg",
        type: "function"
      },
      {
        name: "scale",
        type: "function"
      },
      {
        name: "assertEqual",
        type: "function"
      },
      {
        name: "equal",
        type: "function"
      },
      {
        name: "toFields",
        type: "function"
      },
      {
        name: "fromFields",
        type: "function"
      },
      {
        name: "sizeInFields",
        type: "function"
      },
      {
        name: "check",
        type: "function"
      },
      {
        name: "toJSON",
        type: "function"
      },
      {
        name: "fromJSON",
        type: "function"
      }
    ]
  },
  {
    name: "Scalar",
    props: [
      {
        name: "toFields",
        type: "function"
      },
      {
        name: "sizeInFields",
        type: "function"
      },
      {
        name: "fromFields",
        type: "function"
      },
      {
        name: "random",
        type: "function"
      },
      {
        name: "fromBits",
        type: "function"
      },
      {
        name: "toJSON",
        type: "function"
      },
      {
        name: "fromJSON",
        type: "function"
      },
      {
        name: "check",
        type: "function"
      }
    ]
  },
  {
    name: "Ledger",
    props: [
      {
        name: "create",
        type: "function"
      },
      {
        name: "customTokenId",
        type: "function"
      },
      {
        name: "customTokenIdChecked",
        type: "function"
      },
      {
        name: "createTokenAccount",
        type: "function"
      },
      {
        name: "hashTransaction",
        type: "function"
      },
      {
        name: "hashTransactionChecked",
        type: "function"
      },
      {
        name: "transactionCommitments",
        type: "function"
      },
      {
        name: "zkappPublicInput",
        type: "function"
      },
      {
        name: "signFieldElement",
        type: "function"
      },
      {
        name: "dummySignature",
        type: "function"
      },
      {
        name: "signFeePayer",
        type: "function"
      },
      {
        name: "signOtherAccountUpdate",
        type: "function"
      },
      {
        name: "publicKeyToString",
        type: "function"
      },
      {
        name: "publicKeyOfString",
        type: "function"
      },
      {
        name: "privateKeyToString",
        type: "function"
      },
      {
        name: "privateKeyOfString",
        type: "function"
      },
      {
        name: "fieldToBase58",
        type: "function"
      },
      {
        name: "fieldOfBase58",
        type: "function"
      },
      {
        name: "memoToBase58",
        type: "function"
      },
      { name: "memoHashBase58", type: "function" },
      {
        name: "checkAccountUpdateSignature",
        type: "function"
      },
      {
        name: "fieldsOfJson",
        type: "function"
      },
      {
        name: "hashAccountUpdateFromFields",
        type: "function"
      },
      {
        name: "hashAccountUpdateFromJson",
        type: "function"
      },
      {
        name: "hashInputFromJson",
        type: "object"
      },
      { name: "encoding", type: "object" }
    ]
  },
  {
    name: "Pickles",
    props: [
      {
        name: "compile",
        type: "function"
      },
      {
        name: "circuitDigest",
        type: "function"
      },
      {
        name: "verify",
        type: "function"
      },
      {
        name: "dummyBase64Proof",
        type: "function"
      },
      {
        name: "dummyVerificationKey",
        type: "function"
      },
      {
        name: "proofToBase64",
        type: "function"
      },
      {
        name: "proofOfBase64",
        type: "function"
      },
      {
        name: "proofToBase64Transaction",
        type: "function"
      }
    ]
  },
  {
    name: "Test",
    props: [
      {
        name: "transactionHash",
        type: "object"
      }
    ]
  }
];

// dist/node/snarky/proxy.js
function proxyClasses(getModuleObject, isItReady2, moduleSpec) {
  let moduleProxy = {};
  for (let classSpec of moduleSpec) {
    let className = classSpec.name;
    let Class = function(...args) {
      if (!isItReady2())
        throw Error(constructError(className));
      let moduleObject = getModuleObject();
      return new moduleObject[className](...args);
    };
    for (let prop2 of classSpec.props) {
      let propName = prop2.name;
      if (prop2.type === "function") {
        Class[propName] = function(...args) {
          if (!isItReady2())
            throw Error(methodError(className, propName));
          let moduleObject = getModuleObject();
          return moduleObject[className][propName].apply(this, args);
        };
      } else {
        Object.defineProperty(Class, propName, {
          get: function() {
            let moduleObject = getModuleObject();
            return moduleObject[className][propName];
          }
        });
      }
    }
    moduleProxy[className] = Class;
  }
  return moduleProxy;
}
var constructError = (className) => `Cannot call class constructor because snarkyjs has not finished loading.
Try calling \`await isReady\` before \`new ${className}()\``;
var methodError = (className, methodName) => `Cannot call static method because snarkyjs has not finished loading.
Try calling \`await isReady\` before \`${className}.${methodName}()\``;

// dist/node/snarky.js
var isReadyBoolean = false;
var isReady = snarky_ready.then(() => isReadyBoolean = true);
var isItReady = () => isReadyBoolean;
var { Field, Bool, Circuit, Poseidon, Group, Scalar, Ledger, Pickles, Test } = proxyClasses(getSnarky, isItReady, snarky_class_spec_default);

// dist/node/js_crypto/bigint-helpers.js
function bytesToBigInt(bytes) {
  let x = 0n;
  let bitPosition = 0n;
  for (let byte of bytes) {
    x += BigInt(byte) << bitPosition;
    bitPosition += 8n;
  }
  return x;
}
function bigIntToBytes(x, length) {
  if (x < 0n) {
    throw Error(`bigIntToBytes: negative numbers are not supported, got ${x}`);
  }
  let bytes = Array(length);
  for (let i2 = 0; i2 < length; i2++, x >>= 8n) {
    bytes[i2] = Number(x & 0xffn);
  }
  if (x > 0n) {
    throw Error(`bigIntToBytes: input does not fit in ${length} bytes`);
  }
  return bytes;
}
function changeBase(digits, base, newBase) {
  let x = fromBase(digits, base);
  let newDigits = toBase(x, newBase);
  return newDigits;
}
function fromBase(digits, base) {
  if (base <= 0n)
    throw Error("fromBase: base must be positive");
  let basePowers = [];
  for (let power2 = base, n = 1; n < digits.length; power2 **= 2n, n *= 2) {
    basePowers.push(power2);
  }
  let k = basePowers.length;
  digits = digits.concat(Array(2 ** k - digits.length).fill(0n));
  for (let i2 = 0; i2 < k; i2++) {
    let newDigits = Array(digits.length >> 1);
    let basePower = basePowers[i2];
    for (let j = 0; j < newDigits.length; j++) {
      newDigits[j] = digits[2 * j] + basePower * digits[2 * j + 1];
    }
    digits = newDigits;
  }
  console.assert(digits.length === 1);
  let [digit] = digits;
  return digit;
}
function toBase(x, base) {
  if (base <= 0n)
    throw Error("toBase: base must be positive");
  let basePowers = [];
  for (let power2 = base; power2 < x; power2 **= 2n) {
    basePowers.push(power2);
  }
  let digits = [x];
  let k = basePowers.length;
  for (let i2 = 0; i2 < k; i2++) {
    let newDigits = Array(2 * digits.length);
    let basePower = basePowers[k - 1 - i2];
    for (let j = 0; j < digits.length; j++) {
      let x2 = digits[j];
      let high = x2 / basePower;
      newDigits[2 * j + 1] = high;
      newDigits[2 * j] = x2 - high * basePower;
    }
    digits = newDigits;
  }
  while (digits[digits.length - 1] === 0n) {
    digits.pop();
  }
  return digits;
}

// dist/node/js_crypto/non-negative.js
function assertNonNegativeInteger(n, message) {
  if (!Number.isInteger(n) || n < 0)
    throw Error(message);
}
function assertPositiveInteger(n, message) {
  if (!Number.isInteger(n) || n <= 0)
    throw Error(message);
}

// dist/node/provable/binable.js
function defineBinable({ toBytes, readBytes }) {
  let readBytes_ = (bytes, offset) => {
    assertNonNegativeInteger(offset, "readBytes: offset must be integer >= 0");
    if (offset >= bytes.length)
      throw Error("readBytes: offset must be within bytes length");
    let [value, end] = readBytes(bytes, offset);
    if (end < offset)
      throw Error("offset returned by readBytes must be greater than initial offset");
    if (end > bytes.length)
      throw Error("offset returned by readBytes must not exceed bytes length");
    return [value, end];
  };
  return {
    toBytes,
    readBytes: readBytes_,
    // spec: fromBytes throws if the input bytes are not all used
    fromBytes(bytes) {
      let [value, offset] = readBytes_(bytes, 0);
      if (offset < bytes.length)
        throw Error("fromBytes: input bytes left over");
      return value;
    }
  };
}
function withVersionNumber(binable, versionNumber) {
  return defineBinable({
    toBytes(t) {
      let bytes = binable.toBytes(t);
      bytes.unshift(versionNumber);
      return bytes;
    },
    readBytes(bytes, offset) {
      let version = bytes[offset++];
      if (version !== versionNumber) {
        throw Error(`fromBytes: Invalid version byte. Expected ${versionNumber}, got ${version}.`);
      }
      return binable.readBytes(bytes, offset);
    }
  });
}
function withCheck({ toBytes, readBytes }, check) {
  return defineBinable({
    toBytes,
    readBytes(bytes, start) {
      let [value, end] = readBytes(bytes, start);
      check(value);
      return [value, end];
    }
  });
}
function record(binables, keys) {
  let binablesTuple = keys.map((key) => binables[key]);
  let tupleBinable = tuple(binablesTuple);
  return defineBinable({
    toBytes(t) {
      let array = keys.map((key) => t[key]);
      return tupleBinable.toBytes(array);
    },
    readBytes(bytes, start) {
      let [tupleValue, end] = tupleBinable.readBytes(bytes, start);
      let value = Object.fromEntries(keys.map((key, i2) => [key, tupleValue[i2]]));
      return [value, end];
    }
  });
}
function tuple(binables) {
  let n = binables.length;
  return defineBinable({
    toBytes(t) {
      let bytes = [];
      for (let i2 = 0; i2 < n; i2++) {
        let subBytes = binables[i2].toBytes(t[i2]);
        bytes.push(...subBytes);
      }
      return bytes;
    },
    readBytes(bytes, offset) {
      let values = [];
      for (let i2 = 0; i2 < n; i2++) {
        let [value, newOffset] = binables[i2].readBytes(bytes, offset);
        offset = newOffset;
        values.push(value);
      }
      return [values, offset];
    }
  });
}
var BinableString = defineBinable({
  toBytes(t) {
    return [stringLengthInBytes(t), ...stringToBytes(t)];
  },
  readBytes(bytes, offset) {
    let length = bytes[offset++];
    let end = offset + length;
    let string = stringFromBytes(bytes.slice(offset, end));
    return [string, end];
  }
});
var CODE_NEG_INT8 = 255;
var CODE_INT16 = 254;
var CODE_INT32 = 253;
var CODE_INT64 = 252;
function BinableInt(bits2) {
  let maxValue = 1n << BigInt(bits2 - 1);
  let nBytes = bits2 >> 3;
  if (nBytes * 8 !== bits2)
    throw Error("bits must be evenly divisible by 8");
  return defineBinable({
    toBytes(n) {
      if (n < -maxValue || n >= maxValue)
        throw Error(`int${bits2} out of range, got ${n}`);
      if (n >= 0) {
        if (n < 0x80n)
          return bigIntToBytes(n, 1);
        if (n < 0x8000n)
          return [CODE_INT16, ...bigIntToBytes(n, 2)];
        if (n < 2147483648)
          return [CODE_INT32, ...bigIntToBytes(n, 4)];
        else
          return [CODE_INT64, ...bigIntToBytes(n, 8)];
      } else {
        let M = 1n << 64n;
        if (n >= -0x80n)
          return [CODE_NEG_INT8, ...bigIntToBytes(M + n & 0xffn, 1)];
        if (n >= -0x8000n)
          return [CODE_INT16, ...bigIntToBytes(M + n & 0xffffn, 2)];
        if (n >= -2147483648)
          return [CODE_INT32, ...bigIntToBytes(M + n & 0xffffffffn, 4)];
        else
          return [CODE_INT64, ...bigIntToBytes(M + n, 8)];
      }
    },
    readBytes(bytes, offset) {
      let code = bytes[offset++];
      if (code < 128)
        return [BigInt(code), offset];
      let size = {
        [CODE_NEG_INT8]: 1,
        [CODE_INT16]: 2,
        [CODE_INT32]: 4,
        [CODE_INT64]: 8
      }[code];
      if (size === void 0) {
        throw Error("binable integer: invalid start byte");
      }
      let end = offset + size;
      let x = fillUInt(bytes.slice(offset, end), nBytes);
      if (x >= maxValue) {
        x -= 2n * maxValue;
      }
      if (x < -maxValue || x >= maxValue) {
        throw Error(`int${bits2} out of range, got ${x}`);
      }
      return [x, end];
    }
  });
}
function fillUInt(startBytes, nBytes) {
  let n = startBytes.length;
  let lastBit = startBytes[n - 1] >> 7;
  let fillByte = lastBit === 1 ? 255 : 0;
  let intBytes = startBytes.concat(Array(nBytes - n).fill(fillByte));
  let x = bytesToBigInt(intBytes);
  return x;
}
function BinableUint(bits2) {
  let binableInt = BinableInt(bits2);
  let maxValue = 1n << BigInt(bits2 - 1);
  return iso(binableInt, {
    to(uint) {
      if (uint < 0n || uint >= 2n * maxValue)
        throw Error(`uint${bits2} out of range, got ${uint}`);
      let ret = uint >= maxValue ? uint - 2n * maxValue : uint;
      return ret;
    },
    from(int) {
      let uint = int < 0n ? int + 2n * maxValue : int;
      if (uint < 0n || uint >= 2n * maxValue)
        throw Error(`uint${bits2} out of range, got ${uint}`);
      return uint;
    }
  });
}
var BinableInt64 = BinableInt(64);
var BinableInt32 = BinableInt(32);
var BinableUint64 = BinableUint(64);
var BinableUint32 = BinableUint(32);
function prefixToField(Field4, prefix) {
  let fieldSize = Field4.sizeInBytes();
  if (prefix.length >= fieldSize)
    throw Error("prefix too long");
  let stringBytes = stringToBytes(prefix);
  return Field4.fromBytes(stringBytes.concat(Array(fieldSize - stringBytes.length).fill(0)));
}
function bitsToBytes([...bits2]) {
  let bytes = [];
  while (bits2.length > 0) {
    let byteBits = bits2.splice(0, 8);
    let byte = 0;
    for (let i2 = 0; i2 < 8; i2++) {
      if (!byteBits[i2])
        continue;
      byte |= 1 << i2;
    }
    bytes.push(byte);
  }
  return bytes;
}
function bytesToBits(bytes) {
  return bytes.map((byte) => {
    let bits2 = Array(8);
    for (let i2 = 0; i2 < 8; i2++) {
      bits2[i2] = !!(byte & 1);
      byte >>= 1;
    }
    return bits2;
  }).flat();
}
function withBits(binable, sizeInBits2) {
  return {
    ...binable,
    toBits(t) {
      return bytesToBits(binable.toBytes(t)).slice(0, sizeInBits2);
    },
    fromBits(bits2) {
      return binable.fromBytes(bitsToBytes(bits2));
    },
    sizeInBytes() {
      return Math.ceil(sizeInBits2 / 8);
    },
    sizeInBits() {
      return sizeInBits2;
    }
  };
}
function iso(binable, { to, from }) {
  return defineBinable({
    toBytes(s) {
      return binable.toBytes(to(s));
    },
    readBytes(bytes, offset) {
      let [value, end] = binable.readBytes(bytes, offset);
      return [from(value), end];
    }
  });
}
var encoder = new TextEncoder();
var decoder = new TextDecoder();
function stringToBytes(s) {
  return [...encoder.encode(s)];
}
function stringFromBytes(bytes) {
  return decoder.decode(Uint8Array.from(bytes));
}
function stringLengthInBytes(s) {
  return encoder.encode(s).length;
}

// dist/node/js_crypto/random.js
var import_crypto = require("crypto");
function randomBytes(n) {
  return new Uint8Array((0, import_crypto.randomBytes)(n));
}

// dist/node/js_crypto/finite_field.js
var p = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001n;
var q = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001n;
var pMinusOneOddFactor = 0x40000000000000000000000000000000224698fc094cf91b992d30edn;
var qMinusOneOddFactor = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb21n;
var twoadicRootFp = 0x2bce74deac30ebda362120830561f81aea322bf2b7bb7584bdad6fabd87ea32fn;
var twoadicRootFq = 0x2de6a9b8746d3f589e5c4dfd492ae26e9bb97ea3c106f049a70e2c1102b6d05fn;
function mod(x, p3) {
  x = x % p3;
  if (x < 0)
    return x + p3;
  return x;
}
function power(a, n, p3) {
  a = mod(a, p3);
  let x = 1n;
  for (; n > 0n; n >>= 1n) {
    if (n & 1n)
      x = mod(x * a, p3);
    a = mod(a * a, p3);
  }
  return x;
}
function inverse(a, p3) {
  a = mod(a, p3);
  if (a === 0n)
    return void 0;
  let b2 = p3;
  let x = 0n;
  let y = 1n;
  let u = 1n;
  let v = 0n;
  while (a !== 0n) {
    let q3 = b2 / a;
    let r = mod(b2, a);
    let m = x - u * q3;
    let n = y - v * q3;
    b2 = a;
    a = r;
    x = u;
    y = v;
    u = m;
    v = n;
  }
  if (b2 !== 1n)
    return void 0;
  return mod(x, p3);
}
var precomputed_c = {};
function sqrt(n, p3, Q, z) {
  let M = 32n;
  let c = precomputed_c[p3.toString()] || (precomputed_c[p3.toString()] = power(z, Q, p3));
  let t = power(n, Q, p3);
  let R = power(n, (Q + 1n) / 2n, p3);
  while (true) {
    if (t === 0n)
      return 0n;
    if (t === 1n)
      return R;
    let i2 = 0n;
    let s = t;
    while (s !== 1n) {
      s = mod(s * s, p3);
      i2 = i2 + 1n;
    }
    if (i2 === M)
      return void 0;
    let b2 = power(c, 1n << M - i2 - 1n, p3);
    M = i2;
    c = mod(b2 * b2, p3);
    t = mod(t * c, p3);
    R = mod(R * b2, p3);
  }
}
function isSquare(x, p3) {
  if (x === 0n)
    return true;
  let sqrt1 = power(x, (p3 - 1n) / 2n, p3);
  return sqrt1 === 1n;
}
function randomField(p3) {
  while (true) {
    let bytes = randomBytes(32);
    bytes[31] &= 127;
    let x = bytesToBigInt(bytes);
    if (x < p3)
      return x;
  }
}
var Fp = createField(p, pMinusOneOddFactor, twoadicRootFp);
var Fq = createField(q, qMinusOneOddFactor, twoadicRootFq);
function createField(p3, t, twoadicRoot) {
  return {
    modulus: p3,
    sizeInBits: 255,
    t,
    twoadicRoot,
    add(x, y) {
      return mod(x + y, p3);
    },
    negate(x) {
      return x === 0n ? 0n : p3 - x;
    },
    sub(x, y) {
      return mod(x - y, p3);
    },
    mul(x, y) {
      return mod(x * y, p3);
    },
    inverse(x) {
      return inverse(x, p3);
    },
    div(x, y) {
      let yinv = inverse(y, p3);
      if (yinv === void 0)
        return;
      return mod(x * yinv, p3);
    },
    square(x) {
      return mod(x * x, p3);
    },
    isSquare(x) {
      return isSquare(x, p3);
    },
    sqrt(x) {
      return sqrt(x, p3, t, twoadicRoot);
    },
    power(x, n) {
      return power(x, n, p3);
    },
    dot(x, y) {
      let z = 0n;
      let n = x.length;
      for (let i2 = 0; i2 < n; i2++) {
        z += x[i2] * y[i2];
      }
      return mod(z, p3);
    },
    equal(x, y) {
      return mod(x - y, p3) === 0n;
    },
    isEven(x) {
      return !(x & 1n);
    },
    random() {
      return randomField(p3);
    },
    fromNumber(x) {
      return mod(BigInt(x), p3);
    },
    fromBigint(x) {
      return mod(x, p3);
    }
  };
}

// dist/node/provable/field-bigint.js
var sizeInBits = Fp.sizeInBits;
var minusOne = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000000n;
var checkField = checkRange(0n, Fp.modulus, "Field");
var checkBool = checkAllowList(/* @__PURE__ */ new Set([0n, 1n]), "Bool");
var checkSign = checkAllowList(/* @__PURE__ */ new Set([1n, minusOne]), "Sign");
var Field2 = pseudoClass(function Field3(value) {
  return mod(BigInt(value), Fp.modulus);
}, {
  ...ProvableBigint(checkField),
  ...BinableBigint(Fp.sizeInBits, checkField),
  ...Fp
});
var Bool2 = pseudoClass(function Bool3(value) {
  return BigInt(value);
}, {
  ...ProvableBigint(checkBool),
  ...BinableBigint(1, checkBool),
  toInput(x) {
    return { fields: [], packed: [[x, 1]] };
  },
  toBoolean(x) {
    return !!x;
  },
  toJSON(x) {
    return !!x;
  },
  fromJSON(b2) {
    let x = BigInt(b2);
    checkBool(x);
    return x;
  },
  sizeInBytes() {
    return 1;
  },
  fromField(x) {
    checkBool(x);
    return x;
  }
});
function Unsigned(bits2) {
  let maxValue = (1n << BigInt(bits2)) - 1n;
  let checkUnsigned = checkRange(0n, 1n << BigInt(bits2), `UInt${bits2}`);
  let binable = BinableBigint(bits2, checkUnsigned);
  let bytes = Math.ceil(bits2 / 8);
  return pseudoClass(function Unsigned2(value) {
    let x = BigInt(value);
    checkUnsigned(x);
    return x;
  }, {
    ...ProvableBigint(checkUnsigned),
    ...binable,
    toInput(x) {
      return { fields: [], packed: [[x, bits2]] };
    },
    maxValue,
    random() {
      return binable.fromBytes([...randomBytes(bytes)]);
    }
  });
}
var UInt32 = Unsigned(32);
var UInt64 = Unsigned(64);
var Sign = pseudoClass(function Sign2(value) {
  if (value !== 1 && value !== -1)
    throw Error("Sign: input must be 1 or -1.");
  return mod(BigInt(value), Fp.modulus);
}, {
  ...ProvableBigint(checkSign),
  ...BinableBigint(1, checkSign),
  emptyValue() {
    return 1n;
  },
  toInput(x) {
    return { fields: [], packed: [[x === 1n ? 1n : 0n, 1]] };
  },
  fromFields([x]) {
    if (x === 0n)
      return 1n;
    checkSign(x);
    return x;
  },
  toJSON(x) {
    return x === 1n ? "Positive" : "Negative";
  },
  fromJSON(x) {
    if (x !== "Positive" && x !== "Negative")
      throw Error("Sign: invalid input");
    return x === "Positive" ? 1n : minusOne;
  }
});
function pseudoClass(constructor, module2) {
  return Object.assign(constructor, module2);
}
function ProvableBigint(check) {
  return {
    sizeInFields() {
      return 1;
    },
    toFields(x) {
      return [x];
    },
    toAuxiliary() {
      return [];
    },
    check,
    fromFields([x]) {
      check(x);
      return x;
    },
    toInput(x) {
      return { fields: [x], packed: [] };
    },
    toJSON(x) {
      return x.toString();
    },
    fromJSON(json) {
      if (isNaN(json) || isNaN(parseFloat(json))) {
        throw Error(`fromJSON: expected a numeric string, got "${json}"`);
      }
      let x = BigInt(json);
      check(x);
      return x;
    }
  };
}
function BinableBigint(sizeInBits2, check) {
  let sizeInBytes = Math.ceil(sizeInBits2 / 8);
  return withBits(defineBinable({
    toBytes(x) {
      return bigIntToBytes(x, sizeInBytes);
    },
    readBytes(bytes, start) {
      let x = 0n;
      let bitPosition = 0n;
      let end = Math.min(start + sizeInBytes, bytes.length);
      for (let i2 = start; i2 < end; i2++) {
        x += BigInt(bytes[i2]) << bitPosition;
        bitPosition += 8n;
      }
      check(x);
      return [x, end];
    }
  }), sizeInBits2);
}
function checkRange(lower, upper, name) {
  return (x) => {
    if (x < lower)
      throw Error(`${name}: inputs smaller than ${lower} are not allowed, got ${x}`);
    if (x >= upper)
      throw Error(`${name}: inputs larger than ${upper - 1n} are not allowed, got ${x}`);
  };
}
function checkAllowList(valid, name) {
  return (x) => {
    if (!valid.has(x)) {
      throw Error(`${name}: input must be one of ${[...valid].join(", ")}, got ${x}`);
    }
  };
}

// dist/node/js_crypto/elliptic_curve.js
var pallasGeneratorProjective = {
  x: 1n,
  y: 12418654782883325593414442427049395787963493412651469444558597405572177144507n,
  z: 1n
};
var vestaGeneratorProjective = {
  x: 1n,
  y: 11426906929455361843568202299992114520848200991084027513389447476559454104162n,
  z: 1n
};
var vestaEndoBase = 2942865608506852014473558576493638302197734138389222805617480874486368177743n;
var pallasEndoBase = 20444556541222657078399132219657928148671392403212669005631716460534733845831n;
var vestaEndoScalar = 8503465768106391777493614032514048814691664078728891710322960303815233784505n;
var pallasEndoScalar = 26005156700822196841419187675678338661165322343552424574062261873906994770353n;
var b = 5n;
var projectiveZero = { x: 1n, y: 1n, z: 0n };
function projectiveNeg({ x, y, z }, p3) {
  return { x, y: y === 0n ? 0n : p3 - y, z };
}
function projectiveAdd(g, h, p3) {
  if (g.z === 0n)
    return h;
  if (h.z === 0n)
    return g;
  let X1 = g.x, Y1 = g.y, Z1 = g.z, X2 = h.x, Y2 = h.y, Z2 = h.z;
  let Z1Z1 = mod(Z1 * Z1, p3);
  let Z2Z2 = mod(Z2 * Z2, p3);
  let U1 = mod(X1 * Z2Z2, p3);
  let U2 = mod(X2 * Z1Z1, p3);
  let S1 = mod(Y1 * Z2 * Z2Z2, p3);
  let S2 = mod(Y2 * Z1 * Z1Z1, p3);
  let H = mod(U2 - U1, p3);
  if (H === 0n) {
    if (S1 === S2)
      return projectiveDouble(g, p3);
    if (mod(S1 + S2, p3) === 0n)
      return projectiveZero;
    throw Error("projectiveAdd: invalid point");
  }
  let I = mod(H * H << 2n, p3);
  let J = mod(H * I, p3);
  let r = 2n * (S2 - S1);
  let V = mod(U1 * I, p3);
  let X3 = mod(r * r - J - 2n * V, p3);
  let Y3 = mod(r * (V - X3) - 2n * S1 * J, p3);
  let Z3 = mod(((Z1 + Z2) * (Z1 + Z2) - Z1Z1 - Z2Z2) * H, p3);
  return { x: X3, y: Y3, z: Z3 };
}
function projectiveDouble(g, p3) {
  if (g.z === 0n)
    return g;
  let X1 = g.x, Y1 = g.y, Z1 = g.z;
  let A = mod(X1 * X1, p3);
  let B = mod(Y1 * Y1, p3);
  let C = mod(B * B, p3);
  let D = mod(2n * ((X1 + B) * (X1 + B) - A - C), p3);
  let E = 3n * A;
  let F = mod(E * E, p3);
  let X3 = mod(F - 2n * D, p3);
  let Y3 = mod(E * (D - X3) - 8n * C, p3);
  let Z3 = mod(2n * Y1 * Z1, p3);
  return { x: X3, y: Y3, z: Z3 };
}
function projectiveSub(g, h, p3) {
  return projectiveAdd(g, projectiveNeg(h, p3), p3);
}
function projectiveScale(g, x, p3) {
  let h = projectiveZero;
  while (x > 0n) {
    if (x & 1n)
      h = projectiveAdd(h, g, p3);
    g = projectiveDouble(g, p3);
    x >>= 1n;
  }
  return h;
}
function projectiveToAffine(g, p3) {
  let z = g.z;
  if (z === 0n) {
    return { x: 1n, y: 1n, infinity: true };
  } else if (z === 1n) {
    return { x: g.x, y: g.y, infinity: false };
  } else {
    let zinv = inverse(z, p3);
    let zinv_squared = mod(zinv * zinv, p3);
    let x = mod(g.x * zinv_squared, p3);
    let y = mod(g.y * zinv * zinv_squared, p3);
    return { x, y, infinity: false };
  }
}
function projectiveEqual(g, h, p3) {
  if ((g.z === 0n || h.z === 0n) && !(g.z === 0n && h.z === 0n))
    return false;
  let gz2 = mod(g.z * g.z, p3);
  let hz2 = mod(h.z * h.z, p3);
  if (mod(g.x * hz2, p3) !== mod(h.x * gz2, p3))
    return false;
  let gz3 = mod(gz2 * g.z, p3);
  let hz3 = mod(hz2 * h.z, p3);
  return mod(g.y * hz3, p3) === mod(h.y * gz3, p3);
}
function projectiveOnCurve({ x, y, z }, p3, b2) {
  let x3 = mod(mod(x * x, p3) * x, p3);
  let y2 = mod(y * y, p3);
  let z3 = mod(mod(z * z, p3) * z, p3);
  let z6 = mod(z3 * z3, p3);
  return mod(y2 - x3 - b2 * z6, p3) === 0n;
}
function createCurveProjective(p3, generator, endoBase, endoScalar, b2) {
  return {
    zero: projectiveZero,
    one: generator,
    endoBase,
    endoScalar,
    b: b2,
    equal(g, h) {
      return projectiveEqual(g, h, p3);
    },
    isOnCurve(g) {
      return projectiveOnCurve(g, p3, b2);
    },
    add(g, h) {
      return projectiveAdd(g, h, p3);
    },
    double(g) {
      return projectiveDouble(g, p3);
    },
    negate(g) {
      return projectiveNeg(g, p3);
    },
    sub(g, h) {
      return projectiveSub(g, h, p3);
    },
    scale(g, s) {
      return projectiveScale(g, s, p3);
    },
    endomorphism({ x, y, z }) {
      return { x: mod(endoBase * x, p3), y, z };
    },
    toAffine(g) {
      return projectiveToAffine(g, p3);
    },
    fromAffine({ x, y, infinity }) {
      if (infinity)
        return projectiveZero;
      return { x, y, z: 1n };
    }
  };
}
var Pallas = createCurveProjective(p, pallasGeneratorProjective, pallasEndoBase, pallasEndoScalar, b);
var Vesta = createCurveProjective(q, vestaGeneratorProjective, vestaEndoBase, vestaEndoScalar, b);

// dist/node/js_crypto/constants.js
var prefixes = {
  "event": "MinaZkappEvent******",
  "events": "MinaZkappEvents*****",
  "sequenceEvents": "MinaZkappSeqEvents**",
  "body": "MinaZkappBody*******",
  "accountUpdateCons": "MinaAcctUpdateCons**",
  "accountUpdateNode": "MinaAcctUpdateNode**",
  "zkappMemo": "MinaZkappMemo*******",
  "signatureMainnet": "MinaSignatureMainnet",
  "signatureTestnet": "CodaSignature*******",
  "zkappUri": "MinaZkappUri********"
};
var versionBytes = {
  "tokenIdKey": 28,
  "receiptChainHash": 12,
  "ledgerHash": 5,
  "epochSeed": 13,
  "stateHash": 16,
  "publicKey": 203,
  "userCommandMemo": 20,
  "privateKey": 90,
  "signature": 154,
  "transactionHash": 29,
  "signedCommandV1": 19
};
var poseidonParamsKimchiFp = {
  "mds": [
    [
      "12035446894107573964500871153637039653510326950134440362813193268448863222019",
      "25461374787957152039031444204194007219326765802730624564074257060397341542093",
      "27667907157110496066452777015908813333407980290333709698851344970789663080149"
    ],
    [
      "4491931056866994439025447213644536587424785196363427220456343191847333476930",
      "14743631939509747387607291926699970421064627808101543132147270746750887019919",
      "9448400033389617131295304336481030167723486090288313334230651810071857784477"
    ],
    [
      "10525578725509990281643336361904863911009900817790387635342941550657754064843",
      "27437632000253211280915908546961303399777448677029255413769125486614773776695",
      "27566319851776897085443681456689352477426926500749993803132851225169606086988"
    ]
  ],
  "roundConstants": [
    [
      "21155079691556475130150866428468322463125560312786319980770950159250751855431",
      "16883442198399350202652499677723930673110172289234921799701652810789093522349",
      "17030687036425314703519085065002231920937594822150793091243263847382891822670"
    ],
    [
      "25216718237129482752721276445368692059997901880654047883630276346421457427360",
      "9054264347380455706540423067244764093107767235485930776517975315876127782582",
      "26439087121446593160953570192891907825526260324480347638727375735543609856888"
    ],
    [
      "15251000790817261169639394496851831733819930596125214313084182526610855787494",
      "10861916012597714684433535077722887124099023163589869801449218212493070551767",
      "18597653523270601187312528478986388028263730767495975370566527202946430104139"
    ],
    [
      "15831416454198644276563319006805490049460322229057756462580029181847589006611",
      "15171856919255965617705854914448645702014039524159471542852132430360867202292",
      "15488495958879593647482715143904752785889816789652405888927117106448507625751"
    ],
    [
      "19039802679983063488134304670998725949842655199289961967801223969839823940152",
      "4720101937153217036737330058775388037616286510783561045464678919473230044408",
      "10226318327254973427513859412126640040910264416718766418164893837597674300190"
    ],
    [
      "20878756131129218406920515859235137275859844638301967889441262030146031838819",
      "7178475685651744631172532830973371642652029385893667810726019303466125436953",
      "1996970955918516145107673266490486752153434673064635795711751450164177339618"
    ],
    [
      "15205545916434157464929420145756897321482314798910153575340430817222504672630",
      "25660296961552699573824264215804279051322332899472350724416657386062327210698",
      "13842611741937412200312851417353455040950878279339067816479233688850376089318"
    ],
    [
      "1383799642177300432144836486981606294838630135265094078921115713566691160459",
      "1135532281155277588005319334542025976079676424839948500020664227027300010929",
      "4384117336930380014868572224801371377488688194169758696438185377724744869360"
    ],
    [
      "21725577575710270071808882335900370909424604447083353471892004026180492193649",
      "676128913284806802699862508051022306366147359505124346651466289788974059668",
      "25186611339598418732666781049829183886812651492845008333418424746493100589207"
    ],
    [
      "10402240124664763733060094237696964473609580414190944671778761753887884341073",
      "11918307118590866200687906627767559273324023585642003803337447146531313172441",
      "16895677254395661024186292503536662354181715337630376909778003268311296637301"
    ],
    [
      "23818602699032741669874498456696325705498383130221297580399035778119213224810",
      "4285193711150023248690088154344086684336247475445482883105661485741762600154",
      "19133204443389422404056150665863951250222934590192266371578950735825153238612"
    ],
    [
      "5515589673266504033533906836494002702866463791762187140099560583198974233395",
      "11830435563729472715615302060564876527985621376031612798386367965451821182352",
      "7510711479224915247011074129666445216001563200717943545636462819681638560128"
    ],
    [
      "24694843201907722940091503626731830056550128225297370217610328578733387733444",
      "27361655066973784653563425664091383058914302579694897188019422193564924110528",
      "21606788186194534241166833954371013788633495786419718955480491478044413102713"
    ],
    [
      "19934060063390905409309407607814787335159021816537006003398035237707924006757",
      "8495813630060004961768092461554180468161254914257386012937942498774724649553",
      "27524960680529762202005330464726908693944660961000958842417927307941561848461"
    ],
    [
      "15178481650950399259757805400615635703086255035073919114667254549690862896985",
      "16164780354695672259791105197274509251141405713012804937107314962551600380870",
      "10529167793600778056702353412758954281652843049850979705476598375597148191979"
    ],
    [
      "721141070179074082553302896292167103755384741083338957818644728290501449040",
      "22044408985956234023934090378372374883099115753118261312473550998188148912041",
      "27068254103241989852888872162525066148367014691482601147536314217249046186315"
    ],
    [
      "3880429241956357176819112098792744584376727450211873998699580893624868748961",
      "17387097125522937623262508065966749501583017524609697127088211568136333655623",
      "6256814421247770895467770393029354017922744712896100913895513234184920631289"
    ],
    [
      "2942627347777337187690939671601251987500285937340386328746818861972711408579",
      "24031654937764287280548628128490074801809101323243546313826173430897408945397",
      "14401457902976567713827506689641442844921449636054278900045849050301331732143"
    ],
    [
      "20170632877385406450742199836933900257692624353889848352407590794211839130727",
      "24056496193857444725324410428861722338174099794084586764867109123681727290181",
      "11257913009612703357266904349759250619633397075667824800196659858304604714965"
    ],
    [
      "22228158921984425749199071461510152694025757871561406897041788037116931009246",
      "9152163378317846541430311327336774331416267016980485920222768197583559318682",
      "13906695403538884432896105059360907560653506400343268230130536740148070289175"
    ],
    [
      "7220714562509721437034241786731185291972496952091254931195414855962344025067",
      "27608867305903811397208862801981345878179337369367554478205559689592889691927",
      "13288465747219756218882697408422850918209170830515545272152965967042670763153"
    ],
    [
      "8251343892709140154567051772980662609566359215743613773155065627504813327653",
      "22035238365102171608166944627493632660244312563934708756134297161332908879090",
      "13560937766273321037807329177749403409731524715067067740487246745322577571823"
    ],
    [
      "21652518608959234550262559135285358020552897349934571164032339186996805408040",
      "22479086963324173427634460342145551255011746993910136574926173581069603086891",
      "13676501958531751140966255121288182631772843001727158043704693838707387130095"
    ],
    [
      "5680310394102577950568930199056707827608275306479994663197187031893244826674",
      "25125360450906166639190392763071557410047335755341060350879819485506243289998",
      "22659254028501616785029594492374243581602744364859762239504348429834224676676"
    ],
    [
      "23101411405087512171421838856759448177512679869882987631073569441496722536782",
      "24149774013240355952057123660656464942409328637280437515964899830988178868108",
      "5782097512368226173095183217893826020351125522160843964147125728530147423065"
    ],
    [
      "13540762114500083869920564649399977644344247485313990448129838910231204868111",
      "20421637734328811337527547703833013277831804985438407401987624070721139913982",
      "7742664118615900772129122541139124149525273579639574972380600206383923500701"
    ],
    [
      "1109643801053963021778418773196543643970146666329661268825691230294798976318",
      "16580663920817053843121063692728699890952505074386761779275436996241901223840",
      "14638514680222429058240285918830106208025229459346033470787111294847121792366"
    ],
    [
      "17080385857812672649489217965285727739557573467014392822992021264701563205891",
      "26176268111736737558502775993925696791974738793095023824029827577569530708665",
      "4382756253392449071896813428140986330161215829425086284611219278674857536001"
    ],
    [
      "13934033814940585315406666445960471293638427404971553891617533231178815348902",
      "27054912732979753314774418228399230433963143177662848084045249524271046173121",
      "28916070403698593376490976676534962592542013020010643734621202484860041243391"
    ],
    [
      "24820015636966360150164458094894587765384135259446295278101998130934963922381",
      "7969535238488580655870884015145760954416088335296905520306227531221721881868",
      "7690547696740080985104189563436871930607055124031711216224219523236060212249"
    ],
    [
      "9712576468091272384496248353414290908377825697488757134833205246106605867289",
      "12148698031438398980683630141370402088785182722473169207262735228500190477924",
      "14359657643133476969781351728574842164124292705609900285041476162075031948227"
    ],
    [
      "23563839965372067275137992801035780013422228997724286060975035719045352435470",
      "4184634822776323233231956802962638484057536837393405750680645555481330909086",
      "16249511905185772125762038789038193114431085603985079639889795722501216492487"
    ],
    [
      "11001863048692031559800673473526311616702863826063550559568315794438941516621",
      "4702354107983530219070178410740869035350641284373933887080161024348425080464",
      "23751680507533064238793742311430343910720206725883441625894258483004979501613"
    ],
    [
      "28670526516158451470169873496541739545860177757793329093045522432279094518766",
      "3568312993091537758218792253361873752799472566055209125947589819564395417072",
      "1819755756343439646550062754332039103654718693246396323207323333948654200950"
    ],
    [
      "5372129954699791301953948907349887257752247843844511069896766784624930478273",
      "17512156688034945920605615850550150476471921176481039715733979181538491476080",
      "25777105342317622165159064911913148785971147228777677435200128966844208883059"
    ],
    [
      "25350392006158741749134238306326265756085455157012701586003300872637887157982",
      "20096724945283767296886159120145376967480397366990493578897615204296873954844",
      "8063283381910110762785892100479219642751540456251198202214433355775540036851"
    ],
    [
      "4393613870462297385565277757207010824900723217720226130342463666351557475823",
      "9874972555132910032057499689351411450892722671352476280351715757363137891038",
      "23590926474329902351439438151596866311245682682435235170001347511997242904868"
    ],
    [
      "17723373371137275859467518615551278584842947963894791032296774955869958211070",
      "2350345015303336966039836492267992193191479606566494799781846958620636621159",
      "27755207882790211140683010581856487965587066971982625511152297537534623405016"
    ],
    [
      "6584607987789185408123601849106260907671314994378225066806060862710814193906",
      "609759108847171587253578490536519506369136135254150754300671591987320319770",
      "28435187585965602110074342250910608316032945187476441868666714022529803033083"
    ],
    [
      "16016664911651770663938916450245705908287192964254704641717751103464322455303",
      "17551273293154696089066968171579395800922204266630874071186322718903959339163",
      "20414195497994754529479032467015716938594722029047207834858832838081413050198"
    ],
    [
      "19773307918850685463180290966774465805537520595602496529624568184993487593855",
      "24598603838812162820757838364185126333280131847747737533989799467867231166980",
      "11040972566103463398651864390163813377135738019556270484707889323659789290225"
    ],
    [
      "5189242080957784038860188184443287562488963023922086723850863987437818393811",
      "1435203288979376557721239239445613396009633263160237764653161500252258220144",
      "13066591163578079667911016543985168493088721636164837520689376346534152547210"
    ],
    [
      "17345901407013599418148210465150865782628422047458024807490502489711252831342",
      "22139633362249671900128029132387275539363684188353969065288495002671733200348",
      "1061056418502836172283188490483332922126033656372467737207927075184389487061"
    ],
    [
      "10241738906190857416046229928455551829189196941239601756375665129874835232299",
      "27808033332417845112292408673209999320983657696373938259351951416571545364415",
      "18820154989873674261497645724903918046694142479240549687085662625471577737140"
    ],
    [
      "7983688435214640842673294735439196010654951226956101271763849527529940619307",
      "17067928657801807648925755556866676899145460770352731818062909643149568271566",
      "24472070825156236829515738091791182856425635433388202153358580534810244942762"
    ],
    [
      "25752201169361795911258625731016717414310986450004737514595241038036936283227",
      "26041505376284666160132119888949817249574689146924196064963008712979256107535",
      "23977050489096115210391718599021827780049209314283111721864956071820102846008"
    ],
    [
      "26678257097278788410676026718736087312816016749016738933942134600725962413805",
      "10480026985951498884090911619636977502506079971893083605102044931823547311729",
      "21126631300593007055117122830961273871167754554670317425822083333557535463396"
    ],
    [
      "1564862894215434177641156287699106659379648851457681469848362532131406827573",
      "13247162472821152334486419054854847522301612781818744556576865965657773174584",
      "8673615954922496961704442777870253767001276027366984739283715623634850885984"
    ],
    [
      "2794525076937490807476666942602262298677291735723129868457629508555429470085",
      "4656175953888995612264371467596648522808911819700660048695373348629527757049",
      "23221574237857660318443567292601561932489621919104226163978909845174616477329"
    ],
    [
      "1878392460078272317716114458784636517603142716091316893054365153068227117145",
      "2370412714505757731457251173604396662292063533194555369091306667486647634097",
      "17409784861870189930766639925394191888667317762328427589153989811980152373276"
    ],
    [
      "25869136641898166514111941708608048269584233242773814014385564101168774293194",
      "11361209360311194794795494027949518465383235799633128250259863567683341091323",
      "14913258820718821235077379851098720071902170702113538811112331615559409988569"
    ],
    [
      "12957012022018304419868287033513141736995211906682903915897515954290678373899",
      "17128889547450684566010972445328859295804027707361763477802050112063630550300",
      "23329219085372232771288306767242735245018143857623151155581182779769305489903"
    ],
    [
      "1607741027962933685476527275858938699728586794398382348454736018784568853937",
      "2611953825405141009309433982109911976923326848135736099261873796908057448476",
      "7372230383134982628913227482618052530364724821976589156840317933676130378411"
    ],
    [
      "20203606758501212620842735123770014952499754751430660463060696990317556818571",
      "4678361398979174017885631008335559529633853759463947250620930343087749944307",
      "27176462634198471376002287271754121925750749676999036165457559387195124025594"
    ],
    [
      "6361981813552614697928697527332318530502852015189048838072565811230204474643",
      "13815234633287489023151647353581705241145927054858922281829444557905946323248",
      "10888828634279127981352133512429657747610298502219125571406085952954136470354"
    ]
  ],
  "fullRounds": 55,
  "partialRounds": 0,
  "hasInitialRoundConstant": false,
  "stateSize": 3,
  "rate": 2,
  "power": 7
};
var poseidonParamsLegacyFp = {
  "mds": [
    [
      "5328350144166205084223774245058198666309664348635459768305312917086056785354",
      "15214731724107930304595906373487084110291887262136882623959435918484004667388",
      "22399519358931858664262538157042328690232277435337286643350379269028878354609"
    ],
    [
      "10086628405675314879458652402278736459294354590428582803795166650930540770072",
      "17127968360683744052278857147989507037142007029142438136689352416106177192235",
      "14207324749280135281015658576564097509614634975132487654324863824516044294735"
    ],
    [
      "3059104278162906687184746935153057867173086006783171716838577369156969739687",
      "16755849208683706534025643823697988418063305979108082130624352443958404325985",
      "16889774624482628108075965871448623911656600744832339664842346756371603433407"
    ]
  ],
  "roundConstants": [
    [
      "1346081094044643970582493287085428191977688221215786919106342366360741041016",
      "10635969173348128974923358283368657934408577270968219574411363948927109531877",
      "18431955373344919956072236142080066866861234899777299873162413437379924987003"
    ],
    [
      "5797044060651575840084283729791357462720161727701814038830889113712361837236",
      "931288489507796144596974766082847744938192694315568692730730202141894005205",
      "13659894470945121760517769979107966886673294523737498361566285362771110125394"
    ],
    [
      "6076231707445968054305995680347976771585015308155855387339303513025362636128",
      "28822740034050339685362260108484262889265034407340240070058997651710236456303",
      "23420266473857869790486107029614186913447272961845992963194006142267563993493"
    ],
    [
      "13753917374184785903125509246122783296344288469304898921025291716613575849357",
      "22396739346703340038555577564698139382745239004673153148674304627904081092826",
      "13064238335532551154986111986409392866270911640785653458047811526842088084911"
    ],
    [
      "23165923875642452719095776619341762858050322341374771345641255745672274104746",
      "1876216571769482372914291210815859835162659440705283782713345335434924136736",
      "25448252060136178247213604035267580231762596830634036926922217427938159849142"
    ],
    [
      "2161875315509206970842862195937323600322108268401381254431163181777726747153",
      "19159855698625842998331760283165907305622417625829203038229273729196960321630",
      "24828563875172432296791053766778475681869974948122169083176331088266823626561"
    ],
    [
      "15959479662608710141128458274961057999257961784282074767105536637788386907463",
      "8006369581283017287449277389162056290714176164680299906116833200510117952858",
      "18794336794618132129607701188430371953320538976527988886453665523008714542779"
    ],
    [
      "19408271715954593722501381885401160867835377473312521553027032015227895029571",
      "13654747284005184272412579731446984220568337794941823533879059135026064413631",
      "14094055032353750931629930778481002727722804310855727808905931659115939920989"
    ],
    [
      "13241818625838429282823260827177433104574315653706102174619924764342778921524",
      "25709259239494174564705048436260891089407557689981668111890003079561388887725",
      "26866626910239634723971078462134580196819809568632305020800296809092442642381"
    ],
    [
      "23886826350713085163238005260075062110062681905356997481925492650252417143049",
      "16853602711255261520713463306790360324679500458440235992292027384928526778856",
      "18444710386168488194610417945072711530390091945738595259171890487504771614189"
    ],
    [
      "16896789009769903615328691751424474161656500693270070895928499575572871141439",
      "23842266984616972287898037872537536999393060934879414668030219493005225085992",
      "24369698563802298585444760814856330583118549706483939267059237951238240608187"
    ],
    [
      "25360195173713628054110426524260405937218170863260484655473435413697869858790",
      "1486437708678506228822038923353468635394979165769861487132708983207562337116",
      "18653498960429911228442559598959970807723487073275324556015861725806677047150"
    ],
    [
      "18878179044241268037057256060083772636369783391816038647949347814518015576522",
      "178715779905629247116805974152863592571182389085419970371289655361443016848",
      "8381006794425876451998903949255801618132578446062133243427381291481465852184"
    ],
    [
      "4176946262813877719206528849579392120806054050640974718891398605746592169324",
      "16376345520728802444699629729684297833862527190772376028981704525651968727081",
      "8399065769082251057361366626601550736334213197703006866551331927128775757919"
    ],
    [
      "15435308585611812393531506745122614542196708285088622615406141986333182280857",
      "4082259282787276939431186930090898350392871145699460879678141552997816391817",
      "26348742719959309014730178326877937464605873211235784184917342950648457078699"
    ],
    [
      "9707631711734344681918469569872517425107158187591261754498805460753455298868",
      "27910768846011709391567916011595957279088224137468948238696800459136335473132",
      "20407239095656434708569263842372155762970847207558227886302782130015730063802"
    ],
    [
      "22726225412881182965250630589245572283256255052470345984553083359461473893802",
      "12443967854426795490638709950679156338200426963050610832781263082981525248175",
      "27102543658848146076219989119639465430524061997280788166887046421706499775415"
    ],
    [
      "14427224233985680214097547669945064793149553513421479297921556194475574770861",
      "22917454832925781549840198815703114840452733537799472739275668965081704937832",
      "3455076056123630366063931123762198941796412458154689469887583689725886013901"
    ],
    [
      "4513100023937785913596662867311227004762025658663076805918211014066645403017",
      "18187619530784075723418065322038024507729605774832001333883311123910954334059",
      "9447065431426150382325592560406989926365684509675374414068135115024495130938"
    ],
    [
      "3227816098015819796753427754968234889554095489076864339942014527747604603014",
      "14798316759185072116520458171957899889489461918408669809912344751222514418582",
      "23013904852315603905843158448056763116188801262838729536210355401378476650033"
    ],
    [
      "20979191509934291452182967564058656088941447895799901211038858159903580333267",
      "20772973010251235271448378823573767262405703078344288856168565499702414379868",
      "10105446427739226002497411811738001382334316505480517822035303561899927603685"
    ],
    [
      "11079074761356717003579108002319997196881121172538617046865136940931215263187",
      "4693927775411489288330326150094711670434597808961717172753867514688725690438",
      "18581720304902876944842830383273503265470859268712618325357902881821721540119"
    ],
    [
      "3065369948183164725765083504606321683481629263177690053939474679689088169185",
      "18515622379147081456114962668688706121098539582467584736624699157043365677487",
      "17563088600719312877716085528177751048248154461245613291986010180187238198006"
    ],
    [
      "26199746176994924146211004840756471702409132230831594954444947705902602287290",
      "7576136600627345523051497639367002272003104458453478964661395239732811642605",
      "20058687874612168338994287374025378897088936171250328231848098497610185784281"
    ],
    [
      "16894722532414195606958290526999761110785277556463400588047573469106594850228",
      "13961730805696859614283621225672002906734926278118993580398533742874863598733",
      "25256842011135514243352951950573936602906198374305137963222382546140030647211"
    ],
    [
      "18530360047537856737482157200091774590035773602620205695980247565433703032532",
      "23014819965938599260086897799541446473887833964178378497976832161473586995397",
      "27911426213258307990762460361663504655967992659180759140364181941291843542489"
    ],
    [
      "1067338118323302017358103178057182291035336430305886255160210378977812067042",
      "17219092885519007424608854460610388434712113621163885775309496940189894433620",
      "16432921127615937542183846559291144733339643093361323334499888895135356545408"
    ],
    [
      "28608851042959977114787048070153637607786033079364369200270218128830983558707",
      "10121629780013165888398831090128011045011860641816380162950736555305748332191",
      "2348036340843128746981122630521268144839343500596932561106759754644596320722"
    ],
    [
      "16619881370356823200358060093334065394764987467483650323706184068451904156452",
      "2302436627861989749837563733434625231689351276818486757748445924305258835336",
      "27514536540953539473280001431110316405453388911725550380123851609652679788049"
    ],
    [
      "9459277727420672604737117687200019308525004979918488827092207438664125039815",
      "23425670740358068509956137586663046763224562225383386726193078231034380596217",
      "7641885067011661443791509688937280323563328029517832788240965464798835873658"
    ],
    [
      "9579420382351699601929202663836555665702024548386778299996961509578687980280",
      "18513671386572584282611234979588379470994484682444053600751415262497237017703",
      "24923151431234706142737221165378041700050312199585085101919834422744926421604"
    ],
    [
      "21131320841803068139502705966375283830095161079635803028011171241658723560073",
      "19208476595309656066589572658712717685014329237892885950958199953675225096566",
      "24023185216737416080949689106968568821656545490748664446389634158498624398204"
    ],
    [
      "7510552996848634969347937904645640209946785877619890235458182993413526028718",
      "3694415017252995094553868781762548289196990492336482360084813900937464847638",
      "9219021070107873028263141554048987416559034633883158827414043929220388719352"
    ],
    [
      "5058327241234443421111591959922712922949620710493120384930391763032694640881",
      "13148252221647574076185511663661016015859769210867362839817254885265598775418",
      "15186790492457240277904880519227706403545816456632095870015828239411033220638"
    ],
    [
      "2775942914650502409705888572245750999561427024488403026572311267798009048466",
      "6277965230841030155341171319927732572492215818164736949144854827643964384893",
      "24144742149845235561087977558785057713814731737434473021812189457617252043745"
    ],
    [
      "25789129719327437503403457598813971826156253950521984610569937361506914183550",
      "21500534320778995945845999974779950304491968082325255355181901574840373597824",
      "17185359848218837018503091932245529880546896465437232425673134558221638601375"
    ],
    [
      "12253896579078110143384981818031883112606762215016553811786428215758384195713",
      "12956658260778456372481429232709881794962204180363200699121804724437678625542",
      "3023603786717368708677300377055384474816569333060487675635618249403832078921"
    ],
    [
      "4186492855716808019562789862833898284927736051002588766326482010810259565130",
      "4263939782228419774639068267872291539552889472311225829898746091327730032923",
      "24068843626280451423530509388397151179174104901782990365720205643492047328816"
    ],
    [
      "14564937827374621319716285527475223392664010281568256859627186463065876537730",
      "28367596550218705971881480694115935470211319172596432472834880507822452927283",
      "28712267437482356021504544448225827500268648754270274754623969882031853409874"
    ],
    [
      "4542596163006916397403529184431773692747461300288194722982487051249951403191",
      "2530461821259252672899452671728393208543894014761816288817584587718369998371",
      "12886393063011539390567049190923398676964700147222878509238966758839020897414"
    ],
    [
      "21593897590707514492037699253654745501762191795293908682495110982956631870528",
      "13233005790593128135480716846773978578237145313006994631606474472023504621256",
      "21621863098292803642478350494794106282518362577273973885587684567452726939909"
    ],
    [
      "26068620073001644720969640099644251616742620988609091568084348314770436291745",
      "18248589586787935500122854210401321966459127818593446990365211078521058875685",
      "21247134484403265289037859533347798468858819117600251067578809852124865474448"
    ],
    [
      "7947383127165915366383984718363902897504221803836013123394785749404572432524",
      "22173041014621867335598230447618036223462011647696367239478182269973488867154",
      "16773227734018849308448505860847939069870370055633571816925675705713088305139"
    ],
    [
      "10708707957340055662073314227607620808612686977606082605219160019699644826999",
      "21249897193797038261479589555720746994050836195265348846222835266344091683000",
      "12581195059139097540117398803363514148192715293133623516709277290477633379593"
    ],
    [
      "19779599816866992123290302397082614570282926215253589712189610064229996603178",
      "21749216503901548676985371189807470207364320167486559936962401093285243029177",
      "17600045923623503357380202389718735904174992978547372448837488832457719009224"
    ],
    [
      "2732872979548118117758016335601225525660858727422778256671975055129965858636",
      "13703031005128062046175331918702218558750713240446179585947851411173844703597",
      "28447710105386636841938034820015573492556750872924193415447818187228356409281"
    ],
    [
      "28539960355005748517007309210788803416171161412204526246799800716567376494244",
      "21329318452221893900731030722137844458345358926323127858742388587761302609863",
      "28135302149599894709369178097439582767613940517471323224020113411362601191873"
    ],
    [
      "24980774120400248734054527936006392540889095705961960837980443629260392758683",
      "20339911045808632098936066397942175169549806052128535543540543556255197716643",
      "7929293103930252545581851978492699598413941396422930641071359388697302362494"
    ],
    [
      "8911092207145893152276662096451247820054843777071569723455408545101628926203",
      "19648860643145256523615441075182036100116634560394529500146405733687718224516",
      "14635387208623683806428528837466762532853903031263830054986064902455379735903"
    ],
    [
      "11555212214346132926966321609673228184079851030522218543981385635403167028692",
      "20896918157639814425520058178561910811657326967880217845710779511927814874973",
      "4650158165912007049140499755153804318686705949436165235742106170124284287326"
    ],
    [
      "13880660273492757167295696447853232191657893303250187467329180558670697369810",
      "8043529172463774320604378774840863923445982272478964686447801046272917236836",
      "2134399296482715903442913099374581981696436050603410080564843555725771329441"
    ],
    [
      "27320952903412641133501507962185246982787769547770982814240701526492601978122",
      "23417491374379751329394424924400186404791519133465537872457405970098902747611",
      "17612427354278346772575179176139417348059847375297761006336024476146551185903"
    ],
    [
      "10710998507064742997612080847223278109404482930427999113323732519626499166548",
      "14958094513415797513745395709487730603918953350067504982704138489305723550923",
      "24096319595904213497633343966229498735553590589105811393277073274927955202995"
    ],
    [
      "17983724131200292654039765185049138356840415443160477259330748730019147254309",
      "17598096800487588874709548646068838880468456205252324677357706597166777506441",
      "27420647821110229619898200875848631488422182349567475956209153112306555222281"
    ],
    [
      "448538544835457571662601142415301047108854812427100562339376187510452313026",
      "23494184556634922103535803143214434479598067155171780264810485708203176455201",
      "22626342941879801989161990529511235538216563009907378573817996229389756621777"
    ],
    [
      "26128268137723417163973860961686381960826033145738852158792607959175787222856",
      "20225791828042873305317281581105429726352058325970107209484198122707862156597",
      "7538871133759632802857159609785118198934349221046986784429069814655215585732"
    ],
    [
      "26184554861259642274153262777073624024579929401668865520166966302070394487366",
      "28755259264665180745537307265993667261709206143628938749669440804401623257679",
      "11896066093033549470312328497237649508068258723531931099214795928200015717321"
    ],
    [
      "21657721599978732693249012287058163532690942515202465984736373311077240614059",
      "9214914097169852704753116653702415951907628005986883140609006971322091003693",
      "18710111680849814325169297240208687402588261569152088592693815711857504371037"
    ],
    [
      "6813635166770764528979084175325709935892248249948967889926276426090222296643",
      "20546585456429436268067726231902751119458200511988152296570567167520382569278",
      "20087466019194902429054761607398988292568594301671509779549344754172952693871"
    ],
    [
      "28185105286740691904534067831357491310995891986363455251895371651360605333143",
      "10108348212894231193041286244259038275269464277821588425688314560368589986063",
      "11433633215392393209829215018579238412423821563056156785641278458497271271546"
    ],
    [
      "27870881917195016999862550657996865268956893566432995492427618003637597051321",
      "102309803677783876701097881491240456320211833502658383473112057006867019389",
      "22844040227595875612525628393174357057929113317578127744718774517498324646590"
    ],
    [
      "18364790233947478619325319418813215212267974311771564959136180502266118026133",
      "2480624341921718230432383518425561514824501138863702825916674641657321180841",
      "16778939567530361665956758171503829349658551798564323167725356065198936433124"
    ],
    [
      "11947564511486966895926950599696532964589539443187518177489990556481125699966",
      "3133187646540385483015602955087323554103587039123577645562801570574691666057",
      "27704797101265438206569218421707753788081674727344603874614391656565567951541"
    ],
    [
      "13001484695584753475562184349533365512515447041450030471627087395341039487710",
      "477322000667279478600757543806155989948171541982639893984064422067850617496",
      "13913755821658634147813329813115566967428755223601185963529801459396673113438"
    ],
    [
      "16621869429023470107454028095846067937827722393398508604914831452950874033411",
      "21755744236927410239079501831014076529931327263341620300431356747367343619046",
      "26538666591151124505694487799121414506088199961481579132019627484065014831180"
    ],
    [
      "3066480818457008068617042549071052338581291837882909165666223566402713429090",
      "16182268213934119294035309949459684472027705439038023775276926916166831108357",
      "28907604876608422892474268478706783033050951245339691569015166507728369585190"
    ],
    [
      "27973960109508292680965426133498827831691369851701664449575719912259359998113",
      "1456924360278399121996742356757866616312146358469991014696110099534285524446",
      "8234248752911525485438611255163504976087091103090603316695312869292347668495"
    ],
    [
      "8716078950082339630026654067608811496722305720644485560320987802533380421009",
      "19016744645809919602099479306503354923553336014593353020688463619133130053825",
      "24379650661051444982012238084495990858827340608012118841005379796362233056432"
    ],
    [
      "2245379544097631382062919677963998259142792890502492881341386639439507471783",
      "28788137434161061988371619554419440748189388934884757179010092973102292086583",
      "7187000185648741287953633167647835668543536354944774631102766873251849991238"
    ],
    [
      "18319349500538500800225762827448369057030532278398270164660609327776487168142",
      "2622932985948021877314529887962683530522545893985767148345336304947201715671",
      "13805188629797792210337544360632964855143280581052079479249966961215582531026"
    ],
    [
      "27457600993464082637917106210690168172469473943609357897393615707457194410878",
      "15448646156961779103834447043970817898237835202826003934642165760908058355399",
      "9396792545729486882231669677795667529746274932273033601723318032992363022062"
    ],
    [
      "9927877141952679457141759789181418464292082444806533413864151258248124544859",
      "23827901395971835838179844085051957393677906360196119690926757794561937573142",
      "3273544693673216914876067527455588276979859627093391584406340272737391174619"
    ],
    [
      "19571510438350300564152393820251652609646082150148656806391655428002614034315",
      "4458840243585913642400750597703353770666314833058197517675446022682775625834",
      "6452218213610300363069953741424106105609715382419342511693148495219793324457"
    ],
    [
      "14558167930891460678441266912176752652821641543245953113671886345167213541771",
      "10650967986920075561478528461783351160938460620955779955379459848889204404950",
      "19990009778942542934049216419052172134625404062770188357110708518621145688588"
    ],
    [
      "26855242974447190235826233682457047761532515293146087151296725996543442567035",
      "22785340043356532865086769889360674409753343398766563441587096485751538658065",
      "28603049427449348335651629195385434188071937908693764500052489540779792538285"
    ],
    [
      "20545812864989828913452616721240947168977365844984763819184465128164378967167",
      "23234068381345797209897730226956922073109641728569353961504167817770340037954",
      "26031714567641615877877111172701145299483019910006153132858512509897185854695"
    ],
    [
      "9512221744061419790435674197238913998387834650389922233458121639503195504983",
      "12587458000103271975978240683793268604398305885278203470492658961734100340536",
      "9670291694005369437277651504604785512303147991710650505302465204429311229197"
    ],
    [
      "26995526763045548800439747262386290359229145489609341602564040676717570935439",
      "23742712112104280264401317024221734961713400615669958343926511931219510484675",
      "27931469778579449247589315744656633392873808631802461175539563849884447358271"
    ],
    [
      "20669006894143187877081688942720159738269397552445286314270368345994751825389",
      "26891772301075275370472640177651637211280740381619976926886106618375467277414",
      "28387986011980449959047232529988203397251084614417760995257355718700961696092"
    ],
    [
      "6579105010484741592730389416372694666279917604793318157514380025250233913402",
      "11007035767869292700964744408562802781669930023548892567535397874932420229930",
      "981148366863906885900456473323410468923514528856216824044152942069412627408"
    ],
    [
      "22213671088722307302576907504985884923571642958053627659840326928319445671280",
      "1318836216310789598614608105109389429335273432455224127576823891011367206122",
      "25586582796990779718352441955439394949194222626688223867952982491529809559257"
    ],
    [
      "4923739488579452777913681531125585976446366144127161879759262506690369040090",
      "23505612338866210737103599484620591026802005128655081877133994175016351514827",
      "323887003859465324514901860965142186539600668250760639664361851354147799637"
    ],
    [
      "10198923064967306784017949469108033682156920551672348936591491217255268794658",
      "9593680688139131432883442351722730169325112619984238956948153423155998917175",
      "27027988263960602112273050725720071355535922812577299127302015348825197871870"
    ],
    [
      "14419883951157390867695097127684346981136020111885301573583640959136319507752",
      "5104414988075833278683649298543440897371415916271358703850262680431809374355",
      "24739655595299332818980677669648719986462429574612913501586844601377825836782"
    ],
    [
      "28522818684103966731129743408029731246564480741348128436668680764518115102581",
      "21520350704208288978690888796633940487888044365108767319141211249242880355961",
      "17391005598311948834360476853940353239444383292422171321575043660157438608537"
    ],
    [
      "15367833944125677011173327826570204350687925236257190051755087781855930646142",
      "21715073802090413714601069529558707101797361591183718695054701329871284436172",
      "8994093285353831008525761670339342200997965950202092028313103110478252647618"
    ],
    [
      "8370824693889782161629525898408725452177580012023459750897244954935682978671",
      "16123253540853556024347150096993154278773652905830608614979368087152152043083",
      "3535380953353495025888433493640531836449699255364366295870140701379497967423"
    ],
    [
      "6954518484798178646508803478426114267143074508396663899281411171704702743829",
      "28903134801897070276701950388422104654018369750191967384271618837091859516942",
      "20872505363530172448468374920196608937030884647150175861507911076568784054834"
    ],
    [
      "6902861581703501105786795670676641959401710346423594578401934671029571262513",
      "10124161387604183369443890585742198433184078889862870469507328332805848271064",
      "10488004060799269337071647841224034919633445750252076195310163972966405029030"
    ],
    [
      "507704911991278613147490289466075160618843900088471236546244459176211783848",
      "7252739745607302667257774481690407709040936359589867974787811552896597703097",
      "23278073497974004442836030100920157527910770509761505828038443336325476654930"
    ],
    [
      "22766285055433137793164317120096790621982728188995759745859222009100808389090",
      "23129058299483468195787339200845749049960038336751758017949899311636830205152",
      "16665333681978951552434356320651834889869437822496200946959897681307959400425"
    ],
    [
      "12145699202182574939376505075528461451757079041659894988784442097333218352048",
      "26340666275844437932755852805027863696219004039301187587209926587657008948704",
      "19208771804191839410002226941825269105677187954811130189835856228258013753206"
    ],
    [
      "21957102494792377508237608216278079874536155315851198461024084071231867104453",
      "6933367436450995525851693784691226222726503560893470094614235356287049091852",
      "15707767379191450768747057313641112321773921923533732633534831270357733757271"
    ],
    [
      "27661963645951389261638591385668507557739541354225916772550248746235106571003",
      "19699458096897937575096494582288688995241392471402204995195057374756282223421",
      "902873385171181344315871113842580653512118892800584003934454469411716098791"
    ],
    [
      "17184835876565576154014372215369798779520343573944211203710896053325717110660",
      "664657295519303589036289440053175741110032988007278988577620229144220576240",
      "10803972669668998371638869508774217165881281885838503958226056357738500321396"
    ],
    [
      "2329846733754251453632375727999372856194157027336139087170310553870624325301",
      "14139944357035048486675740400655356660678187875721949218090128899571575479791",
      "18368148273419807418427674359327442879484531833435081951870369910704734685351"
    ],
    [
      "10480273665080572189328459165704340191901489646067580012574464138528963201459",
      "21773636700078124500346009061678153597323236568110076029811348966753228682835",
      "18184268307211429260956076021417309535471438696101133218049142374847151474905"
    ],
    [
      "25957533025669311312382992376854735734491934602484112256289764602447226406852",
      "22223261506176684934865714490719116745135417403915426392159449667435294570739",
      "22937309162832499167063076416585504361695925730111272512450449042837586253575"
    ],
    [
      "16956181785481598286719868503945127919581091625126206673934113115358441284347",
      "8497782777197814773596870810881707148695901557289856910220737358078100998191",
      "21135503731586600979470064722475007625236017670426339278983640892218291297054"
    ],
    [
      "17809297343844488723046665739910571149089769215421130894378638450427880983923",
      "72435395972188389387093550708873189001876361107443937983754878061522372356",
      "7511239878692099209014947248389283109997289411550315391143819429585903287870"
    ]
  ],
  "fullRounds": 63,
  "partialRounds": 0,
  "hasInitialRoundConstant": true,
  "stateSize": 3,
  "rate": 2,
  "power": 5
};

// dist/node/provable/base58.js
var import_js_sha256 = require("js-sha256");
var alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".split("");
var inverseAlphabet = {};
alphabet.forEach((c, i2) => {
  inverseAlphabet[c] = i2;
});
function toBase58Check(input, versionByte) {
  let withVersion = [versionByte, ...input];
  let checksum = computeChecksum(withVersion);
  let withChecksum = withVersion.concat(checksum);
  return toBase58(withChecksum);
}
function fromBase58Check(base582, versionByte) {
  let bytes = fromBase58(base582);
  let checksum = bytes.slice(-4);
  let originalBytes = bytes.slice(0, -4);
  let actualChecksum = computeChecksum(originalBytes);
  if (!arrayEqual(checksum, actualChecksum))
    throw Error("fromBase58Check: invalid checksum");
  if (originalBytes[0] !== versionByte)
    throw Error(`fromBase58Check: input version byte ${versionByte} does not match encoded version byte ${originalBytes[0]}`);
  return originalBytes.slice(1);
}
function toBase58(bytes) {
  let z = 0;
  while (bytes[z] === 0)
    z++;
  let digits = [...bytes].map(BigInt).reverse();
  let base58Digits = changeBase(digits, 256n, 58n).reverse();
  base58Digits = Array(z).fill(0n).concat(base58Digits);
  return base58Digits.map((x) => alphabet[Number(x)]).join("");
}
function fromBase58(base582) {
  let base58Digits = [...base582].map((c) => {
    let digit = inverseAlphabet[c];
    if (digit === void 0)
      throw Error("fromBase58: invalid character");
    return BigInt(digit);
  });
  let z = 0;
  while (base58Digits[z] === 0n)
    z++;
  let digits = changeBase(base58Digits.reverse(), 58n, 256n).reverse();
  digits = Array(z).fill(0n).concat(digits);
  return digits.map(Number);
}
function computeChecksum(input) {
  let hash1 = import_js_sha256.sha256.create();
  hash1.update(input);
  let hash2 = import_js_sha256.sha256.create();
  hash2.update(hash1.array());
  return hash2.array().slice(0, 4);
}
function base58(binable, versionByte) {
  return {
    toBase58(t) {
      let bytes = binable.toBytes(t);
      return toBase58Check(bytes, versionByte);
    },
    fromBase58(base582) {
      let bytes = fromBase58Check(base582, versionByte);
      return binable.fromBytes(bytes);
    }
  };
}
function withBase58(binable, versionByte) {
  return { ...binable, ...base58(binable, versionByte) };
}
function customEncoding(Field4, versionByte, versionNumber) {
  let customField = versionNumber !== void 0 ? withVersionNumber(Field4, versionNumber) : Field4;
  return base58(customField, versionByte);
}
var RECEIPT_CHAIN_HASH_VERSION = 1;
var LEDGER_HASH_VERSION = 1;
var EPOCH_SEED_VERSION = 1;
var STATE_HASH_VERSION = 1;
function fieldEncodings(Field4) {
  const TokenId4 = customEncoding(Field4, versionBytes.tokenIdKey);
  const ReceiptChainHash3 = customEncoding(Field4, versionBytes.receiptChainHash, RECEIPT_CHAIN_HASH_VERSION);
  const LedgerHash2 = customEncoding(Field4, versionBytes.ledgerHash, LEDGER_HASH_VERSION);
  const EpochSeed2 = customEncoding(Field4, versionBytes.epochSeed, EPOCH_SEED_VERSION);
  const StateHash3 = customEncoding(Field4, versionBytes.stateHash, STATE_HASH_VERSION);
  return { TokenId: TokenId4, ReceiptChainHash: ReceiptChainHash3, LedgerHash: LedgerHash2, EpochSeed: EpochSeed2, StateHash: StateHash3 };
}
function arrayEqual(a, b2) {
  if (a.length !== b2.length)
    return false;
  for (let i2 = 0; i2 < a.length; i2++) {
    if (a[i2] !== b2[i2])
      return false;
  }
  return true;
}

// dist/node/provable/provable-generic.js
function createProvable() {
  const HashInput3 = createHashInput();
  let complexTypes2 = /* @__PURE__ */ new Set(["object", "function"]);
  function provable3(typeObj, options) {
    let objectKeys = typeof typeObj === "object" && typeObj !== null ? options?.customObjectKeys ?? Object.keys(typeObj).sort() : [];
    let nonCircuitPrimitives = /* @__PURE__ */ new Set([
      Number,
      String,
      Boolean,
      BigInt,
      null,
      void 0
    ]);
    if (!nonCircuitPrimitives.has(typeObj) && !complexTypes2.has(typeof typeObj)) {
      throw Error(`provable: unsupported type "${typeObj}"`);
    }
    function sizeInFields(typeObj2) {
      if (nonCircuitPrimitives.has(typeObj2))
        return 0;
      if (!complexTypes2.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2))
        return typeObj2.map(sizeInFields).reduce((a, b2) => a + b2, 0);
      if ("sizeInFields" in typeObj2)
        return typeObj2.sizeInFields();
      return Object.values(typeObj2).map(sizeInFields).reduce((a, b2) => a + b2, 0);
    }
    function toFields(typeObj2, obj, isToplevel = false) {
      if (nonCircuitPrimitives.has(typeObj2))
        return [];
      if (!complexTypes2.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i2) => toFields(t, obj[i2])).flat();
      if ("toFields" in typeObj2)
        return typeObj2.toFields(obj);
      return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => toFields(typeObj2[k], obj[k])).flat();
    }
    function toAuxiliary(typeObj2, obj, isToplevel = false) {
      if (typeObj2 === Number)
        return [obj ?? 0];
      if (typeObj2 === String)
        return [obj ?? ""];
      if (typeObj2 === Boolean)
        return [obj ?? false];
      if (typeObj2 === BigInt)
        return [obj ?? 0n];
      if (typeObj2 === void 0 || typeObj2 === null)
        return [];
      if (!complexTypes2.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i2) => toAuxiliary(t, obj?.[i2]));
      if ("toAuxiliary" in typeObj2)
        return typeObj2.toAuxiliary(obj);
      return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => toAuxiliary(typeObj2[k], obj?.[k]));
    }
    function toInput(typeObj2, obj, isToplevel = false) {
      if (nonCircuitPrimitives.has(typeObj2))
        return {};
      if (!complexTypes2.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2)) {
        return typeObj2.map((t, i2) => toInput(t, obj[i2])).reduce(HashInput3.append, HashInput3.empty);
      }
      if ("toInput" in typeObj2)
        return typeObj2.toInput(obj);
      if ("toFields" in typeObj2) {
        return { fields: typeObj2.toFields(obj) };
      }
      return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => toInput(typeObj2[k], obj[k])).reduce(HashInput3.append, HashInput3.empty);
    }
    function toJSON(typeObj2, obj, isToplevel = false) {
      if (typeObj2 === BigInt)
        return obj.toString();
      if (typeObj2 === String || typeObj2 === Number || typeObj2 === Boolean)
        return obj;
      if (typeObj2 === void 0 || typeObj2 === null)
        return null;
      if (!complexTypes2.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i2) => toJSON(t, obj[i2]));
      if ("toJSON" in typeObj2)
        return typeObj2.toJSON(obj);
      return Object.fromEntries((isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => [
        k,
        toJSON(typeObj2[k], obj[k])
      ]));
    }
    function fromFields(typeObj2, fields, aux = [], isToplevel = false) {
      if (typeObj2 === Number || typeObj2 === String || typeObj2 === Boolean || typeObj2 === BigInt)
        return aux[0];
      if (typeObj2 === void 0 || typeObj2 === null)
        return typeObj2;
      if (!complexTypes2.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2)) {
        let array = [];
        let i2 = 0;
        let offset = 0;
        for (let subObj of typeObj2) {
          let size = sizeInFields(subObj);
          array.push(fromFields(subObj, fields.slice(offset, offset + size), aux[i2]));
          offset += size;
          i2++;
        }
        return array;
      }
      if ("fromFields" in typeObj2)
        return typeObj2.fromFields(fields, aux);
      let keys = isToplevel ? objectKeys : Object.keys(typeObj2).sort();
      let values = fromFields(keys.map((k) => typeObj2[k]), fields, aux);
      return Object.fromEntries(keys.map((k, i2) => [k, values[i2]]));
    }
    function fromJSON(typeObj2, json, isToplevel = false) {
      if (typeObj2 === BigInt)
        return BigInt(json);
      if (typeObj2 === String || typeObj2 === Number || typeObj2 === Boolean)
        return json;
      if (typeObj2 === null || typeObj2 === void 0)
        return void 0;
      if (!complexTypes2.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2))
        return typeObj2.map((t, i2) => fromJSON(t, json[i2]));
      if ("fromJSON" in typeObj2)
        return typeObj2.fromJSON(json);
      let keys = isToplevel ? objectKeys : Object.keys(typeObj2).sort();
      let values = fromJSON(keys.map((k) => typeObj2[k]), json);
      return Object.fromEntries(keys.map((k, i2) => [k, values[i2]]));
    }
    function check(typeObj2, obj, isToplevel = false) {
      if (nonCircuitPrimitives.has(typeObj2))
        return;
      if (!complexTypes2.has(typeof typeObj2))
        throw Error(`provable: unsupported type "${typeObj2}"`);
      if (Array.isArray(typeObj2))
        return typeObj2.forEach((t, i2) => check(t, obj[i2]));
      if ("check" in typeObj2)
        return typeObj2.check(obj);
      return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).forEach((k) => check(typeObj2[k], obj[k]));
    }
    if (options?.isPure === true) {
      return {
        sizeInFields: () => sizeInFields(typeObj),
        toFields: (obj) => toFields(typeObj, obj, true),
        toAuxiliary: () => [],
        fromFields: (fields) => fromFields(typeObj, fields, [], true),
        toInput: (obj) => toInput(typeObj, obj, true),
        toJSON: (obj) => toJSON(typeObj, obj, true),
        fromJSON: (json) => fromJSON(typeObj, json, true),
        check: (obj) => check(typeObj, obj, true)
      };
    }
    return {
      sizeInFields: () => sizeInFields(typeObj),
      toFields: (obj) => toFields(typeObj, obj, true),
      toAuxiliary: (obj) => toAuxiliary(typeObj, obj, true),
      fromFields: (fields, aux) => fromFields(typeObj, fields, aux, true),
      toInput: (obj) => toInput(typeObj, obj, true),
      toJSON: (obj) => toJSON(typeObj, obj, true),
      fromJSON: (json) => fromJSON(typeObj, json, true),
      check: (obj) => check(typeObj, obj, true)
    };
  }
  return provable3;
}
function createHashInput() {
  return {
    get empty() {
      return {};
    },
    append(input1, input2) {
      return {
        fields: (input1.fields ?? []).concat(input2.fields ?? []),
        packed: (input1.packed ?? []).concat(input2.packed ?? [])
      };
    }
  };
}

// dist/node/provable/provable-bigint.js
var provable = createProvable();

// dist/node/provable/curve-bigint.js
var versionNumbers = {
  field: 1,
  scalar: 1,
  publicKey: 1,
  signature: 1
};
var Group2 = {
  toProjective({ x, y }) {
    return Pallas.fromAffine({ x, y, infinity: false });
  },
  /**
   * Convert a projective point to a non-zero affine point.
   * Throws an error if the point is zero / infinity, i.e. if z === 0
   */
  fromProjective(point) {
    let { x, y, infinity } = Pallas.toAffine(point);
    if (infinity)
      throw Error("Group.fromProjective: point is infinity");
    return { x, y };
  },
  get generatorMina() {
    return Group2.fromProjective(Pallas.one);
  },
  scale(point, scalar) {
    return Group2.fromProjective(Pallas.scale(Group2.toProjective(point), scalar));
  },
  b: Pallas.b
};
var FieldWithVersion = withVersionNumber(Field2, versionNumbers.field);
var BinablePublicKey = withVersionNumber(withCheck(record({ x: FieldWithVersion, isOdd: Bool2 }, ["x", "isOdd"]), ({ x }) => {
  let { mul, add } = Field2;
  let ySquared = add(mul(x, mul(x, x)), Pallas.b);
  if (!Field2.isSquare(ySquared)) {
    throw Error("PublicKey: not a valid group element");
  }
}), versionNumbers.publicKey);
var PublicKey = {
  ...provable({ x: Field2, isOdd: Bool2 }),
  ...withBase58(BinablePublicKey, versionBytes.publicKey),
  toJSON(publicKey) {
    return PublicKey.toBase58(publicKey);
  },
  fromJSON(json) {
    return PublicKey.fromBase58(json);
  },
  toGroup({ x, isOdd }) {
    let { mul, add } = Field2;
    let ySquared = add(mul(x, mul(x, x)), Pallas.b);
    let y = Field2.sqrt(ySquared);
    if (y === void 0) {
      throw Error("PublicKey.toGroup: not a valid group element");
    }
    if (isOdd !== (y & 1n))
      y = Field2.negate(y);
    return { x, y };
  },
  fromGroup({ x, y }) {
    let isOdd = y & 1n;
    return { x, isOdd };
  },
  equal(pk1, pk2) {
    return pk1.x === pk2.x && pk1.isOdd === pk2.isOdd;
  },
  toInputLegacy({ x, isOdd }) {
    return { fields: [x], bits: [!!isOdd] };
  }
};
var checkScalar = checkRange(0n, Fq.modulus, "Scalar");
var Scalar2 = pseudoClass(function Scalar3(value) {
  return mod(BigInt(value), Fq.modulus);
}, {
  ...ProvableBigint(checkScalar),
  ...BinableBigint(Fq.sizeInBits, checkScalar),
  ...Fq
});
var BinablePrivateKey = withVersionNumber(Scalar2, versionNumbers.scalar);
var Base58PrivateKey = base58(BinablePrivateKey, versionBytes.privateKey);
var PrivateKey = {
  ...Scalar2,
  ...provable(Scalar2),
  ...Base58PrivateKey,
  ...BinablePrivateKey,
  toPublicKey(key) {
    return PublicKey.fromGroup(Group2.scale(Group2.generatorMina, key));
  }
};

// dist/node/lib/core.js
Field.toAuxiliary = () => [];
Bool.toAuxiliary = () => [];
Scalar.toAuxiliary = () => [];
Group.toAuxiliary = () => [];
Field.toInput = function(x) {
  return { fields: [x] };
};
var FieldBinable = defineBinable({
  toBytes(t) {
    return [...t.toConstant().value[1]];
  },
  readBytes(bytes, offset) {
    let uint8array = new Uint8Array(32);
    uint8array.set(bytes.slice(offset, offset + 32));
    return [
      Object.assign(Object.create(Field(1).constructor.prototype), {
        value: [0, uint8array]
      }),
      offset + 32
    ];
  }
});
Field.toBytes = FieldBinable.toBytes;
Field.fromBytes = FieldBinable.fromBytes;
Field.readBytes = FieldBinable.readBytes;
Field.sizeInBytes = () => 32;
Bool.toInput = function(x) {
  return { packed: [[x.toField(), 1]] };
};
var BoolBinable = defineBinable({
  toBytes(b2) {
    return [Number(b2.toBoolean())];
  },
  readBytes(bytes, offset) {
    return [Bool(!!bytes[offset]), offset + 1];
  }
});
Bool.toBytes = BoolBinable.toBytes;
Bool.fromBytes = BoolBinable.fromBytes;
Bool.readBytes = BoolBinable.readBytes;
Bool.sizeInBytes = () => 1;
Scalar.toFieldsCompressed = function(s) {
  let isConstant = s.toFields().every((x2) => x2.isConstant());
  let constantValue = s.constantValue;
  if (!isConstant || constantValue === void 0)
    throw Error(`Scalar.toFieldsCompressed is not available in provable code.
That means it can't be called in a @method or similar environment, and there's no alternative implemented to achieve that.`);
  let x = bytesToBigInt(constantValue);
  let lowBitSize = BigInt(sizeInBits - 1);
  let lowBitMask = (1n << lowBitSize) - 1n;
  return {
    field: Field(x & lowBitMask),
    highBit: Bool(x >> lowBitSize === 1n)
  };
};
Scalar.fromBigInt = function(scalar) {
  scalar = mod(scalar, Scalar2.modulus);
  return Scalar.fromJSON(scalar.toString());
};

// dist/node/snarky/addons.js
function getJsooRuntime() {
  return globalThis.jsoo_runtime;
}
function getSrs(keypair) {
  return keypair.value[2][4];
}
function serializeVerificationKey(verificationKey) {
  let wasm = getWasm();
  let runtime = getJsooRuntime();
  let isFp = verificationKey.value[4].constructor.name === "WasmFpSrs";
  return isFp ? wasm.caml_pasta_fp_plonk_verifier_index_serialize(runtime.caml_pasta_fp_plonk_verifier_index_to_rust(verificationKey.value)) : wasm.caml_pasta_fq_plonk_verifier_index_serialize(runtime.caml_pasta_fq_plonk_verifier_index_to_rust(verificationKey.value));
}
function recoverVerificationKey(srs, serializedVk) {
  let vkRust = getWasm().caml_pasta_fp_plonk_verifier_index_deserialize(srs, serializedVk);
  let vk = getJsooRuntime().caml_pasta_fp_plonk_verifier_index_of_rust(vkRust);
  return Circuit.getVerificationKey(vk);
}

// dist/node/lib/circuit_value.js
var import_reflect_metadata = require("reflect-metadata");

// dist/node/lib/global-context.js
var Context = { create };
function create(options = {
  allowsNesting: true,
  default: void 0
}) {
  let t = Object.assign(function() {
    return t.data[t.data.length - 1]?.context;
  }, {
    data: [],
    allowsNesting: options.allowsNesting ?? true,
    get: () => get(t),
    has: () => t.data.length !== 0,
    runWith: (context, func) => runWith(t, context, func),
    runWithAsync: (context, func) => runWithAsync(t, context, func),
    enter: (context) => enter(t, context),
    leave: (id) => leave(t, id),
    id: () => {
      if (t.data.length === 0)
        throw Error(contextConflictMessage);
      return t.data[t.data.length - 1].id;
    }
  });
  if (options.default !== void 0)
    enter(t, options.default);
  return t;
}
function enter(t, context) {
  if (t.data.length > 0 && !t.allowsNesting) {
    throw Error(contextConflictMessage);
  }
  let id = Math.random();
  t.data.push({ context, id });
  return id;
}
function leave(t, id) {
  let current = t.data.pop();
  if (current === void 0)
    throw Error(contextConflictMessage);
  if (current.id !== id)
    throw Error(contextConflictMessage);
  return current.context;
}
function get(t) {
  if (t.data.length === 0)
    throw Error(contextConflictMessage);
  let current = t.data[t.data.length - 1];
  return current.context;
}
function runWith(t, context, func) {
  let id = enter(t, context);
  let result;
  let resultContext;
  try {
    result = func(context);
  } finally {
    resultContext = leave(t, id);
  }
  return [resultContext, result];
}
async function runWithAsync(t, context, func) {
  let id = enter(t, context);
  let result;
  let resultContext;
  try {
    result = await func(context);
  } finally {
    resultContext = leave(t, id);
  }
  return [resultContext, result];
}
var contextConflictMessage = "It seems you're running multiple provers concurrently within the same JavaScript thread, which, at the moment, is not supported and would lead to bugs.";

// dist/node/lib/proof_system.js
var snarkContext = Context.create({ default: {} });
var Proof = class {
  verify() {
    this.shouldVerify = Bool(true);
  }
  verifyIf(condition) {
    this.shouldVerify = condition;
  }
  toJSON() {
    return {
      publicInput: getPublicInputType(this.constructor).toFields(this.publicInput).map(String),
      maxProofsVerified: this.maxProofsVerified,
      proof: Pickles.proofToBase64([this.maxProofsVerified, this.proof])
    };
  }
  static fromJSON({ maxProofsVerified, proof: proofString, publicInput: publicInputJson }) {
    let [, proof] = Pickles.proofOfBase64(proofString, maxProofsVerified);
    let publicInput = getPublicInputType(this).fromFields(publicInputJson.map(Field));
    return new this({ publicInput, proof, maxProofsVerified });
  }
  constructor({ proof, publicInput, maxProofsVerified }) {
    this.shouldVerify = Bool(false);
    this.publicInput = publicInput;
    this.proof = proof;
    this.maxProofsVerified = maxProofsVerified;
  }
};
Proof.publicInputType = void 0;
Proof.tag = () => {
  throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:
class MyProof extends Proof<PublicInput> { ... }`);
};
function verify(proof, verificationKey) {
  if (typeof proof.proof === "string") {
    let [, picklesProof] = Pickles.proofOfBase64(proof.proof, proof.maxProofsVerified);
    let publicInputFields = proof.publicInput.map(Field);
    return Pickles.verify(publicInputFields, picklesProof, verificationKey);
  } else {
    let publicInputFields = getPublicInputType(proof.constructor).toFields(proof.publicInput);
    return Pickles.verify(publicInputFields, proof.proof, verificationKey);
  }
}
var compiledTags = /* @__PURE__ */ new WeakMap();
var CompiledTag = {
  get(tag) {
    return compiledTags.get(tag);
  },
  store(tag, compiledTag) {
    compiledTags.set(tag, compiledTag);
  }
};
function ZkProgram({ publicInput: publicInputType, methods }) {
  let selfTag = { name: `Program${i++}` };
  class SelfProof2 extends Proof {
  }
  SelfProof2.publicInputType = publicInputType;
  SelfProof2.tag = () => selfTag;
  let keys = Object.keys(methods).sort();
  let methodIntfs = keys.map((key) => sortMethodArguments("program", key, methods[key].privateInputs, SelfProof2));
  let methodFunctions = keys.map((key) => methods[key].method);
  let maxProofsVerified = methodIntfs.reduce((acc, { proofArgs }) => Math.max(acc, proofArgs.length), 0);
  let compileOutput;
  async function compile() {
    let { provers: provers2, verify: verify3, getVerificationKeyArtifact } = compileProgram(publicInputType, methodIntfs, methodFunctions, selfTag);
    compileOutput = { provers: provers2, verify: verify3 };
    return { verificationKey: getVerificationKeyArtifact().data };
  }
  function toProver(key, i2) {
    async function prove(publicInput, ...args) {
      let picklesProver = compileOutput?.provers?.[i2];
      if (picklesProver === void 0) {
        throw Error(`Cannot prove execution of program.${key}(), no prover found. Try calling \`await program.compile()\` first, this will cache provers in the background.`);
      }
      let publicInputFields = publicInputType.toFields(publicInput);
      let previousProofs = getPreviousProofsForProver(args, methodIntfs[i2]);
      let [, proof] = await snarkContext.runWithAsync({ witnesses: args, inProver: true }, () => picklesProver(publicInputFields, previousProofs));
      class ProgramProof extends Proof {
      }
      ProgramProof.publicInputType = publicInputType;
      ProgramProof.tag = () => selfTag;
      return new ProgramProof({ publicInput, proof, maxProofsVerified });
    }
    return [key, prove];
  }
  let provers = Object.fromEntries(keys.map(toProver));
  function verify2(proof) {
    if (compileOutput?.verify === void 0) {
      throw Error(`Cannot verify proof, verification key not found. Try calling \`await program.compile()\` first.`);
    }
    return compileOutput.verify(publicInputType.toFields(proof.publicInput), proof.proof);
  }
  function digest() {
    let methodData = methodIntfs.map((methodEntry, i2) => analyzeMethod(publicInputType, methodEntry, methodFunctions[i2]));
    let hash2 = Poseidon.hash(Object.values(methodData).map((d) => Field(BigInt("0x" + d.digest))), false);
    return hash2.toBigInt().toString(16);
  }
  function analyzeMethods() {
    return methodIntfs.map((methodEntry, i2) => analyzeMethod(publicInputType, methodEntry, methodFunctions[i2]));
  }
  return Object.assign(selfTag, { compile, verify: verify2, digest, publicInputType, analyzeMethods }, provers);
}
var i = 0;
var SelfProof = class extends Proof {
};
function sortMethodArguments(programName, methodName, privateInputs, selfProof) {
  let witnessArgs = [];
  let proofArgs = [];
  let allArgs = [];
  let genericArgs = [];
  for (let i2 = 0; i2 < privateInputs.length; i2++) {
    let privateInput = privateInputs[i2];
    if (isProof(privateInput)) {
      if (privateInput === Proof) {
        throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:
class MyProof extends Proof<PublicInput> { ... }`);
      }
      allArgs.push({ type: "proof", index: proofArgs.length });
      if (privateInput === SelfProof) {
        proofArgs.push(selfProof);
      } else {
        proofArgs.push(privateInput);
      }
    } else if (isAsFields(privateInput)) {
      allArgs.push({ type: "witness", index: witnessArgs.length });
      witnessArgs.push(privateInput);
    } else if (isGeneric(privateInput)) {
      allArgs.push({ type: "generic", index: genericArgs.length });
      genericArgs.push(privateInput);
    } else {
      throw Error(`Argument ${i2 + 1} of method ${methodName} is not a provable type: ${privateInput}`);
    }
  }
  if (proofArgs.length > 2) {
    throw Error(`${programName}.${methodName}() has more than two proof arguments, which is not supported.
Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`);
  }
  return {
    methodName,
    witnessArgs,
    proofArgs,
    allArgs,
    genericArgs
  };
}
function isAsFields(type) {
  return (typeof type === "function" || typeof type === "object") && type !== null && ["toFields", "fromFields", "sizeInFields", "toAuxiliary"].every((s) => s in type);
}
function isProof(type) {
  return type === Proof || typeof type === "function" && type.prototype instanceof Proof;
}
var GenericArgument = class {
  constructor(isEmpty = false) {
    this.isEmpty = isEmpty;
  }
};
var emptyGeneric = () => new GenericArgument(true);
function isGeneric(type) {
  return type === GenericArgument || typeof type === "function" && type.prototype instanceof GenericArgument;
}
function getPreviousProofsForProver(methodArgs, { allArgs, proofArgs }) {
  let previousProofs = [];
  for (let i2 = 0; i2 < allArgs.length; i2++) {
    let arg = allArgs[i2];
    if (arg.type === "proof") {
      let { proof, publicInput } = methodArgs[i2];
      let publicInputType = getPublicInputType(proofArgs[arg.index]);
      previousProofs[arg.index] = {
        publicInput: publicInputType.toFields(publicInput),
        proof
      };
    }
  }
  return previousProofs;
}
function compileProgram(publicInputType, methodIntfs, methods, proofSystemTag) {
  let rules = methodIntfs.map((methodEntry, i2) => picklesRuleFromFunction(publicInputType, methods[i2], proofSystemTag, methodEntry));
  let [, { getVerificationKeyArtifact, provers, verify: verify2, tag }] = snarkContext.runWith({ inCompile: true }, () => Pickles.compile(rules, publicInputType.sizeInFields()));
  CompiledTag.store(proofSystemTag, tag);
  return { getVerificationKeyArtifact, provers, verify: verify2, tag };
}
function analyzeMethod(publicInputType, methodIntf, method2) {
  return Circuit.constraintSystem(() => {
    let args = synthesizeMethodArguments(methodIntf, true);
    let publicInput = emptyWitness(publicInputType);
    return method2(publicInput, ...args);
  });
}
function picklesRuleFromFunction(publicInputType, func, proofSystemTag, { methodName, witnessArgs, proofArgs, allArgs }) {
  function main(publicInput, previousInputs) {
    let { witnesses: argsWithoutPublicInput } = snarkContext.get();
    let finalArgs = [];
    let proofs = [];
    for (let i2 = 0; i2 < allArgs.length; i2++) {
      let arg = allArgs[i2];
      if (arg.type === "witness") {
        let type = witnessArgs[arg.index];
        finalArgs[i2] = argsWithoutPublicInput ? Circuit.witness(type, () => argsWithoutPublicInput[i2]) : emptyWitness(type);
      } else if (arg.type === "proof") {
        let Proof2 = proofArgs[arg.index];
        let publicInput2 = getPublicInputType(Proof2).fromFields(previousInputs[arg.index]);
        let proofInstance;
        if (argsWithoutPublicInput) {
          let { proof } = argsWithoutPublicInput[i2];
          proofInstance = new Proof2({ publicInput: publicInput2, proof });
        } else {
          proofInstance = new Proof2({ publicInput: publicInput2, proof: void 0 });
        }
        finalArgs[i2] = proofInstance;
        proofs.push(proofInstance);
      } else if (arg.type === "generic") {
        finalArgs[i2] = argsWithoutPublicInput?.[i2] ?? emptyGeneric();
      }
    }
    func(publicInputType.fromFields(publicInput), ...finalArgs);
    return proofs.map((proof) => proof.shouldVerify);
  }
  if (proofArgs.length > 2) {
    throw Error(`${proofSystemTag.name}.${methodName}() has more than two proof arguments, which is not supported.
Suggestion: You can merge more than two proofs by merging two at a time in a binary tree.`);
  }
  let proofsToVerify = proofArgs.map((Proof2) => {
    let tag = Proof2.tag();
    if (tag === proofSystemTag)
      return { isSelf: true };
    else {
      let compiledTag = CompiledTag.get(tag);
      if (compiledTag === void 0) {
        throw Error(`${proofSystemTag.name}.compile() depends on ${tag.name}, but we cannot find compilation output for ${tag.name}.
Try to run ${tag.name}.compile() first.`);
      }
      return { isSelf: false, tag: compiledTag };
    }
  });
  return { identifier: methodName, main, proofsToVerify };
}
function synthesizeMethodArguments({ allArgs, proofArgs, witnessArgs }, asVariables = false) {
  let args = [];
  let empty = asVariables ? emptyWitness : emptyValue;
  for (let arg of allArgs) {
    if (arg.type === "witness") {
      args.push(empty(witnessArgs[arg.index]));
    } else if (arg.type === "proof") {
      let Proof2 = proofArgs[arg.index];
      let publicInput = empty(getPublicInputType(Proof2));
      args.push(new Proof2({ publicInput, proof: void 0 }));
    } else if (arg.type === "generic") {
      args.push(emptyGeneric());
    }
  }
  return args;
}
function methodArgumentsToConstant({ allArgs, proofArgs, witnessArgs }, args) {
  let constArgs = [];
  for (let i2 = 0; i2 < allArgs.length; i2++) {
    let arg = args[i2];
    let { type, index } = allArgs[i2];
    if (type === "witness") {
      constArgs.push(toConstant(witnessArgs[index], arg));
    } else if (type === "proof") {
      let Proof2 = proofArgs[index];
      let publicInput = toConstant(getPublicInputType(Proof2), arg.publicInput);
      constArgs.push(new Proof2({ publicInput, proof: arg.proof }));
    } else if (type === "generic") {
      constArgs.push(arg);
    }
  }
  return constArgs;
}
var Generic = provable2(null);
function methodArgumentTypesAndValues({ allArgs, proofArgs, witnessArgs }, args) {
  let typesAndValues = [];
  for (let i2 = 0; i2 < allArgs.length; i2++) {
    let arg = args[i2];
    let { type, index } = allArgs[i2];
    if (type === "witness") {
      typesAndValues.push({ type: witnessArgs[index], value: arg });
    } else if (type === "proof") {
      let Proof2 = proofArgs[index];
      typesAndValues.push({
        type: getPublicInputType(Proof2),
        value: arg.publicInput
      });
    } else if (type === "generic") {
      typesAndValues.push({ type: Generic, value: arg });
    }
  }
  return typesAndValues;
}
function emptyValue(type) {
  return type.fromFields(Array(type.sizeInFields()).fill(Field(0)), type.toAuxiliary());
}
function emptyWitness(type) {
  return Circuit.witness(type, () => emptyValue(type));
}
function getPublicInputType(Proof2) {
  if (Proof2.publicInputType === void 0) {
    throw Error(`You cannot use the \`Proof\` class directly. Instead, define a subclass:
class MyProof extends Proof<PublicInput> { ... }`);
  }
  return Proof2.publicInputType;
}
ZkProgram.Proof = function(program) {
  var _a;
  return _a = class ZkProgramProof extends Proof {
  }, _a.publicInputType = program.publicInputType, _a.tag = () => program, _a;
};
function Prover() {
  return {
    async run(witnesses, proverData, callback) {
      return snarkContext.runWithAsync({ witnesses, proverData, inProver: true }, callback);
    },
    getData() {
      return snarkContext.get().proverData;
    }
  };
}
function inProver() {
  return !!snarkContext.get().inProver;
}
function inCompile() {
  return !!snarkContext.get().inCompile;
}
function inAnalyze() {
  return !!snarkContext.get().inAnalyze;
}
function inCheckedComputation() {
  let ctx = snarkContext.get();
  return !!ctx.inCompile || !!ctx.inProver || !!ctx.inCheckedComputation;
}

// dist/node/lib/circuit_value.js
var HashInput = {
  get empty() {
    return {};
  },
  append(input1, input2) {
    return {
      fields: (input1.fields ?? []).concat(input2.fields ?? []),
      packed: (input1.packed ?? []).concat(input2.packed ?? [])
    };
  }
};
var CircuitValue = class {
  constructor(...props) {
    if (props.length === 0)
      return;
    let fields = this.constructor.prototype._fields;
    if (fields === void 0)
      return;
    if (props.length !== fields.length) {
      throw Error(`${this.constructor.name} constructor called with ${props.length} arguments, but expected ${fields.length}`);
    }
    for (let i2 = 0; i2 < fields.length; ++i2) {
      let [key] = fields[i2];
      this[key] = props[i2];
    }
  }
  static fromObject(value) {
    return Object.assign(Object.create(this.prototype), value);
  }
  static sizeInFields() {
    const fields = this.prototype._fields;
    return fields.reduce((acc, [_, typ]) => acc + typ.sizeInFields(), 0);
  }
  static toFields(v) {
    const res = [];
    const fields = this.prototype._fields;
    if (fields === void 0 || fields === null) {
      return res;
    }
    for (let i2 = 0, n = fields.length; i2 < n; ++i2) {
      const [key, propType] = fields[i2];
      const subElts = propType.toFields(v[key]);
      subElts.forEach((x) => res.push(x));
    }
    return res;
  }
  static toAuxiliary() {
    return [];
  }
  static toInput(v) {
    let input = { fields: [], packed: [] };
    let fields = this.prototype._fields;
    if (fields === void 0)
      return input;
    for (let i2 = 0, n = fields.length; i2 < n; ++i2) {
      let [key, type] = fields[i2];
      if ("toInput" in type) {
        input = HashInput.append(input, type.toInput(v[key]));
        continue;
      }
      let xs = type.toFields(v[key]);
      input.fields.push(...xs);
    }
    return input;
  }
  toFields() {
    return this.constructor.toFields(this);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
  toConstant() {
    return this.constructor.toConstant(this);
  }
  equals(x) {
    return Circuit.equal(this, x);
  }
  assertEquals(x) {
    Circuit.assertEqual(this, x);
  }
  isConstant() {
    return this.toFields().every((x) => x.isConstant());
  }
  static fromFields(xs) {
    const fields = this.prototype._fields;
    if (xs.length < fields.length) {
      throw Error(`${this.name}.fromFields: Expected ${fields.length} field elements, got ${xs?.length}`);
    }
    let offset = 0;
    const props = {};
    for (let i2 = 0; i2 < fields.length; ++i2) {
      const [key, propType] = fields[i2];
      const propSize = propType.sizeInFields();
      const propVal = propType.fromFields(xs.slice(offset, offset + propSize), []);
      props[key] = propVal;
      offset += propSize;
    }
    return Object.assign(Object.create(this.prototype), props);
  }
  static check(v) {
    const fields = this.prototype._fields;
    if (fields === void 0 || fields === null) {
      return;
    }
    for (let i2 = 0; i2 < fields.length; ++i2) {
      const [key, propType] = fields[i2];
      const value = v[key];
      if (propType.check === void 0)
        throw Error("bug: CircuitValue without .check()");
      propType.check(value);
    }
  }
  static toConstant(t) {
    const xs = this.toFields(t);
    return this.fromFields(xs.map((x) => x.toConstant()));
  }
  static toJSON(v) {
    const res = {};
    if (this.prototype._fields !== void 0) {
      const fields = this.prototype._fields;
      fields.forEach(([key, propType]) => {
        res[key] = propType.toJSON(v[key]);
      });
    }
    return res;
  }
  static fromJSON(value) {
    let props = {};
    let fields = this.prototype._fields;
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw Error(`${this.name}.fromJSON(): invalid input ${value}`);
    }
    if (fields !== void 0) {
      for (let i2 = 0; i2 < fields.length; ++i2) {
        let [key, propType] = fields[i2];
        if (value[key] === void 0) {
          throw Error(`${this.name}.fromJSON(): invalid input ${value}`);
        } else {
          props[key] = propType.fromJSON(value[key]);
        }
      }
    }
    return Object.assign(Object.create(this.prototype), props);
  }
};
function prop(target, key) {
  const fieldType = Reflect.getMetadata("design:type", target, key);
  if (!target.hasOwnProperty("_fields")) {
    target._fields = [];
  }
  if (fieldType === void 0) {
  } else if (fieldType.toFields && fieldType.fromFields) {
    target._fields.push([key, fieldType]);
  } else {
    console.log(`warning: property ${key} missing field element conversion methods`);
  }
}
function circuitArray(elementType, length) {
  let type = elementType;
  return {
    /**
     * Returns the size of this structure in {@link Field} elements.
     * @returns size of this structure
     */
    sizeInFields() {
      let elementLength = type.sizeInFields();
      return elementLength * length;
    },
    /**
     * Serializes this structure into {@link Field} elements.
     * @returns an array of {@link Field} elements
     */
    toFields(array) {
      return array.map((e) => type.toFields(e)).flat();
    },
    /**
     * Serializes this structure's auxiliary data.
     * @returns auxiliary data
     */
    toAuxiliary(array) {
      let array_ = array ?? Array(length).fill(void 0);
      return array_?.map((e) => type.toAuxiliary(e));
    },
    /**
     * Deserializes an array of {@link Field} elements into this structure.
     */
    fromFields(fields, aux) {
      let array = [];
      let size = type.sizeInFields();
      let n = length;
      for (let i2 = 0, offset = 0; i2 < n; i2++, offset += size) {
        array[i2] = type.fromFields(fields.slice(offset, offset + size), aux?.[i2]);
      }
      return array;
    },
    check(array) {
      for (let i2 = 0; i2 < length; i2++) {
        type.check(array[i2]);
      }
    },
    /**
     * Encodes this structure into a JSON-like object.
     */
    toJSON(array) {
      if (!("toJSON" in type)) {
        throw Error("circuitArray.toJSON: element type has no toJSON method");
      }
      return array.map((v) => type.toJSON(v));
    },
    /**
     * Decodes a JSON-like object into this structure.
     */
    fromJSON(json) {
      if (!("fromJSON" in type)) {
        throw Error("circuitArray.fromJSON: element type has no fromJSON method");
      }
      return json.map((a) => type.fromJSON(a));
    },
    toInput(array) {
      if (!("toInput" in type)) {
        throw Error("circuitArray.toInput: element type has no toInput method");
      }
      return array.reduce((curr, value) => HashInput.append(curr, type.toInput(value)), HashInput.empty);
    }
  };
}
function arrayProp(elementType, length) {
  return function(target, key) {
    if (!target.hasOwnProperty("_fields")) {
      target._fields = [];
    }
    target._fields.push([key, circuitArray(elementType, length)]);
  };
}
function matrixProp(elementType, nRows, nColumns) {
  return function(target, key) {
    if (!target.hasOwnProperty("_fields")) {
      target._fields = [];
    }
    target._fields.push([
      key,
      circuitArray(circuitArray(elementType, nColumns), nRows)
    ]);
  };
}
function public_(target, _key, index) {
  if (target._public === void 0) {
    target._public = [];
  }
  target._public.push(index);
}
function provableFromTuple(typs) {
  return {
    sizeInFields: () => {
      return typs.reduce((acc, typ) => acc + typ.sizeInFields(), 0);
    },
    toFields: (t) => {
      if (t.length !== typs.length) {
        throw new Error(`typOfArray: Expected ${typs.length}, got ${t.length}`);
      }
      let res = [];
      for (let i2 = 0; i2 < t.length; ++i2) {
        res.push(...typs[i2].toFields(t[i2]));
      }
      return res;
    },
    toAuxiliary() {
      return [];
    },
    fromFields: (xs) => {
      let offset = 0;
      let res = [];
      typs.forEach((typ) => {
        const n = typ.sizeInFields();
        res.push(typ.fromFields(xs.slice(offset, offset + n)));
        offset += n;
      });
      return res;
    },
    check(xs) {
      typs.forEach((typ, i2) => typ.check(xs[i2]));
    }
  };
}
function circuitMain(target, propertyName, _descriptor) {
  const paramTypes = Reflect.getMetadata("design:paramtypes", target, propertyName);
  const numArgs = paramTypes.length;
  const publicIndexSet = new Set(target._public);
  const witnessIndexSet = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < numArgs; ++i2) {
    if (!publicIndexSet.has(i2)) {
      witnessIndexSet.add(i2);
    }
  }
  target.snarkyMain = (w, pub) => {
    let [, result] = snarkContext.runWith({ inCheckedComputation: true }, () => {
      let args = [];
      for (let i2 = 0; i2 < numArgs; ++i2) {
        args.push((publicIndexSet.has(i2) ? pub : w).shift());
      }
      return target[propertyName].apply(target, args);
    });
    return result;
  };
  target.snarkyWitnessTyp = provableFromTuple(Array.from(witnessIndexSet).map((i2) => paramTypes[i2]));
  target.snarkyPublicTyp = provableFromTuple(Array.from(publicIndexSet).map((i2) => paramTypes[i2]));
}
var primitives = /* @__PURE__ */ new Set(["Field", "Bool", "Scalar", "Group"]);
var complexTypes = /* @__PURE__ */ new Set(["object", "function"]);
function provable2(typeObj, options) {
  let objectKeys = typeof typeObj === "object" && typeObj !== null ? options?.customObjectKeys ?? Object.keys(typeObj).sort() : [];
  let nonCircuitPrimitives = /* @__PURE__ */ new Set([
    Number,
    String,
    Boolean,
    BigInt,
    null,
    void 0
  ]);
  if (!nonCircuitPrimitives.has(typeObj) && !complexTypes.has(typeof typeObj)) {
    throw Error(`provable: unsupported type "${typeObj}"`);
  }
  function sizeInFields(typeObj2) {
    if (nonCircuitPrimitives.has(typeObj2))
      return 0;
    if (Array.isArray(typeObj2))
      return typeObj2.map(sizeInFields).reduce((a, b2) => a + b2, 0);
    if ("sizeInFields" in typeObj2)
      return typeObj2.sizeInFields();
    return Object.values(typeObj2).map(sizeInFields).reduce((a, b2) => a + b2, 0);
  }
  function toFields(typeObj2, obj, isToplevel = false) {
    if (nonCircuitPrimitives.has(typeObj2))
      return [];
    if (!complexTypes.has(typeof typeObj2) || typeObj2 === null)
      return [];
    if (Array.isArray(typeObj2))
      return typeObj2.map((t, i2) => toFields(t, obj[i2])).flat();
    if ("toFields" in typeObj2)
      return typeObj2.toFields(obj);
    return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => toFields(typeObj2[k], obj[k])).flat();
  }
  function toAuxiliary(typeObj2, obj, isToplevel = false) {
    if (typeObj2 === Number)
      return [obj ?? 0];
    if (typeObj2 === String)
      return [obj ?? ""];
    if (typeObj2 === Boolean)
      return [obj ?? false];
    if (typeObj2 === BigInt)
      return [obj ?? 0n];
    if (typeObj2 === void 0 || typeObj2 === null)
      return [];
    if (Array.isArray(typeObj2))
      return typeObj2.map((t, i2) => toAuxiliary(t, obj?.[i2]));
    if ("toAuxiliary" in typeObj2)
      return typeObj2.toAuxiliary(obj);
    return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => toAuxiliary(typeObj2[k], obj?.[k]));
  }
  function toInput(typeObj2, obj, isToplevel = false) {
    if (nonCircuitPrimitives.has(typeObj2))
      return {};
    if (Array.isArray(typeObj2)) {
      return typeObj2.map((t, i2) => toInput(t, obj[i2])).reduce(HashInput.append, HashInput.empty);
    }
    if ("toInput" in typeObj2)
      return typeObj2.toInput(obj);
    if ("toFields" in typeObj2) {
      return { fields: typeObj2.toFields(obj) };
    }
    return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => toInput(typeObj2[k], obj[k])).reduce(HashInput.append, HashInput.empty);
  }
  function toJSON(typeObj2, obj, isToplevel = false) {
    if (typeObj2 === BigInt)
      return obj.toString();
    if (typeObj2 === String || typeObj2 === Number || typeObj2 === Boolean)
      return obj;
    if (typeObj2 === void 0 || typeObj2 === null)
      return null;
    if (!complexTypes.has(typeof typeObj2) || typeObj2 === null)
      return obj ?? null;
    if (Array.isArray(typeObj2))
      return typeObj2.map((t, i2) => toJSON(t, obj[i2]));
    if ("toJSON" in typeObj2)
      return typeObj2.toJSON(obj);
    return Object.fromEntries((isToplevel ? objectKeys : Object.keys(typeObj2).sort()).map((k) => [
      k,
      toJSON(typeObj2[k], obj[k])
    ]));
  }
  function fromFields(typeObj2, fields, aux = [], isToplevel = false) {
    if (typeObj2 === Number || typeObj2 === String || typeObj2 === Boolean || typeObj2 === BigInt)
      return aux[0];
    if (typeObj2 === void 0 || typeObj2 === null)
      return typeObj2;
    if (!complexTypes.has(typeof typeObj2) || typeObj2 === null)
      return null;
    if (Array.isArray(typeObj2)) {
      let array = [];
      let i2 = 0;
      let offset = 0;
      for (let subObj of typeObj2) {
        let size = sizeInFields(subObj);
        array.push(fromFields(subObj, fields.slice(offset, offset + size), aux[i2]));
        offset += size;
        i2++;
      }
      return array;
    }
    if ("fromFields" in typeObj2)
      return typeObj2.fromFields(fields, aux);
    let keys = isToplevel ? objectKeys : Object.keys(typeObj2).sort();
    let values = fromFields(keys.map((k) => typeObj2[k]), fields, aux);
    return Object.fromEntries(keys.map((k, i2) => [k, values[i2]]));
  }
  function fromJSON(typeObj2, json, isToplevel = false) {
    if (typeObj2 === BigInt)
      return BigInt(json);
    if (typeObj2 === String || typeObj2 === Number || typeObj2 === Boolean)
      return json;
    if (typeObj2 === null)
      return void 0;
    if (!complexTypes.has(typeof typeObj2))
      return json ?? void 0;
    if (Array.isArray(typeObj2))
      return typeObj2.map((t, i2) => fromJSON(t, json[i2]));
    if ("fromJSON" in typeObj2)
      return typeObj2.fromJSON(json);
    let keys = isToplevel ? objectKeys : Object.keys(typeObj2).sort();
    let values = fromJSON(keys.map((k) => typeObj2[k]), keys.map((k) => json[k]));
    return Object.fromEntries(keys.map((k, i2) => [k, values[i2]]));
  }
  function check(typeObj2, obj, isToplevel = false) {
    if (nonCircuitPrimitives.has(typeObj2))
      return;
    if (Array.isArray(typeObj2))
      return typeObj2.forEach((t, i2) => check(t, obj[i2]));
    if ("check" in typeObj2)
      return typeObj2.check(obj);
    return (isToplevel ? objectKeys : Object.keys(typeObj2).sort()).forEach((k) => check(typeObj2[k], obj[k]));
  }
  if (options?.isPure === true) {
    return {
      sizeInFields: () => sizeInFields(typeObj),
      toFields: (obj) => toFields(typeObj, obj, true),
      toAuxiliary: () => [],
      fromFields: (fields) => fromFields(typeObj, fields, [], true),
      toInput: (obj) => toInput(typeObj, obj, true),
      toJSON: (obj) => toJSON(typeObj, obj, true),
      fromJSON: (json) => fromJSON(typeObj, json, true),
      check: (obj) => check(typeObj, obj, true)
    };
  }
  return {
    sizeInFields: () => sizeInFields(typeObj),
    toFields: (obj) => toFields(typeObj, obj, true),
    toAuxiliary: (obj) => toAuxiliary(typeObj, obj, true),
    fromFields: (fields, aux) => fromFields(typeObj, fields, aux, true),
    toInput: (obj) => toInput(typeObj, obj, true),
    toJSON: (obj) => toJSON(typeObj, obj, true),
    fromJSON: (json) => fromJSON(typeObj, json, true),
    check: (obj) => check(typeObj, obj, true)
  };
}
function provablePure(typeObj, options = {}) {
  return provable2(typeObj, { ...options, isPure: true });
}
function Struct(type, options = {}) {
  class Struct_ {
    constructor(value) {
      Object.assign(this, value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * @returns the size of this struct in field elements
     */
    static sizeInFields() {
      return this.type.sizeInFields();
    }
    /**
     * This method is for internal use, you will probably not need it.
     * @param value
     * @returns the raw list of field elements that represent this struct inside the proof
     */
    static toFields(value) {
      return this.type.toFields(value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * @param value
     * @returns the raw non-field element data contained in the struct
     */
    static toAuxiliary(value) {
      return this.type.toAuxiliary(value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * @param value
     * @returns a representation of this struct as field elements, which can be hashed efficiently
     */
    static toInput(value) {
      return this.type.toInput(value);
    }
    /**
     * Convert this struct to a JSON object, consisting only of numbers, strings, booleans, arrays and plain objects.
     * @param value
     * @returns a JSON representation of this struct
     */
    static toJSON(value) {
      return this.type.toJSON(value);
    }
    /**
     * Convert from a JSON object to an instance of this struct.
     * @param json
     * @returns a JSON representation of this struct
     */
    static fromJSON(json) {
      let value = this.type.fromJSON(json);
      let struct = Object.create(this.prototype);
      return Object.assign(struct, value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * Method to make assertions which should be always made whenever a struct of this type is created in a proof.
     * @param value
     */
    static check(value) {
      return this.type.check(value);
    }
    /**
     * This method is for internal use, you will probably not need it.
     * Recover a struct from its raw field elements and auxiliary data.
     * @param fields the raw fields elements
     * @param aux the raw non-field element data
     */
    static fromFields(fields, aux) {
      let value = this.type.fromFields(fields, aux);
      let struct = Object.create(this.prototype);
      return Object.assign(struct, value);
    }
  }
  Struct_.type = provable2(type, options);
  return Struct_;
}
function cloneCircuitValue(obj) {
  if (typeof obj !== "object" || obj === null)
    return obj;
  if (["GenericArgument", "Callback"].includes(obj.constructor?.name)) {
    return obj;
  }
  if (Array.isArray(obj))
    return obj.map(cloneCircuitValue);
  if (obj instanceof Set)
    return new Set([...obj].map(cloneCircuitValue));
  if (obj instanceof Map)
    return new Map([...obj].map(([k, v]) => [k, cloneCircuitValue(v)]));
  if (ArrayBuffer.isView(obj))
    return new obj.constructor(obj);
  if (primitives.has(obj.constructor.name))
    return obj;
  let propertyDescriptors = {};
  for (let [key, value] of Object.entries(obj)) {
    propertyDescriptors[key] = {
      value: cloneCircuitValue(value),
      writable: true,
      enumerable: true,
      configurable: true
    };
  }
  return Object.create(Object.getPrototypeOf(obj), propertyDescriptors);
}
function circuitValueEquals(a, b2) {
  if (typeof a !== "object" || a === null || typeof b2 !== "object" || b2 === null)
    return a === b2;
  if (Array.isArray(a)) {
    return Array.isArray(b2) && a.length === b2.length && a.every((a_, i2) => circuitValueEquals(a_, b2[i2]));
  }
  if (a instanceof Set) {
    return b2 instanceof Set && a.size === b2.size && [...a].every((a_) => b2.has(a_));
  }
  if (a instanceof Map) {
    return b2 instanceof Map && a.size === b2.size && [...a].every(([k, v]) => circuitValueEquals(v, b2.get(k)));
  }
  if (ArrayBuffer.isView(a) && !(a instanceof DataView)) {
    return ArrayBuffer.isView(b2) && !(b2 instanceof DataView) && circuitValueEquals([...a], [...b2]);
  }
  if ("equals" in a && typeof a.equals === "function") {
    let isEqual = a.equals(b2).toBoolean();
    if (typeof isEqual === "boolean")
      return isEqual;
    if (isEqual instanceof Bool)
      return isEqual.toBoolean();
  }
  if ("toFields" in a && typeof a.toFields === "function" && "toFields" in b2 && typeof b2.toFields === "function") {
    let aFields = a.toFields();
    let bFields = b2.toFields();
    return aFields.every((a2, i2) => a2.equals(bFields[i2]).toBoolean());
  }
  let aEntries = Object.entries(a).filter(([, v]) => v !== void 0);
  let bEntries = Object.entries(b2).filter(([, v]) => v !== void 0);
  if (aEntries.length !== bEntries.length)
    return false;
  return aEntries.every(([key, value]) => key in b2 && circuitValueEquals(b2[key], value));
}
function toConstant(type, value) {
  return type.fromFields(type.toFields(value).map((x) => x.toConstant()), type.toAuxiliary(value));
}
Circuit.inCheckedComputation = inCheckedComputation;
var oldAsProver = Circuit.asProver;
Circuit.asProver = function(f) {
  if (inCheckedComputation()) {
    oldAsProver(f);
  } else {
    f();
  }
};
var oldRunUnchecked = Circuit.runUnchecked;
Circuit.runUnchecked = function(f) {
  let [, result] = snarkContext.runWith({ inCheckedComputation: true }, () => oldRunUnchecked(f));
  return result;
};
var oldRunAndCheck = Circuit.runAndCheck;
Circuit.runAndCheck = function(f) {
  let [, result] = snarkContext.runWith({ inCheckedComputation: true }, () => oldRunAndCheck(f));
  return result;
};
Circuit.witness = function(type, compute) {
  let proverValue;
  let createFields = () => {
    proverValue = compute();
    let fields2 = type.toFields(proverValue);
    return fields2;
  };
  let ctx = snarkContext.get();
  let fields = inCheckedComputation() && !ctx.inWitnessBlock ? snarkContext.runWith({ ...ctx, inWitnessBlock: true }, () => Circuit._witness(type, createFields))[1] : createFields();
  let aux = type.toAuxiliary(proverValue);
  let value = type.fromFields(fields, aux);
  if (inCheckedComputation())
    type.check(value);
  return value;
};
Circuit.array = circuitArray;
Circuit.switch = function(mask, type, values) {
  let nValues = values.length;
  if (mask.length !== nValues)
    throw Error(`Circuit.switch: \`values\` and \`mask\` have different lengths (${values.length} vs. ${mask.length}), which is not allowed.`);
  let checkMask = () => {
    let nTrue = mask.filter((b2) => b2.toBoolean()).length;
    if (nTrue > 1) {
      throw Error(`Circuit.switch: \`mask\` must have 0 or 1 true element, found ${nTrue}.`);
    }
  };
  if (mask.every((b2) => b2.toField().isConstant()))
    checkMask();
  else
    Circuit.asProver(checkMask);
  let size = type.sizeInFields();
  let fields = Array(size).fill(Field(0));
  for (let i2 = 0; i2 < nValues; i2++) {
    let valueFields = type.toFields(values[i2]);
    let maskField = mask[i2].toField();
    for (let j = 0; j < size; j++) {
      let maybeField = valueFields[j].mul(maskField);
      fields[j] = fields[j].add(maybeField);
    }
  }
  let aux = auxiliary(type, () => {
    let i2 = mask.findIndex((b2) => b2.toBoolean());
    if (i2 === -1)
      return type.toAuxiliary();
    return type.toAuxiliary(values[i2]);
  });
  return type.fromFields(fields, aux);
};
Circuit.constraintSystem = function(f) {
  let [, result] = snarkContext.runWith({ inAnalyze: true, inCheckedComputation: true }, () => {
    let result2;
    let { rows, digest, json } = Circuit._constraintSystem(() => {
      result2 = f();
    });
    let { gates, publicInputSize } = gatesFromJson(json);
    return { rows, digest, result: result2, gates, publicInputSize };
  });
  return result;
};
Circuit.log = function(...args) {
  Circuit.asProver(() => {
    let prettyArgs = [];
    for (let arg of args) {
      if (arg?.toPretty !== void 0)
        prettyArgs.push(arg.toPretty());
      else {
        try {
          prettyArgs.push(JSON.parse(JSON.stringify(arg)));
        } catch {
          prettyArgs.push(arg);
        }
      }
    }
    console.log(...prettyArgs);
  });
};
Circuit.constraintSystemFromKeypair = function(keypair) {
  return gatesFromJson(JSON.parse(keypair._constraintSystemJSON())).gates;
};
function gatesFromJson(cs) {
  let gates = cs.gates.map(({ typ, wires, coeffs: byteCoeffs }) => {
    let coeffs = [];
    for (let coefficient of byteCoeffs) {
      let arr = new Uint8Array(coefficient);
      coeffs.push(bytesToBigInt(arr).toString());
    }
    return { type: typ, wires, coeffs };
  });
  return { publicInputSize: cs.public_input_size, gates };
}
function auxiliary(type, compute) {
  let aux;
  if (inCheckedComputation())
    Circuit.asProver(() => aux = compute());
  else
    aux = compute();
  return aux ?? type.toAuxiliary();
}
var memoizationContext = Context.create();
function memoizeWitness(type, compute) {
  return Circuit.witness(type, () => {
    if (!memoizationContext.has())
      return compute();
    let context = memoizationContext.get();
    let { memoized, currentIndex } = context;
    let currentValue = memoized[currentIndex];
    if (currentValue === void 0) {
      let value = compute();
      let fields = type.toFields(value).map((x) => x.toConstant());
      let aux = type.toAuxiliary(value);
      currentValue = { fields, aux };
      memoized[currentIndex] = currentValue;
    }
    context.currentIndex += 1;
    return type.fromFields(currentValue.fields, currentValue.aux);
  });
}
function getBlindingValue() {
  if (!memoizationContext.has())
    return Field.random();
  let context = memoizationContext.get();
  if (context.blindingValue === void 0) {
    context.blindingValue = Field.random();
  }
  return context.blindingValue;
}

// dist/node/lib/hash-generic.js
function createHashHelpers(Field4, Hash3) {
  function salt2(prefix) {
    return Hash3.update(Hash3.initialState(), [prefixToField(Field4, prefix)]);
  }
  function emptyHashWithPrefix2(prefix) {
    return salt2(prefix)[0];
  }
  function hashWithPrefix3(prefix, input) {
    let init = salt2(prefix);
    return Hash3.update(init, input)[0];
  }
  return { salt: salt2, emptyHashWithPrefix: emptyHashWithPrefix2, hashWithPrefix: hashWithPrefix3 };
}

// dist/node/lib/hash.js
var Sponge = class {
  constructor() {
    let isChecked = inCheckedComputation();
    this.sponge = Poseidon.spongeCreate(isChecked);
  }
  absorb(x) {
    Poseidon.spongeAbsorb(this.sponge, x);
  }
  squeeze() {
    return Poseidon.spongeSqueeze(this.sponge);
  }
};
var Poseidon2 = {
  hash(input) {
    let isChecked = !input.every((x) => x.isConstant());
    return Poseidon.hash(input, isChecked);
  },
  update(state2, input) {
    let isChecked = !(state2.every((x) => x.isConstant()) && input.every((x) => x.isConstant()));
    return Poseidon.update(state2, input, isChecked);
  },
  initialState() {
    return [Field(0), Field(0), Field(0)];
  },
  Sponge
};
var Hash = createHashHelpers(Field, Poseidon2);
var { salt, emptyHashWithPrefix, hashWithPrefix } = Hash;
var prefixes2 = new Proxy({}, {
  // hack bc Poseidon_.prefixes is not available at start-up
  get(_target, prop2) {
    return Poseidon.prefixes[prop2];
  }
});
function prefixToField2(prefix) {
  if (prefix.length * 8 >= 255)
    throw Error("prefix too long");
  let bits2 = [...prefix].map((char) => {
    let bits3 = [];
    for (let j = 0, c = char.charCodeAt(0); j < 8; j++, c >>= 1) {
      bits3.push(!!(c & 1));
    }
    return bits3;
  }).flat();
  return Field.fromBits(bits2);
}
function packToFields({ fields = [], packed = [] }) {
  if (packed.length === 0)
    return fields;
  let packedBits = [];
  let currentPackedField = Field(0);
  let currentSize = 0;
  for (let [field, size] of packed) {
    currentSize += size;
    if (currentSize < 255) {
      currentPackedField = currentPackedField.mul(Field(1n << BigInt(size))).add(field);
    } else {
      packedBits.push(currentPackedField);
      currentSize = size;
      currentPackedField = field;
    }
  }
  packedBits.push(currentPackedField);
  return fields.concat(packedBits);
}
var TokenSymbolPure = {
  toFields({ field }) {
    return [field];
  },
  toAuxiliary(value) {
    return [value?.symbol ?? ""];
  },
  fromFields([field], [symbol]) {
    return { symbol, field };
  },
  sizeInFields() {
    return 1;
  },
  check({ field }) {
    let actual = field.rangeCheckHelper(48);
    actual.assertEquals(field);
  },
  toJSON({ symbol }) {
    return symbol;
  },
  fromJSON(symbol) {
    let field = prefixToField2(symbol);
    return { symbol, field };
  },
  toInput({ field }) {
    return { packed: [[field, 48]] };
  }
};
var TokenSymbol = class extends Struct(TokenSymbolPure) {
  static get empty() {
    return { symbol: "", field: Field(0) };
  }
  static from(symbol) {
    let bytesLength = new TextEncoder().encode(symbol).length;
    if (bytesLength > 6)
      throw Error(`Token symbol ${symbol} should be a maximum of 6 bytes, but is ${bytesLength}`);
    let field = prefixToField2(symbol);
    return { symbol, field };
  }
};
function emptyReceiptChainHash() {
  return emptyHashWithPrefix("CodaReceiptEmpty");
}

// dist/node/lib/signature.js
var import_tslib = require("tslib");

// dist/node/mina-signer/src/signature.js
var import_blakejs = require("blakejs");

// dist/node/js_crypto/poseidon.js
var Poseidon3 = createPoseidon(Fp, poseidonParamsKimchiFp);
var PoseidonLegacy = createPoseidon(Fp, poseidonParamsLegacyFp);
function createPoseidon(Fp2, { fullRounds, partialRounds, hasInitialRoundConstant, stateSize, rate, power: power_, roundConstants: roundConstants_, mds: mds_ }) {
  if (partialRounds !== 0) {
    throw Error("we don't support partial rounds");
  }
  assertPositiveInteger(rate, "rate must be a positive integer");
  assertPositiveInteger(fullRounds, "fullRounds must be a positive integer");
  assertPositiveInteger(power_, "power must be a positive integer");
  let power2 = BigInt(power_);
  let roundConstants = roundConstants_.map((arr) => arr.map(BigInt));
  let mds = mds_.map((arr) => arr.map(BigInt));
  function initialState() {
    return Array(stateSize).fill(0n);
  }
  function hash2(input) {
    let state2 = update(initialState(), input);
    return state2[0];
  }
  function update([...state2], input) {
    if (input.length === 0) {
      permutation(state2);
      return state2;
    }
    let n = Math.ceil(input.length / rate) * rate;
    input = input.concat(Array(n - input.length).fill(0n));
    for (let blockIndex = 0; blockIndex < n; blockIndex += rate) {
      for (let i2 = 0; i2 < rate; i2++) {
        state2[i2] = Fp2.add(state2[i2], input[blockIndex + i2]);
      }
      permutation(state2);
    }
    return state2;
  }
  function permutation(state2) {
    let offset = 0;
    if (hasInitialRoundConstant) {
      for (let i2 = 0; i2 < stateSize; i2++) {
        state2[i2] = Fp2.add(state2[i2], roundConstants[0][i2]);
      }
      offset = 1;
    }
    for (let round = 0; round < fullRounds; round++) {
      for (let i2 = 0; i2 < stateSize; i2++) {
        state2[i2] = Fp2.power(state2[i2], power2);
      }
      let oldState = [...state2];
      for (let i2 = 0; i2 < stateSize; i2++) {
        state2[i2] = Fp2.dot(mds[i2], oldState);
        state2[i2] = Fp2.add(state2[i2], roundConstants[round + offset][i2]);
      }
    }
  }
  return { initialState, update, hash: hash2 };
}

// dist/node/provable/poseidon-bigint.js
var HashInput2 = createHashInput();
var Hash2 = createHashHelpers(Field2, Poseidon3);
var { hashWithPrefix: hashWithPrefix2 } = Hash2;
var HashLegacy = createHashHelpers(Field2, PoseidonLegacy);
function packToFields2({ fields = [], packed = [] }) {
  if (packed.length === 0)
    return fields;
  let packedBits = [];
  let currentPackedField = 0n;
  let currentSize = 0;
  for (let [field, size] of packed) {
    currentSize += size;
    if (currentSize < 255) {
      currentPackedField = currentPackedField * (1n << BigInt(size)) + field;
    } else {
      packedBits.push(currentPackedField);
      currentSize = size;
      currentPackedField = field;
    }
  }
  packedBits.push(currentPackedField);
  return fields.concat(packedBits);
}
function packToFieldsLegacy({ fields, bits: bits2 }) {
  let packedFields = [];
  while (bits2.length > 0) {
    let fieldBits = bits2.splice(0, sizeInBits - 1);
    let field = Field2.fromBits(fieldBits);
    packedFields.push(field);
  }
  return fields.concat(packedFields);
}
var HashInputLegacy = {
  empty() {
    return { fields: [], bits: [] };
  },
  bits(bits2) {
    return { fields: [], bits: bits2 };
  },
  append(input1, input2) {
    return {
      fields: (input1.fields ?? []).concat(input2.fields ?? []),
      bits: (input1.bits ?? []).concat(input2.bits ?? [])
    };
  }
};

// dist/node/mina-signer/src/signature.js
var networkIdMainnet = 0x01n;
var networkIdTestnet = 0x00n;
var BinableSignature = withVersionNumber(record({ r: Field2, s: Scalar2 }, ["r", "s"]), versionNumbers.signature);
var Signature = {
  ...BinableSignature,
  ...base58(BinableSignature, versionBytes.signature),
  toJSON({ r, s }) {
    return {
      field: Field2.toJSON(r),
      scalar: Scalar2.toJSON(s)
    };
  },
  fromJSON({ field, scalar }) {
    let r = Field2.fromJSON(field);
    let s = Scalar2.fromJSON(scalar);
    return { r, s };
  },
  dummy() {
    return { r: Field2(0), s: Scalar2(0) };
  }
};
function deriveNonce(message, publicKey, privateKey, networkId) {
  let { x, y } = publicKey;
  let d = Field2(privateKey);
  let id = networkId === "mainnet" ? networkIdMainnet : networkIdTestnet;
  let input = HashInput2.append(message, {
    fields: [x, y, d],
    packed: [[id, 8]]
  });
  let packedInput = packToFields2(input);
  let inputBits = packedInput.map(Field2.toBits).flat();
  let inputBytes = bitsToBytes(inputBits);
  let bytes = (0, import_blakejs.blake2b)(Uint8Array.from(inputBytes), void 0, 32);
  bytes[bytes.length - 1] &= 63;
  return Scalar2.fromBytes([...bytes]);
}

// dist/node/lib/signature.js
var PrivateKey2 = class extends CircuitValue {
  /**
   * You can use this method to generate a private key. You can then obtain
   * the associated public key via {@link toPublicKey}. And generate signatures
   * via {@link Signature.create}.
   *
   * @returns a new {@link PrivateKey}.
   */
  static random() {
    return new PrivateKey2(Scalar.random());
  }
  /**
   * Deserializes a list of bits into a {@link PrivateKey}.
   *
   * @param bs a list of {@link Bool}.
   * @returns a {@link PrivateKey}.
   */
  static fromBits(bs) {
    return new PrivateKey2(Scalar.fromBits(bs));
  }
  /**
   * Derives the associated public key.
   *
   * @returns a {@link PublicKey}.
   */
  toPublicKey() {
    return PublicKey2.fromPrivateKey(this);
  }
  /**
   * Decodes a base58 string into a {@link PrivateKey}.
   *
   * @returns a {@link PrivateKey}.
   */
  static fromBase58(privateKeyBase58) {
    let scalar = Ledger.privateKeyOfString(privateKeyBase58);
    return new PrivateKey2(scalar);
  }
  /**
   * Encodes a {@link PrivateKey} into a base58 string.
   * @returns a base58 encoded string
   */
  toBase58() {
    return PrivateKey2.toBase58(this);
  }
  // static version, to operate on non-class versions of this type
  /**
   * Static method to encode a {@link PrivateKey} into a base58 string.
   * @returns a base58 encoded string
   */
  static toBase58(privateKey) {
    return Ledger.privateKeyToString(privateKey);
  }
};
(0, import_tslib.__decorate)([
  prop,
  (0, import_tslib.__metadata)("design:type", Scalar)
], PrivateKey2.prototype, "s", void 0);
var PublicKey2 = class extends CircuitValue {
  /**
   * Returns the {@link Group} representation of this {@link PublicKey}.
   * @returns A {@link Group}
   */
  toGroup() {
    let { x, isOdd } = this;
    let ySquared = x.mul(x).mul(x).add(5);
    let someY = ySquared.sqrt();
    let isTheRightY = isOdd.equals(someY.toBits()[0]);
    let y = isTheRightY.toField().mul(someY).add(isTheRightY.not().toField().mul(someY.neg()));
    return new Group(x, y);
  }
  /**
   * Creates a {@link PublicKey} from a {@link Group} element.
   * @returns a {@link PublicKey}.
   */
  static fromGroup({ x, y }) {
    let isOdd = y.toBits()[0];
    return PublicKey2.fromObject({ x, isOdd });
  }
  /**
   * Derives a {@link PublicKey} from a {@link PrivateKey}.
   * @returns a {@link PublicKey}.
   */
  static fromPrivateKey({ s }) {
    return PublicKey2.fromGroup(Group.generator.scale(s));
  }
  /**
   * Creates a {@link PublicKey} from a JSON structure element.
   * @returns a {@link PublicKey}.
   */
  static from(g) {
    return PublicKey2.fromObject(g);
  }
  /**
   * Creates an empty {@link PublicKey}.
   * @returns an empty {@link PublicKey}
   */
  static empty() {
    return PublicKey2.from({ x: Field(0), isOdd: Bool(false) });
  }
  /**
   * Checks if a {@link PublicKey} is empty.
   * @returns a {@link Bool}
   */
  isEmpty() {
    return this.x.isZero();
  }
  /**
   * Decodes a base58 encoded {@link PublicKey} into a {@link PublicKey}.
   * @returns a {@link PublicKey}
   */
  static fromBase58(publicKeyBase58) {
    let pk = Ledger.publicKeyOfString(publicKeyBase58);
    return PublicKey2.from(pk);
  }
  /**
   * Encodes a {@link PublicKey} in base58 format.
   * @returns a base58 encoded {@link PublicKey}
   */
  toBase58() {
    return PublicKey2.toBase58(this);
  }
  // static version, to operate on non-class versions of this type
  /**
   * Static method to encode a {@link PublicKey} into base58 format.
   * @returns a base58 encoded {@link PublicKey}
   */
  static toBase58(publicKey) {
    return Ledger.publicKeyToString(publicKey);
  }
  /**
   * Serializes a {@link PublicKey} into its JSON representation.
   * @returns a JSON string
   */
  static toJSON(publicKey) {
    return publicKey.toBase58();
  }
  /**
   * Deserializes a JSON string into a {@link PublicKey}.
   * @returns a JSON string
   */
  static fromJSON(publicKey) {
    return PublicKey2.fromBase58(publicKey);
  }
};
(0, import_tslib.__decorate)([
  prop,
  (0, import_tslib.__metadata)("design:type", Field)
], PublicKey2.prototype, "x", void 0);
(0, import_tslib.__decorate)([
  prop,
  (0, import_tslib.__metadata)("design:type", Bool)
], PublicKey2.prototype, "isOdd", void 0);
var Signature2 = class extends CircuitValue {
  /**
   * Signs a message using a {@link PrivateKey}.
   * @returns a {@link Signature}
   */
  static create(privKey, msg) {
    const publicKey = PublicKey2.fromPrivateKey(privKey).toGroup();
    const d = privKey.s;
    const kPrime = Scalar.fromBigInt(deriveNonce({ fields: msg.map((f) => f.toBigInt()) }, { x: publicKey.x.toBigInt(), y: publicKey.y.toBigInt() }, BigInt(d.toJSON()), "testnet"));
    let { x: r, y: ry } = Group.generator.scale(kPrime);
    const k = ry.toBits()[0].toBoolean() ? kPrime.neg() : kPrime;
    let h = hashWithPrefix(prefixes.signatureTestnet, msg.concat([publicKey.x, publicKey.y, r]));
    let e = unshift(Scalar.fromBits(h.toBits()));
    const s = e.mul(d).add(k);
    return new Signature2(r, s);
  }
  /**
   * Verifies the {@link Signature} using a message and the corresponding {@link PublicKey}.
   * @returns a {@link Bool}
   */
  verify(publicKey, msg) {
    const point = publicKey.toGroup();
    let h = hashWithPrefix(prefixes.signatureTestnet, msg.concat([point.x, point.y, this.r]));
    let e = Scalar.fromBits(h.toBits());
    let r = scaleShifted(point, e).neg().add(Group.generator.scale(this.s));
    return Bool.and(r.x.equals(this.r), r.y.toBits()[0].equals(false));
  }
  /**
   * Decodes a base58 encoded signature into a {@link Signature}.
   */
  static fromBase58(signatureBase58) {
    let { r, s } = Signature.fromBase58(signatureBase58);
    return Signature2.fromObject({
      r: Field(r),
      s: Scalar.fromJSON(s.toString())
    });
  }
  /**
   * Encodes a {@link Signature} in base58 format.
   */
  toBase58() {
    let r = this.r.toBigInt();
    let s = BigInt(this.s.toJSON());
    return Signature.toBase58({ r, s });
  }
};
(0, import_tslib.__decorate)([
  prop,
  (0, import_tslib.__metadata)("design:type", Field)
], Signature2.prototype, "r", void 0);
(0, import_tslib.__decorate)([
  prop,
  (0, import_tslib.__metadata)("design:type", Scalar)
], Signature2.prototype, "s", void 0);
function scaleShifted(point, shiftedScalar) {
  let oneHalfGroup = point.scale(Scalar.fromBigInt(oneHalf));
  let shiftGroup = oneHalfGroup.scale(Scalar.fromBigInt(shift));
  return oneHalfGroup.scale(shiftedScalar).sub(shiftGroup);
}
function unshift(shiftedScalar) {
  return shiftedScalar.sub(Scalar.fromBigInt(shift)).mul(Scalar.fromBigInt(oneHalf));
}
var shift = Scalar2(1n + 2n ** 255n);
var oneHalf = Scalar2.inverse(2n);

// dist/node/lib/int.js
var import_tslib2 = require("tslib");
var UInt642 = class extends CircuitValue {
  /**
   * Static method to create a {@link UInt64} with value `0`.
   */
  static get zero() {
    return new UInt642(Field(0));
  }
  /**
   * Static method to create a {@link UInt64} with value `1`.
   */
  static get one() {
    return new UInt642(Field(1));
  }
  /**
   * Turns the {@link UInt64} into a string.
   * @returns
   */
  toString() {
    return this.value.toString();
  }
  /**
   * Turns the {@link UInt64} into a {@link BigInt}.
   * @returns
   */
  toBigInt() {
    return this.value.toBigInt();
  }
  /**
   * Turns the {@link UInt64} into a {@link UInt32}, asserting that it fits in 32 bits.
   */
  toUInt32() {
    let uint322 = new UInt322(this.value);
    UInt322.check(uint322);
    return uint322;
  }
  /**
   * Turns the {@link UInt64} into a {@link UInt32}, clamping to the 32 bits range if it's too large.
   * ```ts
   * UInt64.from(4294967296).toUInt32Clamped().toString(); // "4294967295"
   * ```
   */
  toUInt32Clamped() {
    let max = (1n << 32n) - 1n;
    return Circuit.if(this.greaterThan(UInt642.from(max)), UInt322.from(max), new UInt322(this.value));
  }
  static check(x) {
    let actual = x.value.rangeCheckHelper(64);
    actual.assertEquals(x.value);
  }
  static toInput(x) {
    return { packed: [[x.value, 64]] };
  }
  /**
   * Encodes this structure into a JSON-like object.
   */
  static toJSON(x) {
    return x.value.toString();
  }
  /**
   * Decodes a JSON-like object into this structure.
   */
  static fromJSON(x) {
    return this.from(x);
  }
  static checkConstant(x) {
    if (!x.isConstant())
      return x;
    let xBig = x.toBigInt();
    if (xBig < 0n || xBig >= 1n << BigInt(this.NUM_BITS)) {
      throw Error(`UInt64: Expected number between 0 and 2^64 - 1, got ${xBig}`);
    }
    return x;
  }
  // this checks the range if the argument is a constant
  /**
   * Creates a new {@link UInt64}.
   */
  static from(x) {
    if (x instanceof UInt642 || x instanceof UInt322)
      x = x.value;
    return new this(this.checkConstant(Field(x)));
  }
  /**
   * Creates a {@link UInt64} with a value of 18,446,744,073,709,551,615.
   */
  static MAXINT() {
    return new UInt642(Field((1n << 64n) - 1n));
  }
  /**
   * Integer division with remainder.
   *
   * `x.divMod(y)` returns the quotient and the remainder.
   */
  divMod(y) {
    let x = this.value;
    let y_ = UInt642.from(y).value;
    if (this.value.isConstant() && y_.isConstant()) {
      let xn = x.toBigInt();
      let yn = y_.toBigInt();
      let q4 = xn / yn;
      let r2 = xn - q4 * yn;
      return {
        quotient: new UInt642(Field(q4)),
        rest: new UInt642(Field(r2))
      };
    }
    y_ = y_.seal();
    let q3 = Circuit.witness(Field, () => new Field(x.toBigInt() / y_.toBigInt()));
    q3.rangeCheckHelper(UInt642.NUM_BITS).assertEquals(q3);
    let r = x.sub(q3.mul(y_)).seal();
    r.rangeCheckHelper(UInt642.NUM_BITS).assertEquals(r);
    let r_ = new UInt642(r);
    let q_ = new UInt642(q3);
    r_.assertLessThan(new UInt642(y_));
    return { quotient: q_, rest: r_ };
  }
  /**
   * Integer division.
   *
   * `x.div(y)` returns the floor of `x / y`, that is, the greatest
   * `z` such that `z * y <= x`.
   *
   */
  div(y) {
    return this.divMod(y).quotient;
  }
  /**
   * Integer remainder.
   *
   * `x.mod(y)` returns the value `z` such that `0 <= z < y` and
   * `x - z` is divisble by `y`.
   */
  mod(y) {
    return this.divMod(y).rest;
  }
  /**
   * Multiplication with overflow checking.
   */
  mul(y) {
    let z = this.value.mul(UInt642.from(y).value);
    z.rangeCheckHelper(UInt642.NUM_BITS).assertEquals(z);
    return new UInt642(z);
  }
  /**
   * Addition with overflow checking.
   */
  add(y) {
    let z = this.value.add(UInt642.from(y).value);
    z.rangeCheckHelper(UInt642.NUM_BITS).assertEquals(z);
    return new UInt642(z);
  }
  /**
   * Subtraction with underflow checking.
   */
  sub(y) {
    let z = this.value.sub(UInt642.from(y).value);
    z.rangeCheckHelper(UInt642.NUM_BITS).assertEquals(z);
    return new UInt642(z);
  }
  /**
   * @deprecated Use {@link lessThanOrEqual} instead.
   *
   * Checks if a {@link UInt64} is less than or equal to another one.
   */
  lte(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool(this.value.toBigInt() <= y.value.toBigInt());
    } else {
      let xMinusY = this.value.sub(y.value).seal();
      let yMinusX = xMinusY.neg();
      let xMinusYFits = xMinusY.rangeCheckHelper(UInt642.NUM_BITS).equals(xMinusY);
      let yMinusXFits = yMinusX.rangeCheckHelper(UInt642.NUM_BITS).equals(yMinusX);
      xMinusYFits.or(yMinusXFits).assertEquals(true);
      return yMinusXFits;
    }
  }
  /**
   * Checks if a {@link UInt64} is less than or equal to another one.
   */
  lessThanOrEqual(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool(this.value.toBigInt() <= y.value.toBigInt());
    } else {
      let xMinusY = this.value.sub(y.value).seal();
      let yMinusX = xMinusY.neg();
      let xMinusYFits = xMinusY.rangeCheckHelper(UInt642.NUM_BITS).equals(xMinusY);
      let yMinusXFits = yMinusX.rangeCheckHelper(UInt642.NUM_BITS).equals(yMinusX);
      xMinusYFits.or(yMinusXFits).assertEquals(true);
      return yMinusXFits;
    }
  }
  /**
   * @deprecated Use {@link assertLessThanOrEqual} instead.
   *
   * Asserts that a {@link UInt64} is less than or equal to another one.
   */
  assertLte(y, message) {
    this.assertLessThanOrEqual(y, message);
  }
  /**
   * Asserts that a {@link UInt64} is less than or equal to another one.
   */
  assertLessThanOrEqual(y, message) {
    if (this.value.isConstant() && y.value.isConstant()) {
      let x0 = this.value.toBigInt();
      let y0 = y.value.toBigInt();
      if (x0 > y0) {
        if (message !== void 0)
          throw Error(message);
        throw Error(`UInt64.assertLessThanOrEqual: expected ${x0} <= ${y0}`);
      }
      return;
    }
    let yMinusX = y.value.sub(this.value).seal();
    yMinusX.rangeCheckHelper(UInt642.NUM_BITS).assertEquals(yMinusX, message);
  }
  /**
   * @deprecated Use {@link lessThan} instead.
   *
   * Checks if a {@link UInt64} is less than another one.
   */
  lt(y) {
    return this.lessThanOrEqual(y).and(this.value.equals(y.value).not());
  }
  /**
   *
   * Checks if a {@link UInt64} is less than another one.
   */
  lessThan(y) {
    return this.lessThanOrEqual(y).and(this.value.equals(y.value).not());
  }
  /**
   *
   * @deprecated Use {@link assertLessThan} instead.
   *
   * Asserts that a {@link UInt64} is less than another one.
   */
  assertLt(y, message) {
    this.lessThan(y).assertEquals(true, message);
  }
  /**
   * Asserts that a {@link UInt64} is less than another one.
   */
  assertLessThan(y, message) {
    this.lessThan(y).assertEquals(true, message);
  }
  /**
   * @deprecated Use {@link greaterThan} instead.
   *
   * Checks if a {@link UInt64} is greater than another one.
   */
  gt(y) {
    return y.lessThan(this);
  }
  /**
   * Checks if a {@link UInt64} is greater than another one.
   */
  greaterThan(y) {
    return y.lessThan(this);
  }
  /**
   * @deprecated Use {@link assertGreaterThan} instead.
   *
   * Asserts that a {@link UInt64} is greater than another one.
   */
  assertGt(y, message) {
    y.assertLessThan(this, message);
  }
  /**
   * Asserts that a {@link UInt64} is greater than another one.
   */
  assertGreaterThan(y, message) {
    y.assertLessThan(this, message);
  }
  /**
   * @deprecated Use {@link greaterThanOrEqual} instead.
   *
   * Checks if a {@link UInt64} is greater than or equal to another one.
   */
  gte(y) {
    return this.lessThan(y).not();
  }
  /**
   * Checks if a {@link UInt64} is greater than or equal to another one.
   */
  greaterThanOrEqual(y) {
    return this.lessThan(y).not();
  }
  /**
   * @deprecated Use {@link assertGreaterThanOrEqual} instead.
   *
   * Asserts that a {@link UInt64} is greater than or equal to another one.
   */
  assertGte(y, message) {
    y.assertLessThanOrEqual(this, message);
  }
  /**
   * Asserts that a {@link UInt64} is greater than or equal to another one.
   */
  assertGreaterThanOrEqual(y, message) {
    y.assertLessThanOrEqual(this, message);
  }
};
UInt642.NUM_BITS = 64;
(0, import_tslib2.__decorate)([
  prop,
  (0, import_tslib2.__metadata)("design:type", Field)
], UInt642.prototype, "value", void 0);
var UInt322 = class extends CircuitValue {
  /**
   * Static method to create a {@link UInt32} with value `0`.
   */
  static get zero() {
    return new UInt322(Field(0));
  }
  /**
   * Static method to create a {@link UInt32} with value `0`.
   */
  static get one() {
    return new UInt322(Field(1));
  }
  /**
   * Turns the {@link UInt32} into a string.
   */
  toString() {
    return this.value.toString();
  }
  /**
   * Turns the {@link UInt32} into a {@link BigInt}.
   */
  toBigint() {
    return this.value.toBigInt();
  }
  /**
   * Turns the {@link UInt32} into a {@link UInt64}.
   */
  toUInt64() {
    return new UInt642(this.value);
  }
  static check(x) {
    let actual = x.value.rangeCheckHelper(32);
    actual.assertEquals(x.value);
  }
  static toInput(x) {
    return { packed: [[x.value, 32]] };
  }
  /**
   * Encodes this structure into a JSON-like object.
   */
  static toJSON(x) {
    return x.value.toString();
  }
  /**
   * Decodes a JSON-like object into this structure.
   */
  static fromJSON(x) {
    return this.from(x);
  }
  static checkConstant(x) {
    if (!x.isConstant())
      return x;
    let xBig = x.toBigInt();
    if (xBig < 0n || xBig >= 1n << BigInt(this.NUM_BITS)) {
      throw Error(`UInt32: Expected number between 0 and 2^32 - 1, got ${xBig}`);
    }
    return x;
  }
  // this checks the range if the argument is a constant
  /**
   * Creates a new {@link UInt32}.
   */
  static from(x) {
    if (x instanceof UInt322)
      x = x.value;
    return new this(this.checkConstant(Field(x)));
  }
  /**
   * Creates a {@link UInt32} with a value of 4,294,967,295.
   */
  static MAXINT() {
    return new UInt322(Field((1n << 32n) - 1n));
  }
  /**
   * Integer division with remainder.
   *
   * `x.divMod(y)` returns the quotient and the remainder.
   */
  divMod(y) {
    let x = this.value;
    let y_ = UInt322.from(y).value;
    if (x.isConstant() && y_.isConstant()) {
      let xn = x.toBigInt();
      let yn = y_.toBigInt();
      let q4 = xn / yn;
      let r2 = xn - q4 * yn;
      return {
        quotient: new UInt322(new Field(q4.toString())),
        rest: new UInt322(new Field(r2.toString()))
      };
    }
    y_ = y_.seal();
    let q3 = Circuit.witness(Field, () => new Field(x.toBigInt() / y_.toBigInt()));
    q3.rangeCheckHelper(UInt322.NUM_BITS).assertEquals(q3);
    let r = x.sub(q3.mul(y_)).seal();
    r.rangeCheckHelper(UInt322.NUM_BITS).assertEquals(r);
    let r_ = new UInt322(r);
    let q_ = new UInt322(q3);
    r_.assertLessThan(new UInt322(y_));
    return { quotient: q_, rest: r_ };
  }
  /**
   * Integer division.
   *
   * `x.div(y)` returns the floor of `x / y`, that is, the greatest
   * `z` such that `x * y <= x`.
   *
   */
  div(y) {
    return this.divMod(y).quotient;
  }
  /**
   * Integer remainder.
   *
   * `x.mod(y)` returns the value `z` such that `0 <= z < y` and
   * `x - z` is divisble by `y`.
   */
  mod(y) {
    return this.divMod(y).rest;
  }
  /**
   * Multiplication with overflow checking.
   */
  mul(y) {
    let z = this.value.mul(UInt322.from(y).value);
    z.rangeCheckHelper(UInt322.NUM_BITS).assertEquals(z);
    return new UInt322(z);
  }
  /**
   * Addition with overflow checking.
   */
  add(y) {
    let z = this.value.add(UInt322.from(y).value);
    z.rangeCheckHelper(UInt322.NUM_BITS).assertEquals(z);
    return new UInt322(z);
  }
  /**
   * Subtraction with underflow checking.
   */
  sub(y) {
    let z = this.value.sub(UInt322.from(y).value);
    z.rangeCheckHelper(UInt322.NUM_BITS).assertEquals(z);
    return new UInt322(z);
  }
  /**
   * @deprecated Use {@link lessThanOrEqual} instead.
   *
   * Checks if a {@link UInt32} is less than or equal to another one.
   */
  lte(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool(this.value.toBigInt() <= y.value.toBigInt());
    } else {
      let xMinusY = this.value.sub(y.value).seal();
      let yMinusX = xMinusY.neg();
      let xMinusYFits = xMinusY.rangeCheckHelper(UInt322.NUM_BITS).equals(xMinusY);
      let yMinusXFits = yMinusX.rangeCheckHelper(UInt322.NUM_BITS).equals(yMinusX);
      xMinusYFits.or(yMinusXFits).assertEquals(true);
      return yMinusXFits;
    }
  }
  /**
   * Checks if a {@link UInt32} is less than or equal to another one.
   */
  lessThanOrEqual(y) {
    if (this.value.isConstant() && y.value.isConstant()) {
      return Bool(this.value.toBigInt() <= y.value.toBigInt());
    } else {
      let xMinusY = this.value.sub(y.value).seal();
      let yMinusX = xMinusY.neg();
      let xMinusYFits = xMinusY.rangeCheckHelper(UInt322.NUM_BITS).equals(xMinusY);
      let yMinusXFits = yMinusX.rangeCheckHelper(UInt322.NUM_BITS).equals(yMinusX);
      xMinusYFits.or(yMinusXFits).assertEquals(true);
      return yMinusXFits;
    }
  }
  /**
   * @deprecated Use {@link assertLessThanOrEqual} instead.
   *
   * Asserts that a {@link UInt32} is less than or equal to another one.
   */
  assertLte(y, message) {
    this.assertLessThanOrEqual(y, message);
  }
  /**
   * Asserts that a {@link UInt32} is less than or equal to another one.
   */
  assertLessThanOrEqual(y, message) {
    if (this.value.isConstant() && y.value.isConstant()) {
      let x0 = this.value.toBigInt();
      let y0 = y.value.toBigInt();
      if (x0 > y0) {
        if (message !== void 0)
          throw Error(message);
        throw Error(`UInt32.assertLessThanOrEqual: expected ${x0} <= ${y0}`);
      }
      return;
    }
    let yMinusX = y.value.sub(this.value).seal();
    yMinusX.rangeCheckHelper(UInt322.NUM_BITS).assertEquals(yMinusX, message);
  }
  /**
   * @deprecated Use {@link lessThan} instead.
   *
   * Checks if a {@link UInt32} is less than another one.
   */
  lt(y) {
    return this.lessThanOrEqual(y).and(this.value.equals(y.value).not());
  }
  /**
   * Checks if a {@link UInt32} is less than another one.
   */
  lessThan(y) {
    return this.lessThanOrEqual(y).and(this.value.equals(y.value).not());
  }
  /**
   * @deprecated Use {@link assertLessThan} instead.
   *
   * Asserts that a {@link UInt32} is less than another one.
   */
  assertLt(y, message) {
    this.lessThan(y).assertEquals(true, message);
  }
  /**
   * Asserts that a {@link UInt32} is less than another one.
   */
  assertLessThan(y, message) {
    this.lessThan(y).assertEquals(true, message);
  }
  /**
   * @deprecated Use {@link greaterThan} instead.
   *
   * Checks if a {@link UInt32} is greater than another one.
   */
  gt(y) {
    return y.lessThan(this);
  }
  /**
   * Checks if a {@link UInt32} is greater than another one.
   */
  greaterThan(y) {
    return y.lessThan(this);
  }
  /**
   * @deprecated Use {@link assertGreaterThan} instead.
   *
   * Asserts that a {@link UInt32} is greater than another one.
   */
  assertGt(y, message) {
    y.assertLessThan(this, message);
  }
  /**
   * Asserts that a {@link UInt32} is greater than another one.
   */
  assertGreaterThan(y, message) {
    y.assertLessThan(this, message);
  }
  /**
   * @deprecated Use {@link greaterThanOrEqual} instead.
   *
   * Checks if a {@link UInt32} is greater than or equal to another one.
   */
  gte(y) {
    return this.lessThan(y).not();
  }
  /**
   * Checks if a {@link UInt32} is greater than or equal to another one.
   */
  greaterThanOrEqual(y) {
    return this.lessThan(y).not();
  }
  /**
     * @deprecated Use {@link assertGreaterThanOrEqual} instead.
  
     *
     * Asserts that a {@link UInt32} is greater than or equal to another one.
     */
  assertGte(y, message) {
    y.assertLessThanOrEqual(this, message);
  }
  /**
   * Asserts that a {@link UInt32} is greater than or equal to another one.
   */
  assertGreaterThanOrEqual(y, message) {
    y.assertLessThanOrEqual(this, message);
  }
};
UInt322.NUM_BITS = 32;
(0, import_tslib2.__decorate)([
  prop,
  (0, import_tslib2.__metadata)("design:type", Field)
], UInt322.prototype, "value", void 0);
var Sign3 = class extends CircuitValue {
  static get one() {
    return new Sign3(Field(1));
  }
  static get minusOne() {
    return new Sign3(Field(-1));
  }
  static check(x) {
    x.value.square().assertEquals(Field(1));
  }
  static emptyValue() {
    return Sign3.one;
  }
  static toInput(x) {
    return { packed: [[x.isPositive().toField(), 1]] };
  }
  static toJSON(x) {
    if (x.toString() === "1")
      return "Positive";
    if (x.neg().toString() === "1")
      return "Negative";
    throw Error(`Invalid Sign: ${x}`);
  }
  static fromJSON(x) {
    return x === "Positive" ? new Sign3(Field(1)) : new Sign3(Field(-1));
  }
  neg() {
    return new Sign3(this.value.neg());
  }
  mul(y) {
    return new Sign3(this.value.mul(y.value));
  }
  isPositive() {
    return this.value.equals(Field(1));
  }
  toString() {
    return this.value.toString();
  }
};
(0, import_tslib2.__decorate)([
  prop,
  (0, import_tslib2.__metadata)("design:type", Field)
], Sign3.prototype, "value", void 0);
var Int64 = class extends CircuitValue {
  // Some thoughts regarding the representation as field elements:
  // toFields returns the in-circuit representation, so the main objective is to minimize the number of constraints
  // that result from this representation. Therefore, I think the only candidate for an efficient 1-field representation
  // is the one where the Int64 is the field: toFields = Int64 => [Int64.magnitude.mul(Int64.sign)]. Anything else involving
  // bit packing would just lead to very inefficient circuit operations.
  //
  // So, is magnitude * sign ("1-field") a more efficient representation than (magnitude, sign) ("2-field")?
  // Several common operations like add, mul, etc, operate on 1-field so in 2-field they result in one additional multiplication
  // constraint per operand. However, the check operation (constraining to 64 bits + a sign) which is called at the introduction
  // of every witness, and also at the end of add, mul, etc, operates on 2-field. So here, the 1-field representation needs
  // to add an additional magnitude * sign = Int64 multiplication constraint, which will typically cancel out most of the gains
  // achieved by 1-field elsewhere.
  // There are some notable operations for which 2-field is definitely better:
  //
  // * div and mod (which do integer division with rounding on the magnitude)
  // * converting the Int64 to a Currency.Amount.Signed (for the zkapp balance), which has the exact same (magnitude, sign) representation we use here.
  //
  // The second point is one of the main things an Int64 is used for, and was the original motivation to use 2 fields.
  // Overall, I think the existing implementation is the optimal one.
  constructor(magnitude, sgn = Sign3.one) {
    super(magnitude, sgn);
  }
  /**
   * Creates a new {@link Int64} from a {@link Field}.
   *
   * Does check if the {@link Field} is within range.
   */
  static fromFieldUnchecked(x) {
    let TWO64 = 1n << 64n;
    let xBigInt = x.toBigInt();
    let isValidPositive = xBigInt < TWO64;
    let isValidNegative = Field.ORDER - xBigInt < TWO64;
    if (!isValidPositive && !isValidNegative)
      throw Error(`Int64: Expected a value between (-2^64, 2^64), got ${x}`);
    let magnitude = Field(isValidPositive ? x.toString() : x.neg().toString());
    let sign = isValidPositive ? Sign3.one : Sign3.minusOne;
    return new Int64(new UInt642(magnitude), sign);
  }
  // this doesn't check ranges because we assume they're already checked on UInts
  /**
   * Creates a new {@link Int64} from a {@link Field}.
   *
   * **Does not** check if the {@link Field} is within range.
   */
  static fromUnsigned(x) {
    return new Int64(x instanceof UInt322 ? x.toUInt64() : x);
  }
  // this checks the range if the argument is a constant
  /**
   * Creates a new {@link Int64}.
   *
   * Check the range if the argument is a constant.
   */
  static from(x) {
    if (x instanceof Int64)
      return x;
    if (x instanceof UInt642 || x instanceof UInt322) {
      return Int64.fromUnsigned(x);
    }
    return Int64.fromFieldUnchecked(Field(x));
  }
  /**
   * Turns the {@link Int64} into a string.
   */
  toString() {
    let abs = this.magnitude.toString();
    let sgn = this.isPositive().toBoolean() || abs === "0" ? "" : "-";
    return sgn + abs;
  }
  isConstant() {
    return this.magnitude.value.isConstant() && this.sgn.isConstant();
  }
  // --- circuit-compatible operations below ---
  // the assumption here is that all Int64 values that appear in a circuit are already checked as valid
  // this is because Circuit.witness calls .check, which calls .check on each prop, i.e. UInt64 and Sign
  // so we only have to do additional checks if an operation on valid inputs can have an invalid outcome (example: overflow)
  /**
   * Static method to create a {@link Int64} with value `0`.
   */
  static get zero() {
    return new Int64(UInt642.zero);
  }
  /**
   * Static method to create a {@link Int64} with value `1`.
   */
  static get one() {
    return new Int64(UInt642.one);
  }
  /**
   * Static method to create a {@link Int64} with value `-1`.
   */
  static get minusOne() {
    return new Int64(UInt642.one).neg();
  }
  /**
   * Returns the {@link Field} value.
   */
  toField() {
    return this.magnitude.value.mul(this.sgn.value);
  }
  /**
   * Static method to create a {@link Int64} from a {@link Field}.
   */
  static fromField(x) {
    if (x.isConstant())
      return Int64.fromFieldUnchecked(x);
    let xInt = Circuit.witness(Int64, () => Int64.fromFieldUnchecked(x));
    xInt.toField().assertEquals(x);
    return xInt;
  }
  /**
   * Negates the value.
   *
   * `Int64.from(5).neg()` will turn into `Int64.from(-5)`
   */
  neg() {
    return new Int64(this.magnitude, this.sgn.neg());
  }
  /**
   * Addition with overflow checking.
   */
  add(y) {
    let y_ = Int64.from(y);
    return Int64.fromField(this.toField().add(y_.toField()));
  }
  /**
   * Subtraction with underflow checking.
   */
  sub(y) {
    let y_ = Int64.from(y);
    return Int64.fromField(this.toField().sub(y_.toField()));
  }
  /**
   * Multiplication with overflow checking.
   */
  mul(y) {
    let y_ = Int64.from(y);
    return Int64.fromField(this.toField().mul(y_.toField()));
  }
  /**
   * Integer division.
   *
   * `x.div(y)` returns the floor of `x / y`, that is, the greatest
   * `z` such that `z * y <= x`.
   *
   */
  div(y) {
    let y_ = Int64.from(y);
    let { quotient } = this.magnitude.divMod(y_.magnitude);
    let sign = this.sgn.mul(y_.sgn);
    return new Int64(quotient, sign);
  }
  /**
   * Integer remainder.
   *
   * `x.mod(y)` returns the value `z` such that `0 <= z < y` and
   * `x - z` is divisble by `y`.
   */
  mod(y) {
    let y_ = UInt642.from(y);
    let rest = this.magnitude.divMod(y_).rest.value;
    rest = Circuit.if(this.isPositive(), rest, y_.value.sub(rest));
    return new Int64(new UInt642(rest));
  }
  /**
   * Checks if two values are equal.
   */
  equals(y) {
    let y_ = Int64.from(y);
    return this.toField().equals(y_.toField());
  }
  /**
   * Asserts that two values are equal.
   */
  assertEquals(y, message) {
    let y_ = Int64.from(y);
    this.toField().assertEquals(y_.toField(), message);
  }
  /**
   * Checks if the value is postive.
   */
  isPositive() {
    return this.sgn.isPositive();
  }
};
(0, import_tslib2.__decorate)([
  prop,
  (0, import_tslib2.__metadata)("design:type", UInt642)
], Int64.prototype, "magnitude", void 0);
(0, import_tslib2.__decorate)([
  prop,
  (0, import_tslib2.__metadata)("design:type", Sign3)
], Int64.prototype, "sgn", void 0);

// dist/node/provable/gen/transaction.js
var transaction_exports = {};
__export(transaction_exports, {
  Account: () => Account,
  AccountUpdate: () => AccountUpdate,
  ActionState: () => ActionState,
  Actions: () => Actions,
  AuthRequired: () => AuthRequired,
  Bool: () => Bool,
  Events: () => Events,
  Field: () => Field,
  Json: () => transaction_json_exports,
  PublicKey: () => PublicKey2,
  ReceiptChainHash: () => ReceiptChainHash,
  Sign: () => Sign3,
  StateHash: () => StateHash,
  TokenId: () => TokenId,
  TokenSymbol: () => TokenSymbol2,
  TypeMap: () => TypeMap,
  UInt32: () => UInt322,
  UInt64: () => UInt642,
  ZkappCommand: () => ZkappCommand,
  ZkappUri: () => ZkappUri,
  customTypes: () => customTypes,
  emptyValue: () => emptyValue2,
  provableFromLayout: () => provableFromLayout,
  toJSONEssential: () => toJSONEssential
});

// dist/node/lib/events.js
function createEvents({ Field: Field4, Poseidon: Poseidon4 }) {
  function initialState() {
    return [Field4(0), Field4(0), Field4(0)];
  }
  function salt2(prefix) {
    return Poseidon4.update(initialState(), [prefixToField(Field4, prefix)]);
  }
  function hashWithPrefix3(prefix, input) {
    let init = salt2(prefix);
    return Poseidon4.update(init, input)[0];
  }
  function emptyHashWithPrefix2(prefix) {
    return salt2(prefix)[0];
  }
  const Events2 = {
    empty() {
      let hash2 = emptyHashWithPrefix2("MinaZkappEventsEmpty");
      return { hash: hash2, data: [] };
    },
    pushEvent(events, event) {
      let eventHash = hashWithPrefix3(prefixes.event, event);
      let hash2 = hashWithPrefix3(prefixes.events, [events.hash, eventHash]);
      return { hash: hash2, data: [event, ...events.data] };
    },
    fromList(events) {
      return [...events].reverse().reduce(Events2.pushEvent, Events2.empty());
    },
    hash(events) {
      return Events2.fromList(events).hash;
    }
  };
  const EventsProvable = {
    ...Events2,
    ...dataAsHash({
      emptyValue: Events2.empty,
      toJSON(data) {
        return data.map((row) => row.map((e) => Field4.toJSON(e)));
      },
      fromJSON(json) {
        let data = json.map((row) => row.map((e) => Field4.fromJSON(e)));
        let hash2 = Events2.hash(data);
        return { data, hash: hash2 };
      }
    })
  };
  const Actions2 = {
    // same as events but w/ different hash prefixes
    empty() {
      let hash2 = emptyHashWithPrefix2("MinaZkappActionsEmpty");
      return { hash: hash2, data: [] };
    },
    pushEvent(actions, event) {
      let eventHash = hashWithPrefix3(prefixes.event, event);
      let hash2 = hashWithPrefix3(prefixes.sequenceEvents, [
        actions.hash,
        eventHash
      ]);
      return { hash: hash2, data: [event, ...actions.data] };
    },
    fromList(events) {
      return [...events].reverse().reduce(Actions2.pushEvent, Actions2.empty());
    },
    hash(events) {
      return this.fromList(events).hash;
    },
    // different than events
    emptyActionState() {
      return emptyHashWithPrefix2("MinaZkappActionStateEmptyElt");
    },
    updateSequenceState(state2, sequenceEventsHash) {
      return hashWithPrefix3(prefixes.sequenceEvents, [
        state2,
        sequenceEventsHash
      ]);
    }
  };
  const SequenceEventsProvable = {
    ...Actions2,
    ...dataAsHash({
      emptyValue: Actions2.empty,
      toJSON(data) {
        return data.map((row) => row.map((e) => Field4.toJSON(e)));
      },
      fromJSON(json) {
        let data = json.map((row) => row.map((e) => Field4.fromJSON(e)));
        let hash2 = Actions2.hash(data);
        return { data, hash: hash2 };
      }
    })
  };
  return { Events: EventsProvable, Actions: SequenceEventsProvable };
}
function dataAsHash({ emptyValue: emptyValue3, toJSON, fromJSON }) {
  return {
    emptyValue: emptyValue3,
    sizeInFields() {
      return 1;
    },
    toFields({ hash: hash2 }) {
      return [hash2];
    },
    toAuxiliary(value) {
      return [value?.data ?? emptyValue3().data];
    },
    fromFields([hash2], [data]) {
      return { data, hash: hash2 };
    },
    toJSON({ data }) {
      return toJSON(data);
    },
    fromJSON(json) {
      return fromJSON(json);
    },
    check() {
    },
    toInput({ hash: hash2 }) {
      return { fields: [hash2] };
    }
  };
}

// dist/node/provable/derived-leaves.js
var tokenSymbolLength = 6;
function derivedLeafTypes({ Field: Field4, Bool: Bool4, Hash: Hash3, packToFields: packToFields3 }) {
  let provable3 = createProvable();
  const Encoding = fieldEncodings(Field4);
  const defaultTokenId = 1;
  const TokenId4 = {
    ...provable3(Field4),
    emptyValue() {
      return Field4(defaultTokenId);
    },
    toJSON(x) {
      return Encoding.TokenId.toBase58(x);
    },
    fromJSON(x) {
      return Encoding.TokenId.fromBase58(x);
    }
  };
  const StateHash3 = {
    ...provable3(Field4),
    toJSON(x) {
      return Encoding.StateHash.toBase58(x);
    },
    fromJSON(x) {
      return Encoding.StateHash.fromBase58(x);
    }
  };
  const TokenSymbol3 = {
    ...provable3({ field: Field4, symbol: String }),
    toInput({ field }) {
      return { packed: [[field, 48]] };
    },
    toJSON({ symbol }) {
      return symbol;
    },
    fromJSON(symbol) {
      let bytesLength = stringLengthInBytes(symbol);
      if (bytesLength > tokenSymbolLength)
        throw Error(`Token symbol ${symbol} should be a maximum of 6 bytes, but is ${bytesLength}`);
      return { symbol, field: prefixToField(Field4, symbol) };
    }
  };
  const AuthRequired2 = {
    ...provable3({ constant: Bool4, signatureNecessary: Bool4, signatureSufficient: Bool4 }, {
      customObjectKeys: [
        "constant",
        "signatureNecessary",
        "signatureSufficient"
      ]
    }),
    emptyValue() {
      return {
        constant: Bool4(true),
        signatureNecessary: Bool4(false),
        signatureSufficient: Bool4(true)
      };
    },
    toJSON(x) {
      let c = Number(Bool4.toJSON(x.constant));
      let n = Number(Bool4.toJSON(x.signatureNecessary));
      let s = Number(Bool4.toJSON(x.signatureSufficient));
      switch (`${c}${n}${s}`) {
        case "110":
          return "Impossible";
        case "101":
          return "None";
        case "000":
          return "Proof";
        case "011":
          return "Signature";
        case "001":
          return "Either";
        default:
          throw Error("Unexpected permission");
      }
    },
    fromJSON(json) {
      let map = {
        Impossible: "110",
        None: "101",
        Proof: "000",
        Signature: "011",
        Either: "001"
      };
      let code = map[json];
      if (code === void 0)
        throw Error("Unexpected permission");
      let [constant, signatureNecessary, signatureSufficient] = code.split("").map((s) => Bool4(!!Number(s)));
      return { constant, signatureNecessary, signatureSufficient };
    }
  };
  function hashZkappUri(uri) {
    let bits2 = bytesToBits(stringToBytes(uri));
    bits2.push(true);
    let input = { packed: bits2.map((b2) => [Field4(Number(b2)), 1]) };
    let packed = packToFields3(input);
    return Hash3.hashWithPrefix(prefixes.zkappUri, packed);
  }
  const ZkappUri2 = dataAsHash({
    emptyValue() {
      let hash2 = Hash3.hashWithPrefix(prefixes.zkappUri, [Field4(0), Field4(0)]);
      return { data: "", hash: hash2 };
    },
    toJSON(data) {
      return data;
    },
    fromJSON(json) {
      return { data: json, hash: hashZkappUri(json) };
    }
  });
  return { TokenId: TokenId4, StateHash: StateHash3, TokenSymbol: TokenSymbol3, AuthRequired: AuthRequired2, ZkappUri: ZkappUri2 };
}

// dist/node/provable/transaction-leaves.js
var { TokenId, StateHash, TokenSymbol: TokenSymbol2, AuthRequired, ZkappUri } = derivedLeafTypes({ Field, Bool, Hash, packToFields });
var { Events, Actions } = createEvents({ Field, Poseidon: Poseidon2 });
var ActionState = {
  ...provable2(Field),
  emptyValue: Actions.emptyActionState
};
var ReceiptChainHash = {
  ...provable2(Field),
  emptyValue: () => emptyHashWithPrefix("CodaReceiptEmpty")
};

// dist/node/provable/generic.js
var emptyType = {
  sizeInFields: () => 0,
  toFields: () => [],
  toAuxiliary: () => [],
  fromFields: () => null,
  check: () => {
  },
  toInput: () => ({}),
  toJSON: () => null,
  fromJSON: () => null
};
var primitiveTypes = /* @__PURE__ */ new Set(["number", "string", "null"]);
function primitiveTypeMap() {
  return primitiveTypeMap_;
}
var primitiveTypeMap_ = {
  number: {
    ...emptyType,
    toAuxiliary: (value = 0) => [value],
    toJSON: (value) => value,
    fromJSON: (value) => value,
    fromFields: (_, [value]) => value
  },
  string: {
    ...emptyType,
    toAuxiliary: (value = "") => [value],
    toJSON: (value) => value,
    fromJSON: (value) => value,
    fromFields: (_, [value]) => value
  },
  null: emptyType
};

// dist/node/provable/from-layout.js
function ProvableFromLayout(TypeMap2, customTypes2) {
  const Field4 = TypeMap2.Field;
  const PrimitiveMap = primitiveTypeMap();
  function layoutFold(spec, typeData, value) {
    return genericLayoutFold(TypeMap2, customTypes2, spec, typeData, value);
  }
  function provableFromLayout2(typeData) {
    return {
      sizeInFields() {
        return sizeInFields(typeData);
      },
      toFields(value) {
        return toFields(typeData, value);
      },
      toAuxiliary(value) {
        return toAuxiliary(typeData, value);
      },
      fromFields(fields, aux) {
        return fromFields(typeData, fields, aux);
      },
      toJSON(value) {
        return toJSON(typeData, value);
      },
      fromJSON(json) {
        return fromJSON(typeData, json);
      },
      check(value) {
        check(typeData, value);
      },
      toInput(value) {
        return toInput(typeData, value);
      },
      emptyValue() {
        return emptyValue3(typeData);
      }
    };
  }
  function toJSON(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toJSON(value2);
      },
      reduceArray(array) {
        return array;
      },
      reduceObject(_, object) {
        return object;
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return isSome ? value2 : null;
      },
      reduceOrUndefined(value2) {
        return value2 ?? null;
      }
    }, typeData, value);
  }
  function fromJSON(typeData, json) {
    let { checkedTypeName } = typeData;
    if (checkedTypeName) {
      return customTypes2[checkedTypeName].fromJSON(json);
    }
    if (typeData.type === "array") {
      let arrayTypeData = typeData;
      return json.map((json2) => fromJSON(arrayTypeData.inner, json2));
    }
    if (typeData.type === "option") {
      let optionTypeData = typeData;
      switch (optionTypeData.optionType) {
        case "closedInterval":
        case "flaggedOption": {
          let isSome = TypeMap2.Bool.fromJSON(json !== null);
          let value;
          if (json !== null) {
            value = fromJSON(optionTypeData.inner, json);
          } else {
            value = emptyValue3(optionTypeData.inner);
            if (optionTypeData.optionType === "closedInterval") {
              let innerInner = optionTypeData.inner.entries.lower;
              let innerType = TypeMap2[innerInner.type];
              value.lower = innerType.fromJSON(optionTypeData.rangeMin);
              value.upper = innerType.fromJSON(optionTypeData.rangeMax);
            }
          }
          return { isSome, value };
        }
        case "orUndefined": {
          return json === null ? void 0 : fromJSON(optionTypeData.inner, json);
        }
        default:
          throw Error("bug");
      }
    }
    if (typeData.type === "object") {
      let { keys, entries } = typeData;
      let values = {};
      for (let i2 = 0; i2 < keys.length; i2++) {
        let typeEntry = entries[keys[i2]];
        values[keys[i2]] = fromJSON(typeEntry, json[keys[i2]]);
      }
      return values;
    }
    if (primitiveTypes.has(typeData.type)) {
      return PrimitiveMap[typeData.type].fromJSON(json);
    }
    return TypeMap2[typeData.type].fromJSON(json);
  }
  function toFields(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toFields(value2);
      },
      reduceArray(array) {
        return array.flat();
      },
      reduceObject(keys, object) {
        return keys.map((key) => object[key]).flat();
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return [isSome, value2].flat();
      },
      reduceOrUndefined(_) {
        return [];
      }
    }, typeData, value);
  }
  function toAuxiliary(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toAuxiliary(value2);
      },
      reduceArray(array) {
        return array;
      },
      reduceObject(keys, object) {
        return keys.map((key) => object[key]);
      },
      reduceFlaggedOption({ value: value2 }) {
        return value2;
      },
      reduceOrUndefined(value2) {
        return value2 === void 0 ? [false] : [true, value2];
      }
    }, typeData, value);
  }
  function sizeInFields(typeData) {
    let spec = {
      map(type) {
        return type.sizeInFields();
      },
      reduceArray(_, { inner, staticLength }) {
        let length = staticLength ?? NaN;
        return length * layoutFold(spec, inner);
      },
      reduceObject(keys, object) {
        return keys.map((key) => object[key]).reduce((x, y) => x + y);
      },
      reduceFlaggedOption({ isSome, value }) {
        return isSome + value;
      },
      reduceOrUndefined(_) {
        return 0;
      }
    };
    return layoutFold(spec, typeData);
  }
  function fromFields(typeData, fields, aux) {
    let { checkedTypeName } = typeData;
    if (checkedTypeName) {
      return customTypes2[checkedTypeName].fromFields(fields, aux);
    }
    if (typeData.type === "array") {
      let arrayTypeData = typeData;
      let size = sizeInFields(arrayTypeData.inner);
      let length = aux.length;
      let value = [];
      for (let i2 = 0, offset = 0; i2 < length; i2++, offset += size) {
        value[i2] = fromFields(arrayTypeData.inner, fields.slice(offset, offset + size), aux[i2]);
      }
      return value;
    }
    if (typeData.type === "option") {
      let { optionType, inner } = typeData;
      switch (optionType) {
        case "closedInterval":
        case "flaggedOption": {
          let [first, ...rest] = fields;
          let isSome = TypeMap2.Bool.fromFields([first], []);
          let value = fromFields(inner, rest, aux);
          return { isSome, value };
        }
        case "orUndefined": {
          let [isDefined, value] = aux;
          return isDefined ? fromFields(inner, fields, value) : void 0;
        }
        default:
          throw Error("bug");
      }
    }
    if (typeData.type === "object") {
      let { keys, entries } = typeData;
      let values = {};
      let offset = 0;
      for (let i2 = 0; i2 < keys.length; i2++) {
        let typeEntry = entries[keys[i2]];
        let size = sizeInFields(typeEntry);
        values[keys[i2]] = fromFields(typeEntry, fields.slice(offset, offset + size), aux[i2]);
        offset += size;
      }
      return values;
    }
    if (primitiveTypes.has(typeData.type)) {
      return PrimitiveMap[typeData.type].fromFields(fields, aux);
    }
    return TypeMap2[typeData.type].fromFields(fields, aux);
  }
  function emptyValue3(typeData) {
    let zero = TypeMap2.Field.fromJSON("0");
    return layoutFold({
      map(type) {
        if (type.emptyValue)
          return type.emptyValue();
        return type.fromFields(Array(type.sizeInFields()).fill(zero), type.toAuxiliary());
      },
      reduceArray(array) {
        return array;
      },
      reduceObject(_, object) {
        return object;
      },
      reduceFlaggedOption({ isSome, value }, typeData2) {
        if (typeData2.optionType === "closedInterval") {
          let innerInner = typeData2.inner.entries.lower;
          let innerType = TypeMap2[innerInner.type];
          value.lower = innerType.fromJSON(typeData2.rangeMin);
          value.upper = innerType.fromJSON(typeData2.rangeMax);
        }
        return { isSome, value };
      },
      reduceOrUndefined() {
        return void 0;
      }
    }, typeData, void 0);
  }
  function check(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.check(value2);
      },
      reduceArray() {
      },
      reduceObject() {
      },
      reduceFlaggedOption() {
      },
      reduceOrUndefined() {
      }
    }, typeData, value);
  }
  function toInput(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toInput(value2);
      },
      reduceArray(array) {
        let acc = { fields: [], packed: [] };
        for (let { fields, packed } of array) {
          if (fields)
            acc.fields.push(...fields);
          if (packed)
            acc.packed.push(...packed);
        }
        return acc;
      },
      reduceObject(keys, object) {
        let acc = { fields: [], packed: [] };
        for (let key of keys) {
          let { fields, packed } = object[key];
          if (fields)
            acc.fields.push(...fields);
          if (packed)
            acc.packed.push(...packed);
        }
        return acc;
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return {
          fields: value2.fields,
          packed: isSome.packed.concat(value2.packed ?? [])
        };
      },
      reduceOrUndefined(_) {
        return {};
      }
    }, typeData, value);
  }
  function toJSONEssential2(typeData, value) {
    return layoutFold({
      map(type, value2) {
        return type.toJSON(value2);
      },
      reduceArray(array) {
        if (array.length === 0 || array.every((x) => x === null))
          return null;
        return array;
      },
      reduceObject(_, object) {
        for (let key in object) {
          if (object[key] === null) {
            delete object[key];
          }
        }
        if (Object.keys(object).length === 0)
          return null;
        return object;
      },
      reduceFlaggedOption({ isSome, value: value2 }) {
        return isSome ? value2 : null;
      },
      reduceOrUndefined(value2) {
        return value2 ?? null;
      }
    }, typeData, value);
  }
  return { provableFromLayout: provableFromLayout2, toJSONEssential: toJSONEssential2, emptyValue: emptyValue3 };
}
function genericLayoutFold(TypeMap2, customTypes2, spec, typeData, value) {
  let PrimitiveMap = primitiveTypeMap();
  let { checkedTypeName } = typeData;
  if (checkedTypeName) {
    return spec.map(customTypes2[checkedTypeName], value, checkedTypeName);
  }
  if (typeData.type === "array") {
    let arrayTypeData = typeData;
    let v = value;
    if (arrayTypeData.staticLength !== null && v === void 0) {
      v = Array(arrayTypeData.staticLength).fill(void 0);
    }
    let array = v?.map((x) => genericLayoutFold(TypeMap2, customTypes2, spec, arrayTypeData.inner, x)) ?? [];
    return spec.reduceArray(array, arrayTypeData);
  }
  if (typeData.type === "option") {
    let { optionType, inner } = typeData;
    switch (optionType) {
      case "closedInterval":
      case "flaggedOption":
        let v = value;
        return spec.reduceFlaggedOption({
          isSome: spec.map(TypeMap2.Bool, v?.isSome, "Bool"),
          value: genericLayoutFold(TypeMap2, customTypes2, spec, inner, v?.value)
        }, typeData);
      case "orUndefined":
        let mapped = value === void 0 ? void 0 : genericLayoutFold(TypeMap2, customTypes2, spec, inner, value);
        return spec.reduceOrUndefined(mapped, inner);
      default:
        throw Error("bug");
    }
  }
  if (typeData.type === "object") {
    let { keys, entries } = typeData;
    let v = value;
    let object = {};
    keys.forEach((key) => {
      object[key] = genericLayoutFold(TypeMap2, customTypes2, spec, entries[key], v?.[key]);
    });
    return spec.reduceObject(keys, object);
  }
  if (primitiveTypes.has(typeData.type)) {
    return spec.map(PrimitiveMap[typeData.type], value, typeData.type);
  }
  return spec.map(TypeMap2[typeData.type], value, typeData.type);
}

// dist/node/provable/gen/transaction-json.js
var transaction_json_exports = {};

// dist/node/provable/gen/js-layout.js
var jsLayout = {
  ZkappCommand: {
    type: "object",
    name: "ZkappCommand",
    docs: null,
    keys: ["feePayer", "accountUpdates", "memo"],
    entries: {
      feePayer: {
        type: "object",
        name: "ZkappFeePayer",
        docs: null,
        keys: ["body", "authorization"],
        entries: {
          body: {
            type: "object",
            name: "FeePayerBody",
            docs: null,
            keys: ["publicKey", "fee", "validUntil", "nonce"],
            entries: {
              publicKey: { type: "PublicKey" },
              fee: { type: "UInt64" },
              validUntil: {
                type: "option",
                optionType: "orUndefined",
                inner: { type: "UInt32" }
              },
              nonce: { type: "UInt32" }
            },
            docEntries: {
              publicKey: null,
              fee: null,
              validUntil: null,
              nonce: null
            }
          },
          authorization: { type: "string" }
        },
        docEntries: { body: null, authorization: null }
      },
      accountUpdates: {
        type: "array",
        inner: {
          type: "object",
          name: "ZkappAccountUpdate",
          docs: "An account update in a zkApp transaction",
          keys: ["body", "authorization"],
          entries: {
            body: {
              type: "object",
              name: "AccountUpdateBody",
              docs: null,
              keys: [
                "publicKey",
                "tokenId",
                "update",
                "balanceChange",
                "incrementNonce",
                "events",
                "actions",
                "callData",
                "callDepth",
                "preconditions",
                "useFullCommitment",
                "implicitAccountCreationFee",
                "mayUseToken",
                "authorizationKind"
              ],
              entries: {
                publicKey: { type: "PublicKey" },
                tokenId: { type: "TokenId" },
                update: {
                  type: "object",
                  name: "AccountUpdateModification",
                  docs: null,
                  keys: [
                    "appState",
                    "delegate",
                    "verificationKey",
                    "permissions",
                    "zkappUri",
                    "tokenSymbol",
                    "timing",
                    "votingFor"
                  ],
                  entries: {
                    appState: {
                      type: "array",
                      inner: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      staticLength: 8
                    },
                    delegate: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: { type: "PublicKey" }
                    },
                    verificationKey: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "object",
                        name: "VerificationKeyWithHash",
                        docs: null,
                        keys: ["data", "hash"],
                        entries: {
                          data: { type: "string" },
                          hash: { type: "Field" }
                        },
                        docEntries: { data: null, hash: null }
                      }
                    },
                    permissions: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "object",
                        name: "Permissions",
                        docs: null,
                        keys: [
                          "editState",
                          "access",
                          "send",
                          "receive",
                          "setDelegate",
                          "setPermissions",
                          "setVerificationKey",
                          "setZkappUri",
                          "editActionState",
                          "setTokenSymbol",
                          "incrementNonce",
                          "setVotingFor",
                          "setTiming"
                        ],
                        entries: {
                          editState: { type: "AuthRequired" },
                          access: { type: "AuthRequired" },
                          send: { type: "AuthRequired" },
                          receive: { type: "AuthRequired" },
                          setDelegate: { type: "AuthRequired" },
                          setPermissions: { type: "AuthRequired" },
                          setVerificationKey: { type: "AuthRequired" },
                          setZkappUri: { type: "AuthRequired" },
                          editActionState: { type: "AuthRequired" },
                          setTokenSymbol: { type: "AuthRequired" },
                          incrementNonce: { type: "AuthRequired" },
                          setVotingFor: { type: "AuthRequired" },
                          setTiming: { type: "AuthRequired" }
                        },
                        docEntries: {
                          editState: null,
                          access: null,
                          send: null,
                          receive: null,
                          setDelegate: null,
                          setPermissions: null,
                          setVerificationKey: null,
                          setZkappUri: null,
                          editActionState: null,
                          setTokenSymbol: null,
                          incrementNonce: null,
                          setVotingFor: null,
                          setTiming: null
                        }
                      }
                    },
                    zkappUri: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "string",
                        checkedType: {
                          type: "object",
                          name: "Events",
                          docs: null,
                          keys: ["data", "hash"],
                          entries: {
                            data: { type: "string" },
                            hash: { type: "Field" }
                          },
                          docEntries: { data: null, hash: null }
                        },
                        checkedTypeName: "ZkappUri"
                      }
                    },
                    tokenSymbol: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "string",
                        checkedType: {
                          type: "object",
                          name: "Anonymous",
                          docs: null,
                          keys: ["symbol", "field"],
                          entries: {
                            symbol: { type: "string" },
                            field: { type: "Field" }
                          },
                          docEntries: { symbol: "", field: "" }
                        },
                        checkedTypeName: "TokenSymbol"
                      }
                    },
                    timing: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "object",
                        name: "Timing",
                        docs: null,
                        keys: [
                          "initialMinimumBalance",
                          "cliffTime",
                          "cliffAmount",
                          "vestingPeriod",
                          "vestingIncrement"
                        ],
                        entries: {
                          initialMinimumBalance: { type: "UInt64" },
                          cliffTime: { type: "UInt32" },
                          cliffAmount: { type: "UInt64" },
                          vestingPeriod: { type: "UInt32" },
                          vestingIncrement: { type: "UInt64" }
                        },
                        docEntries: {
                          initialMinimumBalance: null,
                          cliffTime: null,
                          cliffAmount: null,
                          vestingPeriod: null,
                          vestingIncrement: null
                        }
                      }
                    },
                    votingFor: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: {
                        type: "Field",
                        checkedType: { type: "Field" },
                        checkedTypeName: "StateHash"
                      }
                    }
                  },
                  docEntries: {
                    appState: null,
                    delegate: null,
                    verificationKey: null,
                    permissions: null,
                    zkappUri: null,
                    tokenSymbol: null,
                    timing: null,
                    votingFor: null
                  }
                },
                balanceChange: {
                  type: "object",
                  name: "BalanceChange",
                  docs: null,
                  keys: ["magnitude", "sgn"],
                  entries: {
                    magnitude: { type: "UInt64" },
                    sgn: { type: "Sign" }
                  },
                  docEntries: { magnitude: null, sgn: null }
                },
                incrementNonce: { type: "Bool" },
                events: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null,
                  checkedType: {
                    type: "object",
                    name: "Events",
                    docs: null,
                    keys: ["data", "hash"],
                    entries: {
                      data: {
                        type: "array",
                        inner: {
                          type: "array",
                          inner: { type: "Field" },
                          staticLength: null
                        },
                        staticLength: null
                      },
                      hash: { type: "Field" }
                    },
                    docEntries: { data: null, hash: null }
                  },
                  checkedTypeName: "Events"
                },
                actions: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null,
                  checkedType: {
                    type: "object",
                    name: "Events",
                    docs: null,
                    keys: ["data", "hash"],
                    entries: {
                      data: {
                        type: "array",
                        inner: {
                          type: "array",
                          inner: { type: "Field" },
                          staticLength: null
                        },
                        staticLength: null
                      },
                      hash: { type: "Field" }
                    },
                    docEntries: { data: null, hash: null }
                  },
                  checkedTypeName: "Actions"
                },
                callData: { type: "Field" },
                callDepth: { type: "number" },
                preconditions: {
                  type: "object",
                  name: "Preconditions",
                  docs: null,
                  keys: ["network", "account", "validWhile"],
                  entries: {
                    network: {
                      type: "object",
                      name: "NetworkPrecondition",
                      docs: null,
                      keys: [
                        "snarkedLedgerHash",
                        "blockchainLength",
                        "minWindowDensity",
                        "totalCurrency",
                        "globalSlotSinceGenesis",
                        "stakingEpochData",
                        "nextEpochData"
                      ],
                      entries: {
                        snarkedLedgerHash: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Field" }
                        },
                        blockchainLength: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "LengthInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        minWindowDensity: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "LengthInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        totalCurrency: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "18446744073709551615",
                          inner: {
                            type: "object",
                            name: "CurrencyAmountInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt64" },
                              upper: { type: "UInt64" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        globalSlotSinceGenesis: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "GlobalSlotInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        stakingEpochData: {
                          type: "object",
                          name: "EpochDataPrecondition",
                          docs: null,
                          keys: [
                            "ledger",
                            "seed",
                            "startCheckpoint",
                            "lockCheckpoint",
                            "epochLength"
                          ],
                          entries: {
                            ledger: {
                              type: "object",
                              name: "EpochLedgerPrecondition",
                              docs: null,
                              keys: ["hash", "totalCurrency"],
                              entries: {
                                hash: {
                                  type: "option",
                                  optionType: "flaggedOption",
                                  inner: { type: "Field" }
                                },
                                totalCurrency: {
                                  type: "option",
                                  optionType: "closedInterval",
                                  rangeMin: "0",
                                  rangeMax: "18446744073709551615",
                                  inner: {
                                    type: "object",
                                    name: "CurrencyAmountInterval",
                                    docs: null,
                                    keys: ["lower", "upper"],
                                    entries: {
                                      lower: { type: "UInt64" },
                                      upper: { type: "UInt64" }
                                    },
                                    docEntries: { lower: null, upper: null }
                                  }
                                }
                              },
                              docEntries: { hash: null, totalCurrency: null }
                            },
                            seed: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            startCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            lockCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            epochLength: {
                              type: "option",
                              optionType: "closedInterval",
                              rangeMin: "0",
                              rangeMax: "4294967295",
                              inner: {
                                type: "object",
                                name: "LengthInterval",
                                docs: null,
                                keys: ["lower", "upper"],
                                entries: {
                                  lower: { type: "UInt32" },
                                  upper: { type: "UInt32" }
                                },
                                docEntries: { lower: null, upper: null }
                              }
                            }
                          },
                          docEntries: {
                            ledger: null,
                            seed: null,
                            startCheckpoint: null,
                            lockCheckpoint: null,
                            epochLength: null
                          }
                        },
                        nextEpochData: {
                          type: "object",
                          name: "EpochDataPrecondition",
                          docs: null,
                          keys: [
                            "ledger",
                            "seed",
                            "startCheckpoint",
                            "lockCheckpoint",
                            "epochLength"
                          ],
                          entries: {
                            ledger: {
                              type: "object",
                              name: "EpochLedgerPrecondition",
                              docs: null,
                              keys: ["hash", "totalCurrency"],
                              entries: {
                                hash: {
                                  type: "option",
                                  optionType: "flaggedOption",
                                  inner: { type: "Field" }
                                },
                                totalCurrency: {
                                  type: "option",
                                  optionType: "closedInterval",
                                  rangeMin: "0",
                                  rangeMax: "18446744073709551615",
                                  inner: {
                                    type: "object",
                                    name: "CurrencyAmountInterval",
                                    docs: null,
                                    keys: ["lower", "upper"],
                                    entries: {
                                      lower: { type: "UInt64" },
                                      upper: { type: "UInt64" }
                                    },
                                    docEntries: { lower: null, upper: null }
                                  }
                                }
                              },
                              docEntries: { hash: null, totalCurrency: null }
                            },
                            seed: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            startCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            lockCheckpoint: {
                              type: "option",
                              optionType: "flaggedOption",
                              inner: { type: "Field" }
                            },
                            epochLength: {
                              type: "option",
                              optionType: "closedInterval",
                              rangeMin: "0",
                              rangeMax: "4294967295",
                              inner: {
                                type: "object",
                                name: "LengthInterval",
                                docs: null,
                                keys: ["lower", "upper"],
                                entries: {
                                  lower: { type: "UInt32" },
                                  upper: { type: "UInt32" }
                                },
                                docEntries: { lower: null, upper: null }
                              }
                            }
                          },
                          docEntries: {
                            ledger: null,
                            seed: null,
                            startCheckpoint: null,
                            lockCheckpoint: null,
                            epochLength: null
                          }
                        }
                      },
                      docEntries: {
                        snarkedLedgerHash: null,
                        blockchainLength: null,
                        minWindowDensity: null,
                        totalCurrency: null,
                        globalSlotSinceGenesis: null,
                        stakingEpochData: null,
                        nextEpochData: null
                      }
                    },
                    account: {
                      type: "object",
                      name: "AccountPrecondition",
                      docs: null,
                      keys: [
                        "balance",
                        "nonce",
                        "receiptChainHash",
                        "delegate",
                        "state",
                        "actionState",
                        "provedState",
                        "isNew"
                      ],
                      entries: {
                        balance: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "18446744073709551615",
                          inner: {
                            type: "object",
                            name: "BalanceInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt64" },
                              upper: { type: "UInt64" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        nonce: {
                          type: "option",
                          optionType: "closedInterval",
                          rangeMin: "0",
                          rangeMax: "4294967295",
                          inner: {
                            type: "object",
                            name: "NonceInterval",
                            docs: null,
                            keys: ["lower", "upper"],
                            entries: {
                              lower: { type: "UInt32" },
                              upper: { type: "UInt32" }
                            },
                            docEntries: { lower: null, upper: null }
                          }
                        },
                        receiptChainHash: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Field" }
                        },
                        delegate: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "PublicKey" }
                        },
                        state: {
                          type: "array",
                          inner: {
                            type: "option",
                            optionType: "flaggedOption",
                            inner: { type: "Field" }
                          },
                          staticLength: 8
                        },
                        actionState: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: {
                            type: "Field",
                            checkedType: { type: "Field" },
                            checkedTypeName: "ActionState"
                          }
                        },
                        provedState: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Bool" }
                        },
                        isNew: {
                          type: "option",
                          optionType: "flaggedOption",
                          inner: { type: "Bool" }
                        }
                      },
                      docEntries: {
                        balance: null,
                        nonce: null,
                        receiptChainHash: null,
                        delegate: null,
                        state: null,
                        actionState: null,
                        provedState: null,
                        isNew: null
                      }
                    },
                    validWhile: {
                      type: "option",
                      optionType: "closedInterval",
                      rangeMin: "0",
                      rangeMax: "4294967295",
                      inner: {
                        type: "object",
                        name: "GlobalSlotInterval",
                        docs: null,
                        keys: ["lower", "upper"],
                        entries: {
                          lower: { type: "UInt32" },
                          upper: { type: "UInt32" }
                        },
                        docEntries: { lower: null, upper: null }
                      }
                    }
                  },
                  docEntries: {
                    network: null,
                    account: null,
                    validWhile: null
                  }
                },
                useFullCommitment: { type: "Bool" },
                implicitAccountCreationFee: { type: "Bool" },
                mayUseToken: {
                  type: "object",
                  name: "MayUseToken",
                  docs: null,
                  keys: ["parentsOwnToken", "inheritFromParent"],
                  entries: {
                    parentsOwnToken: { type: "Bool" },
                    inheritFromParent: { type: "Bool" }
                  },
                  docEntries: {
                    parentsOwnToken: null,
                    inheritFromParent: null
                  }
                },
                authorizationKind: {
                  type: "object",
                  name: "AuthorizationKindStructured",
                  docs: null,
                  keys: ["isSigned", "isProved", "verificationKeyHash"],
                  entries: {
                    isSigned: { type: "Bool" },
                    isProved: { type: "Bool" },
                    verificationKeyHash: { type: "Field" }
                  },
                  docEntries: {
                    isSigned: null,
                    isProved: null,
                    verificationKeyHash: null
                  }
                }
              },
              docEntries: {
                publicKey: null,
                tokenId: null,
                update: null,
                balanceChange: null,
                incrementNonce: null,
                events: null,
                actions: null,
                callData: null,
                callDepth: null,
                preconditions: null,
                useFullCommitment: null,
                implicitAccountCreationFee: null,
                mayUseToken: null,
                authorizationKind: null
              }
            },
            authorization: {
              type: "object",
              name: "Control",
              docs: null,
              keys: ["proof", "signature"],
              entries: {
                proof: {
                  type: "option",
                  optionType: "orUndefined",
                  inner: { type: "string" }
                },
                signature: {
                  type: "option",
                  optionType: "orUndefined",
                  inner: { type: "string" }
                }
              },
              docEntries: { proof: null, signature: null }
            }
          },
          docEntries: { body: null, authorization: null }
        },
        staticLength: null
      },
      memo: { type: "string" }
    },
    docEntries: { feePayer: null, accountUpdates: null, memo: null }
  },
  AccountUpdate: {
    type: "object",
    name: "ZkappAccountUpdate",
    docs: "An account update in a zkApp transaction",
    keys: ["body", "authorization"],
    entries: {
      body: {
        type: "object",
        name: "AccountUpdateBody",
        docs: null,
        keys: [
          "publicKey",
          "tokenId",
          "update",
          "balanceChange",
          "incrementNonce",
          "events",
          "actions",
          "callData",
          "callDepth",
          "preconditions",
          "useFullCommitment",
          "implicitAccountCreationFee",
          "mayUseToken",
          "authorizationKind"
        ],
        entries: {
          publicKey: { type: "PublicKey" },
          tokenId: { type: "TokenId" },
          update: {
            type: "object",
            name: "AccountUpdateModification",
            docs: null,
            keys: [
              "appState",
              "delegate",
              "verificationKey",
              "permissions",
              "zkappUri",
              "tokenSymbol",
              "timing",
              "votingFor"
            ],
            entries: {
              appState: {
                type: "array",
                inner: {
                  type: "option",
                  optionType: "flaggedOption",
                  inner: { type: "Field" }
                },
                staticLength: 8
              },
              delegate: {
                type: "option",
                optionType: "flaggedOption",
                inner: { type: "PublicKey" }
              },
              verificationKey: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "object",
                  name: "VerificationKeyWithHash",
                  docs: null,
                  keys: ["data", "hash"],
                  entries: {
                    data: { type: "string" },
                    hash: { type: "Field" }
                  },
                  docEntries: { data: null, hash: null }
                }
              },
              permissions: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "object",
                  name: "Permissions",
                  docs: null,
                  keys: [
                    "editState",
                    "access",
                    "send",
                    "receive",
                    "setDelegate",
                    "setPermissions",
                    "setVerificationKey",
                    "setZkappUri",
                    "editActionState",
                    "setTokenSymbol",
                    "incrementNonce",
                    "setVotingFor",
                    "setTiming"
                  ],
                  entries: {
                    editState: { type: "AuthRequired" },
                    access: { type: "AuthRequired" },
                    send: { type: "AuthRequired" },
                    receive: { type: "AuthRequired" },
                    setDelegate: { type: "AuthRequired" },
                    setPermissions: { type: "AuthRequired" },
                    setVerificationKey: { type: "AuthRequired" },
                    setZkappUri: { type: "AuthRequired" },
                    editActionState: { type: "AuthRequired" },
                    setTokenSymbol: { type: "AuthRequired" },
                    incrementNonce: { type: "AuthRequired" },
                    setVotingFor: { type: "AuthRequired" },
                    setTiming: { type: "AuthRequired" }
                  },
                  docEntries: {
                    editState: null,
                    access: null,
                    send: null,
                    receive: null,
                    setDelegate: null,
                    setPermissions: null,
                    setVerificationKey: null,
                    setZkappUri: null,
                    editActionState: null,
                    setTokenSymbol: null,
                    incrementNonce: null,
                    setVotingFor: null,
                    setTiming: null
                  }
                }
              },
              zkappUri: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "string",
                  checkedType: {
                    type: "object",
                    name: "Events",
                    docs: null,
                    keys: ["data", "hash"],
                    entries: {
                      data: { type: "string" },
                      hash: { type: "Field" }
                    },
                    docEntries: { data: null, hash: null }
                  },
                  checkedTypeName: "ZkappUri"
                }
              },
              tokenSymbol: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "string",
                  checkedType: {
                    type: "object",
                    name: "Anonymous",
                    docs: null,
                    keys: ["symbol", "field"],
                    entries: {
                      symbol: { type: "string" },
                      field: { type: "Field" }
                    },
                    docEntries: { symbol: "", field: "" }
                  },
                  checkedTypeName: "TokenSymbol"
                }
              },
              timing: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "object",
                  name: "Timing",
                  docs: null,
                  keys: [
                    "initialMinimumBalance",
                    "cliffTime",
                    "cliffAmount",
                    "vestingPeriod",
                    "vestingIncrement"
                  ],
                  entries: {
                    initialMinimumBalance: { type: "UInt64" },
                    cliffTime: { type: "UInt32" },
                    cliffAmount: { type: "UInt64" },
                    vestingPeriod: { type: "UInt32" },
                    vestingIncrement: { type: "UInt64" }
                  },
                  docEntries: {
                    initialMinimumBalance: null,
                    cliffTime: null,
                    cliffAmount: null,
                    vestingPeriod: null,
                    vestingIncrement: null
                  }
                }
              },
              votingFor: {
                type: "option",
                optionType: "flaggedOption",
                inner: {
                  type: "Field",
                  checkedType: { type: "Field" },
                  checkedTypeName: "StateHash"
                }
              }
            },
            docEntries: {
              appState: null,
              delegate: null,
              verificationKey: null,
              permissions: null,
              zkappUri: null,
              tokenSymbol: null,
              timing: null,
              votingFor: null
            }
          },
          balanceChange: {
            type: "object",
            name: "BalanceChange",
            docs: null,
            keys: ["magnitude", "sgn"],
            entries: { magnitude: { type: "UInt64" }, sgn: { type: "Sign" } },
            docEntries: { magnitude: null, sgn: null }
          },
          incrementNonce: { type: "Bool" },
          events: {
            type: "array",
            inner: {
              type: "array",
              inner: { type: "Field" },
              staticLength: null
            },
            staticLength: null,
            checkedType: {
              type: "object",
              name: "Events",
              docs: null,
              keys: ["data", "hash"],
              entries: {
                data: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null
                },
                hash: { type: "Field" }
              },
              docEntries: { data: null, hash: null }
            },
            checkedTypeName: "Events"
          },
          actions: {
            type: "array",
            inner: {
              type: "array",
              inner: { type: "Field" },
              staticLength: null
            },
            staticLength: null,
            checkedType: {
              type: "object",
              name: "Events",
              docs: null,
              keys: ["data", "hash"],
              entries: {
                data: {
                  type: "array",
                  inner: {
                    type: "array",
                    inner: { type: "Field" },
                    staticLength: null
                  },
                  staticLength: null
                },
                hash: { type: "Field" }
              },
              docEntries: { data: null, hash: null }
            },
            checkedTypeName: "Actions"
          },
          callData: { type: "Field" },
          callDepth: { type: "number" },
          preconditions: {
            type: "object",
            name: "Preconditions",
            docs: null,
            keys: ["network", "account", "validWhile"],
            entries: {
              network: {
                type: "object",
                name: "NetworkPrecondition",
                docs: null,
                keys: [
                  "snarkedLedgerHash",
                  "blockchainLength",
                  "minWindowDensity",
                  "totalCurrency",
                  "globalSlotSinceGenesis",
                  "stakingEpochData",
                  "nextEpochData"
                ],
                entries: {
                  snarkedLedgerHash: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Field" }
                  },
                  blockchainLength: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "LengthInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  minWindowDensity: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "LengthInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  totalCurrency: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "18446744073709551615",
                    inner: {
                      type: "object",
                      name: "CurrencyAmountInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt64" },
                        upper: { type: "UInt64" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  globalSlotSinceGenesis: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "GlobalSlotInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  stakingEpochData: {
                    type: "object",
                    name: "EpochDataPrecondition",
                    docs: null,
                    keys: [
                      "ledger",
                      "seed",
                      "startCheckpoint",
                      "lockCheckpoint",
                      "epochLength"
                    ],
                    entries: {
                      ledger: {
                        type: "object",
                        name: "EpochLedgerPrecondition",
                        docs: null,
                        keys: ["hash", "totalCurrency"],
                        entries: {
                          hash: {
                            type: "option",
                            optionType: "flaggedOption",
                            inner: { type: "Field" }
                          },
                          totalCurrency: {
                            type: "option",
                            optionType: "closedInterval",
                            rangeMin: "0",
                            rangeMax: "18446744073709551615",
                            inner: {
                              type: "object",
                              name: "CurrencyAmountInterval",
                              docs: null,
                              keys: ["lower", "upper"],
                              entries: {
                                lower: { type: "UInt64" },
                                upper: { type: "UInt64" }
                              },
                              docEntries: { lower: null, upper: null }
                            }
                          }
                        },
                        docEntries: { hash: null, totalCurrency: null }
                      },
                      seed: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      startCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      lockCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      epochLength: {
                        type: "option",
                        optionType: "closedInterval",
                        rangeMin: "0",
                        rangeMax: "4294967295",
                        inner: {
                          type: "object",
                          name: "LengthInterval",
                          docs: null,
                          keys: ["lower", "upper"],
                          entries: {
                            lower: { type: "UInt32" },
                            upper: { type: "UInt32" }
                          },
                          docEntries: { lower: null, upper: null }
                        }
                      }
                    },
                    docEntries: {
                      ledger: null,
                      seed: null,
                      startCheckpoint: null,
                      lockCheckpoint: null,
                      epochLength: null
                    }
                  },
                  nextEpochData: {
                    type: "object",
                    name: "EpochDataPrecondition",
                    docs: null,
                    keys: [
                      "ledger",
                      "seed",
                      "startCheckpoint",
                      "lockCheckpoint",
                      "epochLength"
                    ],
                    entries: {
                      ledger: {
                        type: "object",
                        name: "EpochLedgerPrecondition",
                        docs: null,
                        keys: ["hash", "totalCurrency"],
                        entries: {
                          hash: {
                            type: "option",
                            optionType: "flaggedOption",
                            inner: { type: "Field" }
                          },
                          totalCurrency: {
                            type: "option",
                            optionType: "closedInterval",
                            rangeMin: "0",
                            rangeMax: "18446744073709551615",
                            inner: {
                              type: "object",
                              name: "CurrencyAmountInterval",
                              docs: null,
                              keys: ["lower", "upper"],
                              entries: {
                                lower: { type: "UInt64" },
                                upper: { type: "UInt64" }
                              },
                              docEntries: { lower: null, upper: null }
                            }
                          }
                        },
                        docEntries: { hash: null, totalCurrency: null }
                      },
                      seed: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      startCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      lockCheckpoint: {
                        type: "option",
                        optionType: "flaggedOption",
                        inner: { type: "Field" }
                      },
                      epochLength: {
                        type: "option",
                        optionType: "closedInterval",
                        rangeMin: "0",
                        rangeMax: "4294967295",
                        inner: {
                          type: "object",
                          name: "LengthInterval",
                          docs: null,
                          keys: ["lower", "upper"],
                          entries: {
                            lower: { type: "UInt32" },
                            upper: { type: "UInt32" }
                          },
                          docEntries: { lower: null, upper: null }
                        }
                      }
                    },
                    docEntries: {
                      ledger: null,
                      seed: null,
                      startCheckpoint: null,
                      lockCheckpoint: null,
                      epochLength: null
                    }
                  }
                },
                docEntries: {
                  snarkedLedgerHash: null,
                  blockchainLength: null,
                  minWindowDensity: null,
                  totalCurrency: null,
                  globalSlotSinceGenesis: null,
                  stakingEpochData: null,
                  nextEpochData: null
                }
              },
              account: {
                type: "object",
                name: "AccountPrecondition",
                docs: null,
                keys: [
                  "balance",
                  "nonce",
                  "receiptChainHash",
                  "delegate",
                  "state",
                  "actionState",
                  "provedState",
                  "isNew"
                ],
                entries: {
                  balance: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "18446744073709551615",
                    inner: {
                      type: "object",
                      name: "BalanceInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt64" },
                        upper: { type: "UInt64" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  nonce: {
                    type: "option",
                    optionType: "closedInterval",
                    rangeMin: "0",
                    rangeMax: "4294967295",
                    inner: {
                      type: "object",
                      name: "NonceInterval",
                      docs: null,
                      keys: ["lower", "upper"],
                      entries: {
                        lower: { type: "UInt32" },
                        upper: { type: "UInt32" }
                      },
                      docEntries: { lower: null, upper: null }
                    }
                  },
                  receiptChainHash: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Field" }
                  },
                  delegate: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "PublicKey" }
                  },
                  state: {
                    type: "array",
                    inner: {
                      type: "option",
                      optionType: "flaggedOption",
                      inner: { type: "Field" }
                    },
                    staticLength: 8
                  },
                  actionState: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: {
                      type: "Field",
                      checkedType: { type: "Field" },
                      checkedTypeName: "ActionState"
                    }
                  },
                  provedState: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Bool" }
                  },
                  isNew: {
                    type: "option",
                    optionType: "flaggedOption",
                    inner: { type: "Bool" }
                  }
                },
                docEntries: {
                  balance: null,
                  nonce: null,
                  receiptChainHash: null,
                  delegate: null,
                  state: null,
                  actionState: null,
                  provedState: null,
                  isNew: null
                }
              },
              validWhile: {
                type: "option",
                optionType: "closedInterval",
                rangeMin: "0",
                rangeMax: "4294967295",
                inner: {
                  type: "object",
                  name: "GlobalSlotInterval",
                  docs: null,
                  keys: ["lower", "upper"],
                  entries: {
                    lower: { type: "UInt32" },
                    upper: { type: "UInt32" }
                  },
                  docEntries: { lower: null, upper: null }
                }
              }
            },
            docEntries: { network: null, account: null, validWhile: null }
          },
          useFullCommitment: { type: "Bool" },
          implicitAccountCreationFee: { type: "Bool" },
          mayUseToken: {
            type: "object",
            name: "MayUseToken",
            docs: null,
            keys: ["parentsOwnToken", "inheritFromParent"],
            entries: {
              parentsOwnToken: { type: "Bool" },
              inheritFromParent: { type: "Bool" }
            },
            docEntries: { parentsOwnToken: null, inheritFromParent: null }
          },
          authorizationKind: {
            type: "object",
            name: "AuthorizationKindStructured",
            docs: null,
            keys: ["isSigned", "isProved", "verificationKeyHash"],
            entries: {
              isSigned: { type: "Bool" },
              isProved: { type: "Bool" },
              verificationKeyHash: { type: "Field" }
            },
            docEntries: {
              isSigned: null,
              isProved: null,
              verificationKeyHash: null
            }
          }
        },
        docEntries: {
          publicKey: null,
          tokenId: null,
          update: null,
          balanceChange: null,
          incrementNonce: null,
          events: null,
          actions: null,
          callData: null,
          callDepth: null,
          preconditions: null,
          useFullCommitment: null,
          implicitAccountCreationFee: null,
          mayUseToken: null,
          authorizationKind: null
        }
      },
      authorization: {
        type: "object",
        name: "Control",
        docs: null,
        keys: ["proof", "signature"],
        entries: {
          proof: {
            type: "option",
            optionType: "orUndefined",
            inner: { type: "string" }
          },
          signature: {
            type: "option",
            optionType: "orUndefined",
            inner: { type: "string" }
          }
        },
        docEntries: { proof: null, signature: null }
      }
    },
    docEntries: { body: null, authorization: null }
  },
  Account: {
    type: "object",
    name: "Account",
    docs: null,
    keys: [
      "publicKey",
      "tokenId",
      "tokenSymbol",
      "balance",
      "nonce",
      "receiptChainHash",
      "delegate",
      "votingFor",
      "timing",
      "permissions",
      "zkapp"
    ],
    entries: {
      publicKey: { type: "PublicKey" },
      tokenId: { type: "TokenId" },
      tokenSymbol: { type: "string" },
      balance: { type: "UInt64" },
      nonce: { type: "UInt32" },
      receiptChainHash: {
        type: "Field",
        checkedType: { type: "Field" },
        checkedTypeName: "ReceiptChainHash"
      },
      delegate: {
        type: "option",
        optionType: "orUndefined",
        inner: { type: "PublicKey" }
      },
      votingFor: { type: "Field" },
      timing: {
        type: "object",
        name: "AccountTiming",
        docs: null,
        keys: [
          "isTimed",
          "initialMinimumBalance",
          "cliffTime",
          "cliffAmount",
          "vestingPeriod",
          "vestingIncrement"
        ],
        entries: {
          isTimed: { type: "Bool" },
          initialMinimumBalance: { type: "UInt64" },
          cliffTime: { type: "UInt32" },
          cliffAmount: { type: "UInt64" },
          vestingPeriod: { type: "UInt32" },
          vestingIncrement: { type: "UInt64" }
        },
        docEntries: {
          isTimed: null,
          initialMinimumBalance: null,
          cliffTime: null,
          cliffAmount: null,
          vestingPeriod: null,
          vestingIncrement: null
        }
      },
      permissions: {
        type: "object",
        name: "Permissions",
        docs: null,
        keys: [
          "editState",
          "access",
          "send",
          "receive",
          "setDelegate",
          "setPermissions",
          "setVerificationKey",
          "setZkappUri",
          "editActionState",
          "setTokenSymbol",
          "incrementNonce",
          "setVotingFor",
          "setTiming"
        ],
        entries: {
          editState: { type: "AuthRequired" },
          access: { type: "AuthRequired" },
          send: { type: "AuthRequired" },
          receive: { type: "AuthRequired" },
          setDelegate: { type: "AuthRequired" },
          setPermissions: { type: "AuthRequired" },
          setVerificationKey: { type: "AuthRequired" },
          setZkappUri: { type: "AuthRequired" },
          editActionState: { type: "AuthRequired" },
          setTokenSymbol: { type: "AuthRequired" },
          incrementNonce: { type: "AuthRequired" },
          setVotingFor: { type: "AuthRequired" },
          setTiming: { type: "AuthRequired" }
        },
        docEntries: {
          editState: null,
          access: null,
          send: null,
          receive: null,
          setDelegate: null,
          setPermissions: null,
          setVerificationKey: null,
          setZkappUri: null,
          editActionState: null,
          setTokenSymbol: null,
          incrementNonce: null,
          setVotingFor: null,
          setTiming: null
        }
      },
      zkapp: {
        type: "option",
        optionType: "orUndefined",
        inner: {
          type: "object",
          name: "ZkappAccount",
          docs: null,
          keys: [
            "appState",
            "verificationKey",
            "zkappVersion",
            "actionState",
            "lastActionSlot",
            "provedState",
            "zkappUri"
          ],
          entries: {
            appState: {
              type: "array",
              inner: { type: "Field" },
              staticLength: 8
            },
            verificationKey: {
              type: "option",
              optionType: "orUndefined",
              inner: {
                type: "object",
                name: "VerificationKeyWithHash",
                docs: null,
                keys: ["data", "hash"],
                entries: { data: { type: "string" }, hash: { type: "Field" } },
                docEntries: { data: null, hash: null }
              }
            },
            zkappVersion: { type: "UInt32" },
            actionState: {
              type: "array",
              inner: { type: "Field" },
              staticLength: 5
            },
            lastActionSlot: { type: "UInt32" },
            provedState: { type: "Bool" },
            zkappUri: { type: "string" }
          },
          docEntries: {
            appState: null,
            verificationKey: null,
            zkappVersion: null,
            actionState: null,
            lastActionSlot: null,
            provedState: null,
            zkappUri: null
          }
        }
      }
    },
    docEntries: {
      publicKey: null,
      tokenId: null,
      tokenSymbol: null,
      balance: null,
      nonce: null,
      receiptChainHash: null,
      delegate: null,
      votingFor: null,
      timing: null,
      permissions: null,
      zkapp: null
    }
  }
};

// dist/node/provable/gen/transaction.js
var TypeMap = {
  PublicKey: PublicKey2,
  UInt64: UInt642,
  UInt32: UInt322,
  TokenId,
  Field,
  Bool,
  AuthRequired,
  Sign: Sign3
};
var customTypes = {
  ZkappUri,
  TokenSymbol: TokenSymbol2,
  StateHash,
  Events,
  Actions,
  ActionState,
  ReceiptChainHash
};
var { provableFromLayout, toJSONEssential, emptyValue: emptyValue2 } = ProvableFromLayout(TypeMap, customTypes);
var ZkappCommand = provableFromLayout(jsLayout.ZkappCommand);
var AccountUpdate = provableFromLayout(jsLayout.AccountUpdate);
var Account = provableFromLayout(jsLayout.Account);

// dist/node/lib/mina.js
var mina_exports = {};
__export(mina_exports, {
  BerkeleyQANet: () => BerkeleyQANet,
  LocalBlockchain: () => LocalBlockchain,
  Network: () => Network2,
  Transaction: () => Transaction,
  accountCreationFee: () => accountCreationFee,
  activeInstance: () => activeInstance,
  createTransaction: () => createTransaction,
  currentSlot: () => currentSlot,
  currentTransaction: () => currentTransaction,
  faucet: () => faucet,
  fetchActions: () => fetchActions2,
  fetchEvents: () => fetchEvents2,
  filterGroups: () => filterGroups,
  getAccount: () => getAccount,
  getActions: () => getActions,
  getBalance: () => getBalance,
  getNetworkState: () => getNetworkState,
  getProofsEnabled: () => getProofsEnabled,
  hasAccount: () => hasAccount,
  sendTransaction: () => sendTransaction,
  sender: () => sender,
  setActiveInstance: () => setActiveInstance,
  transaction: () => transaction,
  waitForFunding: () => waitForFunding
});

// dist/node/lib/zkapp.js
var import_tslib3 = require("tslib");

// dist/node/lib/encoding.js
var encoding_exports = {};
__export(encoding_exports, {
  Bijective: () => Bijective,
  EpochSeed: () => EpochSeed,
  LedgerHash: () => LedgerHash,
  ReceiptChainHash: () => ReceiptChainHash2,
  StateHash: () => StateHash2,
  TokenId: () => TokenId2,
  bytesFromFields: () => bytesFromFields,
  bytesToFields: () => bytesToFields,
  stringFromFields: () => stringFromFields,
  stringToFields: () => stringToFields
});
var { TokenId: TokenId2, ReceiptChainHash: ReceiptChainHash2, EpochSeed, LedgerHash, StateHash: StateHash2 } = fieldEncodings(Field);
function stringToFields(message) {
  let bytes = new TextEncoder().encode(message);
  return bytesToFields(bytes);
}
function stringFromFields(fields) {
  let bytes = bytesFromFields(fields);
  return new TextDecoder().decode(bytes);
}
var STOP = 1;
function bytesToFields(bytes) {
  let fields = [];
  let currentBigInt = 0n;
  let bitPosition = 0n;
  for (let byte of bytes) {
    currentBigInt += BigInt(byte) << bitPosition;
    bitPosition += 8n;
    if (bitPosition === 248n) {
      fields.push(Field(currentBigInt.toString()));
      currentBigInt = 0n;
      bitPosition = 0n;
    }
  }
  currentBigInt += BigInt(STOP) << bitPosition;
  fields.push(Field(currentBigInt.toString()));
  return fields;
}
function bytesFromFields(fields) {
  let lastChunk = fields.pop();
  if (lastChunk === void 0)
    return new Uint8Array();
  let lastChunkBytes = bytesOfConstantField(lastChunk);
  let i2 = lastChunkBytes.lastIndexOf(STOP, 30);
  if (i2 === -1)
    throw Error("Error (bytesFromFields): Invalid encoding.");
  let bytes = new Uint8Array(fields.length * 31 + i2);
  bytes.set(lastChunkBytes.subarray(0, i2), fields.length * 31);
  i2 = 0;
  for (let field of fields) {
    bytes.set(bytesOfConstantField(field).subarray(0, 31), i2);
    i2 += 31;
  }
  fields.push(lastChunk);
  return bytes;
}
var p2 = 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001n;
var q2 = 0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001n;
var bytesPerBigInt = 32;
var bytesBase = 256n ** BigInt(bytesPerBigInt);
var Bijective = {
  Fp: {
    toBytes: (fields) => toBytesBijective(fields, p2),
    fromBytes: (bytes) => toFieldsBijective(bytes, p2),
    toString(fields) {
      return new TextDecoder().decode(toBytesBijective(fields, p2));
    },
    fromString(message) {
      let bytes = new TextEncoder().encode(message);
      return toFieldsBijective(bytes, p2);
    }
  },
  Fq: {
    toBytes: (fields) => toBytesBijective(fields, q2),
    fromBytes: (bytes) => toFieldsBijective(bytes, q2),
    toString(fields) {
      return new TextDecoder().decode(toBytesBijective(fields, q2));
    },
    fromString(message) {
      let bytes = new TextEncoder().encode(message);
      return toFieldsBijective(bytes, q2);
    }
  }
};
function toBytesBijective(fields, p3) {
  let fieldsBigInts = fields.map(fieldToBigInt);
  let bytesBig = changeBase(fieldsBigInts, p3, bytesBase);
  let bytes = bigIntArrayToBytes(bytesBig, bytesPerBigInt);
  return bytes;
}
function toFieldsBijective(bytes, p3) {
  let bytesBig = bytesToBigIntArray(bytes, bytesPerBigInt);
  let fieldsBigInts = changeBase(bytesBig, bytesBase, p3);
  let fields = fieldsBigInts.map(bigIntToField);
  return fields;
}
function bytesOfConstantField(field) {
  let value = field.value;
  if (value[0] !== 0)
    throw Error("Field is not constant");
  return value[1];
}
function fieldToBigInt(field) {
  let bytes = bytesOfConstantField(field);
  return bytesToBigInt(bytes);
}
function bigIntToField(x) {
  let field = Field(1);
  field.value = [0, bigIntToBytes2(x, 32)];
  return field;
}
function bigIntToBytes2(x, length) {
  let bytes = [];
  for (; x > 0; x >>= 8n) {
    bytes.push(Number(x & 0xffn));
  }
  let array = new Uint8Array(bytes);
  if (length === void 0)
    return array;
  if (array.length > length)
    throw Error(`bigint doesn't fit into ${length} bytes.`);
  let sizedArray = new Uint8Array(length);
  sizedArray.set(array);
  return sizedArray;
}
function bytesToBigIntArray(bytes, bytesPerBigInt2) {
  let bigints = [];
  for (let i2 = 0; i2 < bytes.byteLength; i2 += bytesPerBigInt2) {
    bigints.push(bytesToBigInt(bytes.subarray(i2, i2 + bytesPerBigInt2)));
  }
  return bigints;
}
function bigIntArrayToBytes(bigints, bytesPerBigInt2) {
  let bytes = new Uint8Array(bigints.length * bytesPerBigInt2);
  let offset = 0;
  for (let b2 of bigints) {
    bytes.set(bigIntToBytes2(b2, bytesPerBigInt2), offset);
    offset += bytesPerBigInt2;
  }
  let i2 = bytes.byteLength - 1;
  for (; i2 >= 0; i2--) {
    if (bytes[i2] !== 0)
      break;
  }
  return bytes.slice(0, i2 + 1);
}

// dist/node/lib/precondition.js
function preconditions(accountUpdate, isSelf) {
  initializePreconditions(accountUpdate, isSelf);
  return {
    account: Account2(accountUpdate),
    network: Network(accountUpdate),
    currentSlot: CurrentSlot(accountUpdate)
  };
}
function Network(accountUpdate) {
  let layout = jsLayout.AccountUpdate.entries.body.entries.preconditions.entries.network;
  let context = getPreconditionContextExn(accountUpdate);
  let network = preconditionClass(layout, "network", accountUpdate, context);
  let timestamp = {
    get() {
      let slot = network.globalSlotSinceGenesis.get();
      return globalSlotToTimestamp(slot);
    },
    assertEquals(value) {
      let { genesisTimestamp, slotTime } = activeInstance.getNetworkConstants();
      let slot = timestampToGlobalSlot(value, `Timestamp precondition unsatisfied: the timestamp can only equal numbers of the form ${genesisTimestamp} + k*${slotTime},
i.e., the genesis timestamp plus an integer number of slots.`);
      return network.globalSlotSinceGenesis.assertEquals(slot);
    },
    assertBetween(lower, upper) {
      let [slotLower, slotUpper] = timestampToGlobalSlotRange(lower, upper);
      return network.globalSlotSinceGenesis.assertBetween(slotLower, slotUpper);
    },
    assertNothing() {
      return network.globalSlotSinceGenesis.assertNothing();
    }
  };
  return { ...network, timestamp };
}
function Account2(accountUpdate) {
  let layout = jsLayout.AccountUpdate.entries.body.entries.preconditions.entries.account;
  let context = getPreconditionContextExn(accountUpdate);
  let identity = (x) => x;
  let update = {
    delegate: {
      ...preconditionSubclass(accountUpdate, "account.delegate", PublicKey2, context),
      ...updateSubclass(accountUpdate, "delegate", identity)
    },
    verificationKey: updateSubclass(accountUpdate, "verificationKey", identity),
    permissions: updateSubclass(accountUpdate, "permissions", identity),
    zkappUri: updateSubclass(accountUpdate, "zkappUri", ZkappUri.fromJSON),
    tokenSymbol: updateSubclass(accountUpdate, "tokenSymbol", TokenSymbol.from),
    timing: updateSubclass(accountUpdate, "timing", identity),
    votingFor: updateSubclass(accountUpdate, "votingFor", identity)
  };
  return {
    ...preconditionClass(layout, "account", accountUpdate, context),
    ...update
  };
}
function updateSubclass(accountUpdate, key, transform) {
  return {
    set(value) {
      accountUpdate.body.update[key].isSome = Bool(true);
      accountUpdate.body.update[key].value = transform(value);
    }
  };
}
function CurrentSlot(accountUpdate) {
  let context = getPreconditionContextExn(accountUpdate);
  return {
    assertBetween(lower, upper) {
      context.constrained.add("validWhile");
      let property = accountUpdate.body.preconditions.validWhile;
      property.isSome = Bool(true);
      property.value.lower = lower;
      property.value.upper = upper;
    }
  };
}
var unimplementedPreconditions = [
  // unimplemented because its not checked in the protocol
  "network.stakingEpochData.seed",
  "network.nextEpochData.seed"
];
var baseMap = { UInt64: UInt642, UInt32: UInt322, Field, Bool, PublicKey: PublicKey2 };
function preconditionClass(layout, baseKey, accountUpdate, context) {
  if (layout.type === "option") {
    if (layout.optionType === "closedInterval") {
      let lower = layout.inner.entries.lower.type;
      let baseType = baseMap[lower];
      return preconditionSubClassWithRange(accountUpdate, baseKey, baseType, context);
    } else if (layout.optionType === "flaggedOption") {
      let baseType = baseMap[layout.inner.type];
      return preconditionSubclass(accountUpdate, baseKey, baseType, context);
    }
  } else if (layout.type === "array") {
    return {};
  } else if (layout.type === "object") {
    return Object.fromEntries(layout.keys.map((key) => {
      let value = layout.entries[key];
      return [
        key,
        preconditionClass(value, `${baseKey}.${key}`, accountUpdate, context)
      ];
    }));
  } else
    throw Error("bug");
}
function preconditionSubClassWithRange(accountUpdate, longKey, fieldType, context) {
  return {
    ...preconditionSubclass(accountUpdate, longKey, fieldType, context),
    assertBetween(lower, upper) {
      context.constrained.add(longKey);
      let property = getPath(accountUpdate.body.preconditions, longKey);
      property.isSome = Bool(true);
      property.value.lower = lower;
      property.value.upper = upper;
    }
  };
}
function preconditionSubclass(accountUpdate, longKey, fieldType, context) {
  if (fieldType === void 0) {
    throw Error(`this.${longKey}: fieldType undefined`);
  }
  return {
    get() {
      if (unimplementedPreconditions.includes(longKey)) {
        let self = context.isSelf ? "this" : "accountUpdate";
        throw Error(`${self}.${longKey}.get() is not implemented yet.`);
      }
      let { read, vars } = context;
      read.add(longKey);
      return vars[longKey] ?? (vars[longKey] = getVariable(accountUpdate, longKey, fieldType));
    },
    assertEquals(value) {
      context.constrained.add(longKey);
      let property = getPath(accountUpdate.body.preconditions, longKey);
      if ("isSome" in property) {
        property.isSome = Bool(true);
        if ("lower" in property.value && "upper" in property.value) {
          property.value.lower = value;
          property.value.upper = value;
        } else {
          property.value = value;
        }
      } else {
        setPath(accountUpdate.body.preconditions, longKey, value);
      }
    },
    assertNothing() {
      context.constrained.add(longKey);
    }
  };
}
function getVariable(accountUpdate, longKey, fieldType) {
  return Circuit.witness(fieldType, () => {
    let [accountOrNetwork, ...rest] = longKey.split(".");
    let key = rest.join(".");
    let value;
    if (accountOrNetwork === "account") {
      let account = getAccountPreconditions(accountUpdate.body);
      value = account[key];
    } else if (accountOrNetwork === "network") {
      let networkState = getNetworkState();
      value = getPath(networkState, key);
    } else if (accountOrNetwork === "validWhile") {
      let networkState = getNetworkState();
      value = networkState.globalSlotSinceGenesis;
    } else {
      throw Error("impossible");
    }
    return value;
  });
}
function globalSlotToTimestamp(slot) {
  let { genesisTimestamp, slotTime } = activeInstance.getNetworkConstants();
  return UInt642.from(slot).mul(slotTime).add(genesisTimestamp);
}
function timestampToGlobalSlot(timestamp, message) {
  let { genesisTimestamp, slotTime } = activeInstance.getNetworkConstants();
  let { quotient: slot, rest } = timestamp.sub(genesisTimestamp).divMod(slotTime);
  rest.value.assertEquals(Field(0), message);
  return slot.toUInt32();
}
function timestampToGlobalSlotRange(tsLower, tsUpper) {
  let { genesisTimestamp, slotTime } = activeInstance.getNetworkConstants();
  let tsLowerInt = Int64.from(tsLower).sub(genesisTimestamp).add(slotTime).sub(1);
  let lowerCapped = Circuit.if(tsLowerInt.isPositive(), UInt642, tsLowerInt.magnitude, UInt642.from(0));
  let slotLower = lowerCapped.div(slotTime).toUInt32Clamped();
  let slotUpper = tsUpper.sub(genesisTimestamp).div(slotTime).toUInt32Clamped();
  return [slotLower, slotUpper];
}
function getAccountPreconditions(body) {
  let { publicKey, tokenId } = body;
  let hasAccount2 = hasAccount(publicKey, tokenId);
  if (!hasAccount2) {
    return {
      balance: UInt642.zero,
      nonce: UInt322.zero,
      receiptChainHash: emptyReceiptChainHash(),
      actionState: Actions.emptyActionState(),
      delegate: publicKey,
      provedState: Bool(false),
      isNew: Bool(true)
    };
  }
  let account = getAccount(publicKey, tokenId);
  return {
    balance: account.balance,
    nonce: account.nonce,
    receiptChainHash: account.receiptChainHash,
    actionState: account.zkapp?.actionState?.[0] ?? Actions.emptyActionState(),
    delegate: account.delegate ?? account.publicKey,
    provedState: account.zkapp?.provedState ?? Bool(false),
    isNew: Bool(false)
  };
}
function initializePreconditions(accountUpdate, isSelf) {
  preconditionContexts.set(accountUpdate, {
    read: /* @__PURE__ */ new Set(),
    constrained: /* @__PURE__ */ new Set(),
    vars: {},
    isSelf
  });
}
function cleanPreconditionsCache(accountUpdate) {
  let context = preconditionContexts.get(accountUpdate);
  if (context !== void 0)
    context.vars = {};
}
function assertPreconditionInvariants(accountUpdate) {
  let context = getPreconditionContextExn(accountUpdate);
  let self = context.isSelf ? "this" : "accountUpdate";
  let dummyPreconditions = Preconditions.ignoreAll();
  for (let preconditionPath of context.read) {
    if (context.constrained.has(preconditionPath))
      continue;
    let precondition = getPath(accountUpdate.body.preconditions, preconditionPath);
    let dummy = getPath(dummyPreconditions, preconditionPath);
    if (!circuitValueEquals(precondition, dummy))
      continue;
    let hasAssertBetween = isRangeCondition(precondition);
    let shortPath = preconditionPath.split(".").pop();
    let errorMessage = `You used \`${self}.${preconditionPath}.get()\` without adding a precondition that links it to the actual ${shortPath}.
Consider adding this line to your code:
${self}.${preconditionPath}.assertEquals(${self}.${preconditionPath}.get());${hasAssertBetween ? `
You can also add more flexible preconditions with \`${self}.${preconditionPath}.assertBetween(...)\`.` : ""}`;
    throw Error(errorMessage);
  }
}
function getPreconditionContextExn(accountUpdate) {
  let c = preconditionContexts.get(accountUpdate);
  if (c === void 0)
    throw Error("bug: precondition context not found");
  return c;
}
var preconditionContexts = /* @__PURE__ */ new WeakMap();
function isRangeCondition(condition) {
  return "isSome" in condition && "lower" in condition.value;
}
function getPath(obj, path) {
  let pathArray = path.split(".").reverse();
  while (pathArray.length > 0) {
    let key = pathArray.pop();
    obj = obj[key];
  }
  return obj;
}
function setPath(obj, path, value) {
  let pathArray = path.split(".");
  let key = pathArray.pop();
  getPath(obj, pathArray.join("."))[key] = value;
}

// dist/node/lib/fetch.js
var import_isomorphic_fetch = require("isomorphic-fetch");

// dist/node/lib/mina/account.js
var Account3 = transaction_exports.Account;
var accountQuery = (publicKey, tokenId) => `{
  account(publicKey: "${publicKey}", token: "${tokenId}") {
    publicKey
    token
    nonce
    balance { total }
    tokenSymbol
    receiptChainHash
    timing {
      initialMinimumBalance
      cliffTime
      cliffAmount
      vestingPeriod
      vestingIncrement
    }
    permissions {
      editState
      access
      send
      receive
      setDelegate
      setPermissions
      setVerificationKey
      setZkappUri
      editActionState
      setTokenSymbol
      incrementNonce
      setVotingFor
      setTiming
    }
    delegateAccount { publicKey }
    votingFor
    zkappState
    verificationKey {
      verificationKey
      hash
    }
    actionState
    provedState
    zkappUri
  }
}
`;
function parseFetchedAccount({ publicKey, nonce, zkappState, balance, permissions, timing: { cliffAmount, cliffTime, initialMinimumBalance, vestingIncrement, vestingPeriod }, delegateAccount, receiptChainHash, actionState, token, tokenSymbol, verificationKey, provedState, zkappUri }) {
  let hasZkapp = zkappState !== null || verificationKey !== null || actionState !== null || zkappUri !== null || provedState;
  let partialAccount = {
    publicKey: PublicKey2.fromBase58(publicKey),
    tokenId: TokenId2.fromBase58(token),
    tokenSymbol: tokenSymbol ?? void 0,
    balance: balance && UInt642.from(balance.total),
    nonce: UInt322.from(nonce),
    receiptChainHash: receiptChainHash && ReceiptChainHash2.fromBase58(receiptChainHash) || void 0,
    delegate: (delegateAccount && PublicKey2.fromBase58(delegateAccount.publicKey)) ?? void 0,
    votingFor: void 0,
    timing: cliffAmount && cliffTime && initialMinimumBalance && vestingIncrement && vestingPeriod && {
      isTimed: Bool(true),
      cliffAmount: UInt642.from(cliffAmount),
      cliffTime: UInt322.from(cliffTime),
      initialMinimumBalance: UInt642.from(initialMinimumBalance),
      vestingIncrement: UInt642.from(vestingIncrement),
      vestingPeriod: UInt322.from(vestingPeriod)
    } || void 0,
    permissions: (permissions && Permissions.fromJSON(permissions)) ?? Permissions.initial(),
    zkapp: hasZkapp ? {
      appState: (zkappState && zkappState.map(Field)) ?? void 0,
      verificationKey: (verificationKey && {
        data: verificationKey.verificationKey,
        hash: Field(verificationKey.hash)
      }) ?? void 0,
      zkappVersion: void 0,
      actionState: (actionState && actionState.map(Field)) ?? void 0,
      lastActionSlot: void 0,
      provedState: provedState !== null ? Bool(provedState) : void 0,
      zkappUri: zkappUri !== null ? zkappUri : void 0
    } : void 0
  };
  return fillPartialAccount(partialAccount);
}
function fillPartialAccount(account) {
  return genericLayoutFold(TypeMap, customTypes, {
    map(type, value) {
      if (value !== void 0)
        return value;
      if (type.emptyValue)
        return type.emptyValue();
      return type.fromFields(Array(type.sizeInFields()).fill(Field(0)), type.toAuxiliary());
    },
    reduceArray(array) {
      return array;
    },
    reduceObject(_, record2) {
      return record2;
    },
    reduceFlaggedOption() {
      throw Error("not relevant");
    },
    reduceOrUndefined(value) {
      return value;
    }
  }, jsLayout.Account, account);
}

// dist/node/lib/fetch.js
var defaultGraphqlEndpoint = "none";
var archiveGraphqlEndpoint = "none";
function setGraphqlEndpoint(graphqlEndpoint) {
  defaultGraphqlEndpoint = graphqlEndpoint;
}
function setArchiveGraphqlEndpoint(graphqlEndpoint) {
  archiveGraphqlEndpoint = graphqlEndpoint;
}
async function fetchAccount(accountInfo, graphqlEndpoint = defaultGraphqlEndpoint, { timeout = defaultTimeout } = {}) {
  let publicKeyBase58 = accountInfo.publicKey instanceof PublicKey2 ? accountInfo.publicKey.toBase58() : accountInfo.publicKey;
  let tokenIdBase58 = typeof accountInfo.tokenId === "string" || !accountInfo.tokenId ? accountInfo.tokenId : TokenId3.toBase58(accountInfo.tokenId);
  return await fetchAccountInternal({ publicKey: publicKeyBase58, tokenId: tokenIdBase58 }, graphqlEndpoint, {
    timeout
  });
}
async function fetchAccountInternal(accountInfo, graphqlEndpoint = defaultGraphqlEndpoint, config) {
  const { publicKey, tokenId } = accountInfo;
  let [response, error] = await makeGraphqlRequest(accountQuery(publicKey, tokenId ?? TokenId3.toBase58(TokenId3.default)), graphqlEndpoint, config);
  if (error !== void 0)
    return { account: void 0, error };
  let fetchedAccount = response.data.account;
  if (fetchedAccount === null) {
    return {
      account: void 0,
      error: {
        statusCode: 404,
        statusText: `fetchAccount: Account with public key ${publicKey} does not exist.`
      }
    };
  }
  let account = parseFetchedAccount(fetchedAccount);
  addCachedAccountInternal(account, graphqlEndpoint);
  return {
    account,
    error: void 0
  };
}
var defaultTimeout = 5 * 60 * 1e3;
var accountCache = {};
var networkCache = {};
var actionsCache = {};
var accountsToFetch = {};
var networksToFetch = {};
var actionsToFetch = {};
function markAccountToBeFetched(publicKey, tokenId, graphqlEndpoint) {
  let publicKeyBase58 = publicKey.toBase58();
  let tokenBase58 = TokenId3.toBase58(tokenId);
  accountsToFetch[`${publicKeyBase58};${tokenBase58};${graphqlEndpoint}`] = {
    publicKey: publicKeyBase58,
    tokenId: tokenBase58,
    graphqlEndpoint
  };
}
function markNetworkToBeFetched(graphqlEndpoint) {
  networksToFetch[graphqlEndpoint] = { graphqlEndpoint };
}
function markActionsToBeFetched(publicKey, tokenId, graphqlEndpoint, actionStates = {}) {
  let publicKeyBase58 = publicKey.toBase58();
  let tokenBase58 = TokenId3.toBase58(tokenId);
  let { fromActionState, endActionState } = actionStates;
  let fromActionStateBase58 = fromActionState ? fromActionState.toString() : void 0;
  let endActionStateBase58 = endActionState ? endActionState.toString() : void 0;
  actionsToFetch[`${publicKeyBase58};${tokenBase58};${graphqlEndpoint}`] = {
    publicKey: publicKeyBase58,
    tokenId: tokenBase58,
    actionStates: {
      fromActionState: fromActionStateBase58,
      endActionState: endActionStateBase58
    },
    graphqlEndpoint
  };
}
async function fetchMissingData(graphqlEndpoint, archiveEndpoint) {
  let promises = Object.entries(accountsToFetch).map(async ([key, { publicKey, tokenId }]) => {
    let response = await fetchAccountInternal({ publicKey, tokenId }, graphqlEndpoint);
    if (response.error === void 0)
      delete accountsToFetch[key];
  });
  let actionPromises = Object.entries(actionsToFetch).map(async ([key, { publicKey, actionStates, tokenId }]) => {
    let response = await fetchActions({ publicKey, actionStates, tokenId }, archiveEndpoint);
    if (!("error" in response) || response.error === void 0)
      delete actionsToFetch[key];
  });
  promises.push(...actionPromises);
  let network = Object.entries(networksToFetch).find(([, network2]) => {
    return network2.graphqlEndpoint === graphqlEndpoint;
  });
  if (network !== void 0) {
    promises.push((async () => {
      try {
        await fetchLastBlock(graphqlEndpoint);
        delete networksToFetch[network[0]];
      } catch {
      }
    })());
  }
  await Promise.all(promises);
}
function getCachedAccount(publicKey, tokenId, graphqlEndpoint = defaultGraphqlEndpoint) {
  return accountCache[accountCacheKey(publicKey, tokenId, graphqlEndpoint)]?.account;
}
function getCachedNetwork(graphqlEndpoint = defaultGraphqlEndpoint) {
  return networkCache[graphqlEndpoint]?.network;
}
function getCachedActions(publicKey, tokenId, graphqlEndpoint = archiveGraphqlEndpoint) {
  return actionsCache[accountCacheKey(publicKey, tokenId, graphqlEndpoint)]?.actions;
}
function addCachedAccount(partialAccount, graphqlEndpoint = defaultGraphqlEndpoint) {
  let account = fillPartialAccount(partialAccount);
  addCachedAccountInternal(account, graphqlEndpoint);
}
function addCachedAccountInternal(account, graphqlEndpoint) {
  accountCache[accountCacheKey(account.publicKey, account.tokenId, graphqlEndpoint)] = {
    account,
    graphqlEndpoint,
    timestamp: Date.now()
  };
}
function addCachedActions({ publicKey, tokenId }, actions, graphqlEndpoint) {
  actionsCache[`${publicKey};${tokenId};${graphqlEndpoint}`] = {
    actions,
    graphqlEndpoint,
    timestamp: Date.now()
  };
}
function accountCacheKey(publicKey, tokenId, graphqlEndpoint) {
  return `${publicKey.toBase58()};${TokenId3.toBase58(tokenId)};${graphqlEndpoint}`;
}
async function fetchLastBlock(graphqlEndpoint = defaultGraphqlEndpoint) {
  let [resp, error] = await makeGraphqlRequest(lastBlockQuery, graphqlEndpoint);
  if (error)
    throw Error(error.statusText);
  let lastBlock = resp?.data?.bestChain?.[0];
  if (lastBlock === void 0) {
    throw Error("Failed to fetch latest network state.");
  }
  let network = parseFetchedBlock(lastBlock);
  networkCache[graphqlEndpoint] = {
    network,
    graphqlEndpoint,
    timestamp: Date.now()
  };
  return network;
}
var lastBlockQuery = `{
  bestChain(maxLength: 1) {
    protocolState {
      blockchainState {
        snarkedLedgerHash
        stagedLedgerHash
        date
        utcDate
        stagedLedgerProofEmitted
      }
      previousStateHash
      consensusState {
        blockHeight
        slotSinceGenesis
        slot
        nextEpochData {
          ledger {hash totalCurrency}
          seed
          startCheckpoint
          lockCheckpoint
          epochLength
        }
        stakingEpochData {
          ledger {hash totalCurrency}
          seed
          startCheckpoint
          lockCheckpoint
          epochLength
        }
        epochCount
        minWindowDensity
        totalCurrency
        epoch
      }
    }
  }
}`;
function parseFetchedBlock({ protocolState: { blockchainState: { snarkedLedgerHash, utcDate }, consensusState: { blockHeight, minWindowDensity, totalCurrency, slot, slotSinceGenesis, nextEpochData, stakingEpochData } } }) {
  return {
    snarkedLedgerHash: LedgerHash.fromBase58(snarkedLedgerHash),
    // TODO: use date or utcDate?
    blockchainLength: UInt322.from(blockHeight),
    minWindowDensity: UInt322.from(minWindowDensity),
    totalCurrency: UInt642.from(totalCurrency),
    globalSlotSinceGenesis: UInt322.from(slotSinceGenesis),
    nextEpochData: parseEpochData(nextEpochData),
    stakingEpochData: parseEpochData(stakingEpochData)
  };
}
function parseEpochData({ ledger: { hash: hash2, totalCurrency }, seed, startCheckpoint, lockCheckpoint, epochLength }) {
  return {
    ledger: {
      hash: LedgerHash.fromBase58(hash2),
      totalCurrency: UInt642.from(totalCurrency)
    },
    seed: EpochSeed.fromBase58(seed),
    startCheckpoint: StateHash2.fromBase58(startCheckpoint),
    lockCheckpoint: StateHash2.fromBase58(lockCheckpoint),
    epochLength: UInt322.from(epochLength)
  };
}
var transactionStatusQuery = (txId) => `query {
  transactionStatus(zkappTransaction:"${txId}")
}`;
async function fetchTransactionStatus(txId, graphqlEndpoint = defaultGraphqlEndpoint) {
  let [resp, error] = await makeGraphqlRequest(transactionStatusQuery(txId), graphqlEndpoint);
  if (error)
    throw Error(error.statusText);
  let txStatus = resp?.data?.transactionStatus;
  if (txStatus === void 0 || txStatus === null) {
    throw Error(`Failed to fetch transaction status. TransactionId: ${txId}`);
  }
  return txStatus;
}
function sendZkapp(json, graphqlEndpoint = defaultGraphqlEndpoint, { timeout = defaultTimeout } = {}) {
  return makeGraphqlRequest(sendZkappQuery(json), graphqlEndpoint, {
    timeout
  });
}
function sendZkappQuery(json) {
  return `mutation {
  sendZkapp(input: {
    zkappCommand: ${removeJsonQuotes(json)}
  }) {
    zkapp {
      hash
      id
      failureReason {
        failures
        index
      }
      zkappCommand {
        memo
        feePayer {
          body {
            publicKey
          }
        }
        accountUpdates {
          body {
            publicKey
            useFullCommitment
            incrementNonce
          }
        }
      }
    }
  }
}
`;
}
var getEventsQuery = (publicKey, tokenId, filterOptions) => {
  const { to, from } = filterOptions ?? {};
  let input = `address: "${publicKey}", tokenId: "${tokenId}"`;
  if (to !== void 0) {
    input += `, to: ${to}`;
  }
  if (from !== void 0) {
    input += `, from: ${from}`;
  }
  return `{
  events(input: { ${input} }) {
    blockInfo {
      distanceFromMaxBlockHeight
      height
      globalSlotSinceGenesis
      stateHash
      parentHash
      chainStatus
    }
    eventData {
      transactionInfo {
        hash
        memo
        status
      }
      data
    }
  }
}`;
};
var getActionsQuery = (publicKey, actionStates, tokenId, _filterOptions) => {
  const { fromActionState, endActionState } = actionStates ?? {};
  let input = `address: "${publicKey}", tokenId: "${tokenId}"`;
  if (fromActionState !== void 0) {
    input += `, fromActionState: "${fromActionState}"`;
  }
  if (endActionState !== void 0) {
    input += `, endActionState: "${endActionState}"`;
  }
  return `{
  actions(input: { ${input} }) {
    blockInfo {
      distanceFromMaxBlockHeight
    }
    actionState {
      actionStateOne
      actionStateTwo
    }
    actionData {
      accountUpdateId
      data
    }
  }
}`;
};
async function fetchEvents(accountInfo, graphqlEndpoint = archiveGraphqlEndpoint, filterOptions = {}) {
  if (!graphqlEndpoint)
    throw new Error("fetchEvents: Specified GraphQL endpoint is undefined. Please specify a valid endpoint.");
  const { publicKey, tokenId } = accountInfo;
  let [response, error] = await makeGraphqlRequest(getEventsQuery(publicKey, tokenId ?? TokenId3.toBase58(TokenId3.default), filterOptions), graphqlEndpoint);
  if (error)
    throw Error(error.statusText);
  let fetchedEvents = response?.data.events;
  if (fetchedEvents === void 0) {
    throw Error(`Failed to fetch events data. Account: ${publicKey} Token: ${tokenId}`);
  }
  let numberOfBestTipBlocks = 0;
  for (let i2 = 0; i2 < fetchedEvents.length; i2++) {
    if (fetchedEvents[i2].blockInfo.distanceFromMaxBlockHeight === 0) {
      numberOfBestTipBlocks++;
    }
    if (numberOfBestTipBlocks > 1) {
      fetchedEvents = fetchedEvents.filter((event) => {
        return event.blockInfo.distanceFromMaxBlockHeight !== 0;
      });
      break;
    }
  }
  return fetchedEvents.map((event) => {
    let events = event.eventData.map(({ data, transactionInfo }) => {
      return {
        data,
        transactionInfo
      };
    });
    return {
      events,
      blockHeight: UInt322.from(event.blockInfo.height),
      blockHash: event.blockInfo.stateHash,
      parentBlockHash: event.blockInfo.parentHash,
      globalSlot: UInt322.from(event.blockInfo.globalSlotSinceGenesis),
      chainStatus: event.blockInfo.chainStatus
    };
  });
}
async function fetchActions(accountInfo, graphqlEndpoint = archiveGraphqlEndpoint) {
  if (!graphqlEndpoint)
    throw new Error("fetchActions: Specified GraphQL endpoint is undefined. Please specify a valid endpoint.");
  const { publicKey, actionStates, tokenId = TokenId3.toBase58(TokenId3.default) } = accountInfo;
  let [response, error] = await makeGraphqlRequest(getActionsQuery(publicKey, actionStates, tokenId), graphqlEndpoint);
  if (error)
    throw Error(error.statusText);
  let fetchedActions = response?.data.actions;
  if (fetchedActions === void 0) {
    return {
      error: {
        statusCode: 404,
        statusText: `fetchActions: Account with public key ${publicKey} with tokenId ${tokenId} does not exist.`
      }
    };
  }
  let numberOfBestTipBlocks = 0;
  for (let i2 = 0; i2 < fetchedActions.length; i2++) {
    if (fetchedActions[i2].blockInfo.distanceFromMaxBlockHeight === 0) {
      numberOfBestTipBlocks++;
    }
    if (numberOfBestTipBlocks > 1) {
      fetchedActions = fetchedActions.filter((action) => {
        return action.blockInfo.distanceFromMaxBlockHeight !== 0;
      });
      break;
    }
  }
  fetchedActions.reverse();
  let actionsList = [];
  if (fetchedActions.length !== 0 && fetchedActions[0].actionState.actionStateOne === actionStates.fromActionState) {
    fetchedActions = fetchedActions.slice(1);
  }
  fetchedActions.forEach((actionBlock) => {
    let { actionData } = actionBlock;
    let latestActionState = Field(actionBlock.actionState.actionStateTwo);
    let actionState = actionBlock.actionState.actionStateOne;
    if (actionData.length === 0)
      throw Error(`No action data was found for the account ${publicKey} with the latest action state ${actionState}`);
    let actionsByAccountUpdate = [];
    let currentAccountUpdateId = "none";
    let currentActions;
    actionData.forEach(({ accountUpdateId, data }) => {
      if (accountUpdateId === currentAccountUpdateId) {
        currentActions.push(data);
      } else {
        currentAccountUpdateId = accountUpdateId;
        currentActions = [data];
        actionsByAccountUpdate.push(currentActions);
      }
    });
    for (let actions of actionsByAccountUpdate) {
      latestActionState = updateActionState(actions, latestActionState);
      actionsList.push({ actions, hash: latestActionState.toString() });
    }
    const finalActionState = latestActionState.toString();
    const expectedActionState = actionState;
    if (finalActionState !== expectedActionState) {
      throw new Error(`Failed to derive correct actions hash for ${publicKey}.
        Derived hash: ${finalActionState}, expected hash: ${expectedActionState}).
        All action hashes derived: ${JSON.stringify(actionsList, null, 2)}
        Please try a different Archive Node API endpoint.
        `);
    }
  });
  addCachedActions({ publicKey, tokenId }, actionsList, graphqlEndpoint);
  return actionsList;
}
function updateActionState(actions, actionState) {
  let actionsHash = Actions.fromJSON(actions).hash;
  return Actions.updateSequenceState(actionState, actionsHash);
}
function removeJsonQuotes(json) {
  let cleaned = JSON.stringify(JSON.parse(json), null, 2);
  return cleaned.replace(/\"(\S+)\"\s*:/gm, "$1:");
}
async function makeGraphqlRequest(query, graphqlEndpoint = defaultGraphqlEndpoint, { timeout = defaultTimeout } = {}) {
  if (graphqlEndpoint === "none")
    throw Error("Should have made a graphql request, but don't know to which endpoint. Try calling `setGraphqlEndpoint` first.");
  const controller = new AbortController();
  const timer = setTimeout(() => {
    controller.abort();
  }, timeout);
  try {
    let body = JSON.stringify({ operationName: null, query, variables: {} });
    let response = await fetch(graphqlEndpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body,
      signal: controller.signal
    });
    return await checkResponseStatus(response);
  } catch (error) {
    clearTimeout(timer);
    return [void 0, inferError(error)];
  }
}
async function checkResponseStatus(response) {
  if (response.ok) {
    return [await response.json(), void 0];
  } else {
    return [
      void 0,
      {
        statusCode: response.status,
        statusText: response.statusText
      }
    ];
  }
}
function inferError(error) {
  let errorMessage = JSON.stringify(error);
  if (error instanceof AbortSignal) {
    return { statusCode: 408, statusText: `Request Timeout: ${errorMessage}` };
  } else {
    return {
      statusCode: 500,
      statusText: `Unknown Error: ${errorMessage}`
    };
  }
}

// dist/node/lib/state.js
function State() {
  return createState();
}
function state(stateType) {
  return function(target, key, _descriptor) {
    const ZkappClass = target.constructor;
    if (reservedPropNames.has(key)) {
      throw Error(`Property name ${key} is reserved.`);
    }
    let sc = smartContracts.get(ZkappClass);
    if (sc === void 0) {
      sc = { states: [], layout: void 0 };
      smartContracts.set(ZkappClass, sc);
    }
    sc.states.push([key, stateType]);
    Object.defineProperty(target, key, {
      get() {
        return this._?.[key];
      },
      set(v) {
        if (v._contract !== void 0)
          throw Error("A State should only be assigned once to a SmartContract");
        if (this._?.[key])
          throw Error("A @state should only be assigned once");
        v._contract = {
          key,
          stateType,
          instance: this,
          class: ZkappClass,
          wasConstrained: false,
          wasRead: false,
          cachedVariable: void 0
        };
        (this._ ?? (this._ = {}))[key] = v;
      }
    });
  };
}
function declareState(SmartContract2, states) {
  for (let key in states) {
    let CircuitValue2 = states[key];
    state(CircuitValue2)(SmartContract2.prototype, key);
  }
}
function createState() {
  return {
    _contract: void 0,
    set(state2) {
      if (this._contract === void 0)
        throw Error("set can only be called when the State is assigned to a SmartContract @state.");
      let layout = getLayoutPosition(this._contract);
      let stateAsFields = this._contract.stateType.toFields(state2);
      let accountUpdate = this._contract.instance.self;
      stateAsFields.forEach((x, i2) => {
        AccountUpdate2.setValue(accountUpdate.body.update.appState[layout.offset + i2], x);
      });
    },
    assertEquals(state2) {
      if (this._contract === void 0)
        throw Error("assertEquals can only be called when the State is assigned to a SmartContract @state.");
      let layout = getLayoutPosition(this._contract);
      let stateAsFields = this._contract.stateType.toFields(state2);
      let accountUpdate = this._contract.instance.self;
      stateAsFields.forEach((x, i2) => {
        AccountUpdate2.assertEquals(accountUpdate.body.preconditions.account.state[layout.offset + i2], x);
      });
      this._contract.wasConstrained = true;
    },
    assertNothing() {
      if (this._contract === void 0)
        throw Error("assertNothing can only be called when the State is assigned to a SmartContract @state.");
      this._contract.wasConstrained = true;
    },
    get() {
      if (this._contract === void 0)
        throw Error("get can only be called when the State is assigned to a SmartContract @state.");
      if (this._contract.cachedVariable !== void 0 && // `inCheckedComputation() === true` here always implies being inside a wrapped smart contract method,
      // which will ensure that the cache is cleaned up before & after each method run.
      inCheckedComputation()) {
        this._contract.wasRead = true;
        return this._contract.cachedVariable;
      }
      let layout = getLayoutPosition(this._contract);
      let contract = this._contract;
      let inProver_ = inProver();
      let stateFieldsType = circuitArray(Field, layout.length);
      let stateAsFields = Circuit.witness(stateFieldsType, () => {
        let account;
        try {
          account = getAccount(contract.instance.address, contract.instance.self.body.tokenId);
        } catch (err) {
          if (inProver_) {
            throw err;
          }
          throw Error(`${contract.key}.get() failed, either:
1. We can't find this zkapp account in the ledger
2. Because the zkapp account was not found in the cache. Try calling \`await fetchAccount(zkappAddress)\` first.
If none of these are the case, then please reach out on Discord at #zkapp-developers and/or open an issue to tell us!`);
        }
        if (account.zkapp?.appState === void 0) {
          return Array(layout.length).fill(Field(0));
        } else {
          let stateAsFields2 = [];
          for (let i2 = 0; i2 < layout.length; ++i2) {
            stateAsFields2.push(account.zkapp.appState[layout.offset + i2]);
          }
          return stateAsFields2;
        }
      });
      let state2 = this._contract.stateType.fromFields(stateAsFields);
      if (inCheckedComputation())
        this._contract.stateType.check?.(state2);
      this._contract.wasRead = true;
      this._contract.cachedVariable = state2;
      return state2;
    },
    async fetch() {
      if (this._contract === void 0)
        throw Error("fetch can only be called when the State is assigned to a SmartContract @state.");
      if (currentTransaction.has())
        throw Error("fetch is not intended to be called inside a transaction block.");
      let layout = getLayoutPosition(this._contract);
      let address = this._contract.instance.address;
      let { account } = await fetchAccount({
        publicKey: address,
        tokenId: TokenId3.toBase58(TokenId3.default)
      });
      if (account === void 0)
        return void 0;
      let stateAsFields;
      if (account.zkapp?.appState === void 0) {
        stateAsFields = Array(layout.length).fill(Field(0));
      } else {
        stateAsFields = [];
        for (let i2 = 0; i2 < layout.length; i2++) {
          stateAsFields.push(account.zkapp.appState[layout.offset + i2]);
        }
      }
      return this._contract.stateType.fromFields(stateAsFields);
    }
  };
}
function getLayoutPosition({ key, class: contractClass }) {
  let layout = getLayout(contractClass);
  let stateLayout = layout.get(key);
  if (stateLayout === void 0) {
    throw new Error(`state ${key} not found`);
  }
  return stateLayout;
}
function getLayout(scClass) {
  let sc = smartContracts.get(scClass);
  if (sc === void 0)
    throw Error("bug");
  if (sc.layout === void 0) {
    let layout = /* @__PURE__ */ new Map();
    sc.layout = layout;
    let offset = 0;
    sc.states.forEach(([key, stateType]) => {
      let length = stateType.sizeInFields();
      layout.set(key, { offset, length });
      offset += length;
    });
  }
  return sc.layout;
}
var smartContracts = /* @__PURE__ */ new WeakMap();
var reservedPropNames = /* @__PURE__ */ new Set(["_methods", "_"]);
function assertStatePrecondition(sc) {
  try {
    for (let [key, context] of getStateContexts(sc)) {
      if (!context?.wasRead || context.wasConstrained)
        continue;
      let errorMessage = `You used \`this.${key}.get()\` without adding a precondition that links it to the actual on-chain state.
Consider adding this line to your code:
this.${key}.assertEquals(this.${key}.get());`;
      throw Error(errorMessage);
    }
  } finally {
    cleanStatePrecondition(sc);
  }
}
function cleanStatePrecondition(sc) {
  for (let [, context] of getStateContexts(sc)) {
    if (context === void 0)
      continue;
    context.wasRead = false;
    context.wasConstrained = false;
    context.cachedVariable = void 0;
  }
}
function getStateContexts(sc) {
  let scClass = sc.constructor;
  let scInfo = smartContracts.get(scClass);
  if (scInfo === void 0)
    return [];
  return scInfo.states.map(([key]) => [key, sc[key]?._contract]);
}

// dist/node/lib/zkapp.js
var _SmartContract_executionState;
var _SmartContract__senderState;
var reservedPropNames2 = /* @__PURE__ */ new Set(["_methods", "_"]);
function method(target, methodName, descriptor) {
  const ZkappClass = target.constructor;
  if (reservedPropNames2.has(methodName)) {
    throw Error(`Property name ${methodName} is reserved.`);
  }
  if (typeof target[methodName] !== "function") {
    throw Error(`@method decorator was applied to \`${methodName}\`, which is not a function.`);
  }
  let paramTypes = Reflect.getMetadata("design:paramtypes", target, methodName);
  let returnType = Reflect.getMetadata("design:returntype", target, methodName);
  class SelfProof2 extends Proof {
  }
  SelfProof2.publicInputType = ZkappPublicInput;
  SelfProof2.tag = () => ZkappClass;
  let internalMethodEntry = sortMethodArguments(ZkappClass.name, methodName, paramTypes, SelfProof2);
  let methodEntry = sortMethodArguments(ZkappClass.name, methodName, [PublicKey2, Field, ...paramTypes], SelfProof2);
  if (isAsFields(returnType)) {
    internalMethodEntry.returnType = returnType;
    methodEntry.returnType = returnType;
  }
  ZkappClass._methods ?? (ZkappClass._methods = []);
  ZkappClass._methods.push(methodEntry);
  ZkappClass._maxProofsVerified ?? (ZkappClass._maxProofsVerified = 0);
  ZkappClass._maxProofsVerified = Math.max(ZkappClass._maxProofsVerified, methodEntry.proofArgs.length);
  let func = descriptor.value;
  descriptor.value = wrapMethod(func, ZkappClass, internalMethodEntry);
}
function wrapMethod(method2, ZkappClass, methodIntf) {
  let methodName = methodIntf.methodName;
  return function wrappedMethod(...actualArgs) {
    cleanStatePrecondition(this);
    actualArgs.forEach((arg) => {
      if (arg instanceof AccountUpdate2) {
        AccountUpdate2.unlink(arg);
      }
    });
    if (!smartContractContext.has() || smartContractContext()?.isCallback) {
      return smartContractContext.runWith(smartContractContext() ?? {
        this: this,
        methodCallDepth: 0,
        isCallback: false,
        selfUpdate: selfAccountUpdate(this, methodName)
      }, (context) => {
        if ((inCompile() || inProver() || inAnalyze()) && !context.isCallback) {
          let proverData = inProver() ? zkAppProver.getData() : void 0;
          let [, result2] = currentTransaction.runWith({
            sender: proverData?.transaction.feePayer.body.publicKey,
            accountUpdates: [],
            fetchMode: inProver() ? "cached" : "test",
            isFinalRunOutsideCircuit: false,
            numberOfRuns: void 0
          }, () => {
            let publicInput = actualArgs.shift();
            let accountUpdate = this.self;
            let blindingValue = Circuit.witness(Field, getBlindingValue);
            let context2 = memoizationContext() ?? {
              memoized: [],
              currentIndex: 0
            };
            let [, result3] = memoizationContext.runWith({ ...context2, blindingValue }, () => method2.apply(this, actualArgs));
            let callDataFields = computeCallData(methodIntf, actualArgs, result3, blindingValue);
            accountUpdate.body.callData = Poseidon2.hash(callDataFields);
            Authorization.setProofAuthorizationKind(accountUpdate);
            if (DEBUG_PUBLIC_INPUT_CHECK) {
              Circuit.asProver(() => {
                function diff(prover, input) {
                  delete prover.id;
                  delete prover.callDepth;
                  delete input.id;
                  delete input.callDepth;
                  if (JSON.stringify(prover) !== JSON.stringify(input)) {
                    console.log("transaction:", ZkappCommand2.toPretty(transaction2));
                    console.log("index", index);
                    console.log("inconsistent account updates:");
                    console.log("update created by the prover:");
                    console.log(prover);
                    console.log("update created in transaction block:");
                    console.log(input);
                  }
                }
                function diffRecursive(prover, input) {
                  diff(prover.toPretty(), input.toPretty());
                  let nChildren = input.children.accountUpdates.length;
                  for (let i2 = 0; i2 < nChildren; i2++) {
                    let inputChild = input.children.accountUpdates[i2];
                    let child = prover.children.accountUpdates[i2];
                    if (!inputChild || !child)
                      return;
                    diffRecursive(child, inputChild);
                  }
                }
                let { accountUpdate: inputUpdate, transaction: transaction2, index } = zkAppProver.getData();
                diffRecursive(accountUpdate, inputUpdate);
              });
            }
            checkPublicInput(publicInput, accountUpdate);
            assertPreconditionInvariants(accountUpdate);
            cleanPreconditionsCache(accountUpdate);
            assertStatePrecondition(this);
            return result3;
          });
          return result2;
        } else if (!currentTransaction.has()) {
          let result2 = method2.apply(this, actualArgs);
          assertPreconditionInvariants(this.self);
          cleanPreconditionsCache(this.self);
          assertStatePrecondition(this);
          return result2;
        } else {
          let accountUpdate = context.selfUpdate;
          if (!context.isCallback) {
            currentTransaction()?.accountUpdates.push(accountUpdate);
          }
          let clonedArgs = cloneCircuitValue(actualArgs);
          let blindingValue = getBlindingValue();
          let [{ memoized }, result2] = memoizationContext.runWith({
            memoized: [],
            currentIndex: 0,
            blindingValue
          }, () => method2.apply(this, actualArgs.map((a, i2) => {
            let arg = methodIntf.allArgs[i2];
            if (arg.type === "witness") {
              let type = methodIntf.witnessArgs[arg.index];
              return Circuit.witness(type, () => a);
            }
            return a;
          })));
          assertStatePrecondition(this);
          let callDataFields = computeCallData(methodIntf, actualArgs, result2, blindingValue);
          accountUpdate.body.callData = Poseidon2.hash(callDataFields);
          if (!Authorization.hasAny(accountUpdate)) {
            Authorization.setLazyProof(accountUpdate, {
              methodName: methodIntf.methodName,
              args: clonedArgs,
              // proofs actually don't have to be cloned
              previousProofs: getPreviousProofsForProver(actualArgs, methodIntf),
              ZkappClass,
              memoized,
              blindingValue
            }, currentTransaction().accountUpdates);
          }
          return result2;
        }
      })[1];
    }
    let parentAccountUpdate = smartContractContext.get().this.self;
    let methodCallDepth = smartContractContext.get().methodCallDepth;
    let [, result] = smartContractContext.runWith({
      this: this,
      methodCallDepth: methodCallDepth + 1,
      isCallback: false,
      selfUpdate: selfAccountUpdate(this, methodName)
    }, () => {
      let { returnType } = methodIntf;
      let noReturnTypeError = `To return a result from ${methodIntf.methodName}() inside another zkApp, you need to declare the return type.
This can be done by annotating the type at the end of the function signature. For example:

@method ${methodIntf.methodName}(): Field {
  // ...
}

Note: Only types built out of \`Field\` are valid return types. This includes snarkyjs primitive types and custom CircuitValues.`;
      if (ZkappClass._methodMetadata[methodIntf.methodName]?.hasReturn && returnType === void 0) {
        throw Error(noReturnTypeError);
      }
      let blindingValue = getBlindingValue();
      let runCalledContract = () => {
        let constantArgs = methodArgumentsToConstant(methodIntf, actualArgs);
        let constantBlindingValue = blindingValue.toConstant();
        let accountUpdate2 = this.self;
        accountUpdate2.body.callDepth = parentAccountUpdate.body.callDepth + 1;
        accountUpdate2.parent = parentAccountUpdate;
        let [{ memoized }, result3] = memoizationContext.runWith({
          memoized: [],
          currentIndex: 0,
          blindingValue: constantBlindingValue
        }, () => method2.apply(this, constantArgs));
        assertStatePrecondition(this);
        if (result3 !== void 0) {
          if (returnType === void 0) {
            throw Error(noReturnTypeError);
          } else {
            result3 = toConstant(returnType, result3);
          }
        }
        let callDataFields2 = computeCallData(methodIntf, constantArgs, result3, constantBlindingValue);
        accountUpdate2.body.callData = Poseidon.hash(callDataFields2, false);
        if (!Authorization.hasAny(accountUpdate2)) {
          Authorization.setLazyProof(accountUpdate2, {
            methodName: methodIntf.methodName,
            args: constantArgs,
            previousProofs: getPreviousProofsForProver(constantArgs, methodIntf),
            ZkappClass,
            memoized,
            blindingValue: constantBlindingValue
          }, currentTransaction().accountUpdates);
        }
        return { accountUpdate: accountUpdate2, result: result3 ?? null };
      };
      let { accountUpdate, result: result2 } = methodCallDepth === 0 ? AccountUpdate2.witness(returnType ?? provable2(null), runCalledContract, { skipCheck: true }) : runCalledContract();
      smartContractContext.get().selfUpdate = accountUpdate;
      accountUpdate.body.callDepth = parentAccountUpdate.body.callDepth + 1;
      accountUpdate.parent = parentAccountUpdate;
      accountUpdate.children.callsType = { type: "Witness" };
      parentAccountUpdate.children.accountUpdates.push(accountUpdate);
      accountUpdate.body.publicKey.assertEquals(this.address);
      accountUpdate.body.tokenId.assertEquals(this.self.body.tokenId);
      let callDataFields = computeCallData(methodIntf, actualArgs, result2, blindingValue);
      let callData = Poseidon2.hash(callDataFields);
      accountUpdate.body.callData.assertEquals(callData);
      let isTopLevel = Circuit.witness(Bool, () => {
        let isProverUpdate = inProver() && zkAppProver.getData().accountUpdate.body.publicKey.equals(parentAccountUpdate.body.publicKey).toBoolean();
        let parentCallDepth = isProverUpdate ? zkAppProver.getData().accountUpdate.body.callDepth : CallForest.computeCallDepth(parentAccountUpdate);
        return Bool(parentCallDepth === 0);
      });
      parentAccountUpdate.body.mayUseToken = {
        parentsOwnToken: isTopLevel.not(),
        inheritFromParent: Bool(false)
      };
      return result2;
    });
    return result;
  };
}
function checkPublicInput({ accountUpdate, calls }, self) {
  let otherInput = self.toPublicInput();
  accountUpdate.assertEquals(otherInput.accountUpdate);
  calls.assertEquals(otherInput.calls);
}
function computeCallData(methodIntf, argumentValues, returnValue, blindingValue) {
  let { returnType, methodName } = methodIntf;
  let args = methodArgumentTypesAndValues(methodIntf, argumentValues);
  let argSizesAndFields = args.map(({ type, value }) => [
    Field(type.sizeInFields()),
    ...type.toFields(value)
  ]);
  let totalArgSize = Field(args.map(({ type }) => type.sizeInFields()).reduce((s, t) => s + t, 0));
  let totalArgFields = argSizesAndFields.flat();
  let returnSize = Field(returnType?.sizeInFields() ?? 0);
  let returnFields = returnType?.toFields(returnValue) ?? [];
  let methodNameFields = stringToFields(methodName);
  return [
    // we have to encode the sizes of arguments / return value, so that fields can't accidentally shift
    // from one argument to another, or from arguments to the return value, or from the return value to the method name
    totalArgSize,
    ...totalArgFields,
    returnSize,
    ...returnFields,
    // we don't have to encode the method name size because the blinding value is fixed to one field element,
    // so method name fields can't accidentally become the blinding value and vice versa
    ...methodNameFields,
    blindingValue
  ];
}
var Callback = class extends GenericArgument {
  static create(instance, methodName, args) {
    let ZkappClass = instance.constructor;
    let methodIntf_ = (ZkappClass._methods ?? []).find((i2) => i2.methodName === methodName);
    if (methodIntf_ === void 0)
      throw Error(`Callback: could not find method ${ZkappClass.name}.${String(methodName)}`);
    let methodIntf = {
      ...methodIntf_,
      returnType: methodIntf_.returnType ?? provable2(null)
    };
    let result = instance[methodName](...args);
    let accountUpdate = instance.self;
    let callback = new Callback({
      instance,
      methodIntf,
      args,
      result,
      accountUpdate,
      isEmpty: false
    });
    return callback;
  }
  constructor(self) {
    super();
    Object.assign(this, self);
  }
};
var SmartContract = class {
  /**
   * Returns a Proof type that belongs to this {@link SmartContract}.
   */
  static Proof() {
    var _a;
    let Contract = this;
    return _a = class extends Proof {
    }, _a.publicInputType = ZkappPublicInput, _a.tag = () => Contract, _a;
  }
  constructor(address, tokenId) {
    _SmartContract_executionState.set(this, void 0);
    _SmartContract__senderState.set(this, void 0);
    this.events = {};
    this.address = address;
    this.tokenId = tokenId ?? TokenId3.default;
    Object.defineProperty(this, "reducer", {
      set(reducer) {
        var _a;
        ((_a = this)._ ?? (_a._ = {})).reducer = reducer;
      },
      get() {
        return getReducer(this);
      }
    });
  }
  /**
   * Compile your smart contract.
   *
   * This generates both the prover functions, needed to create proofs for running `@method`s,
   * and the verification key, needed to deploy your zkApp.
   *
   * Although provers and verification key are returned by this method, they are also cached internally and used when needed,
   * so you don't actually have to use the return value of this function.
   *
   * Under the hood, "compiling" means calling into the lower-level [Pickles and Kimchi libraries](https://o1-labs.github.io/proof-systems/kimchi/overview.html) to
   * create multiple prover & verifier indices (one for each smart contract method as part of a "step circuit" and one for the "wrap circuit" which recursively wraps
   * it so that proofs end up in the original finite field). These are fairly expensive operations, so **expect compiling to take at least 20 seconds**,
   * up to several minutes if your circuit is large or your hardware is not optimal for these operations.
   */
  static async compile() {
    let methodIntfs = this._methods ?? [];
    let methods = methodIntfs.map(({ methodName }) => {
      return (publicInput, publicKey, tokenId, ...args) => {
        let instance = new this(publicKey, tokenId);
        instance[methodName](publicInput, ...args);
      };
    });
    this.analyzeMethods();
    let { getVerificationKeyArtifact, provers, verify: verify2 } = compileProgram(ZkappPublicInput, methodIntfs, methods, this);
    let verificationKey_ = getVerificationKeyArtifact();
    let verificationKey = {
      data: verificationKey_.data,
      hash: Field(verificationKey_.hash)
    };
    this._provers = provers;
    this._verificationKey = verificationKey;
    return { verificationKey, provers, verify: verify2 };
  }
  /**
   * Computes a hash of your smart contract, which will reliably change _whenever one of your method circuits changes_.
   * This digest is quick to compute. it is designed to help with deciding whether a contract should be re-compiled or
   * a cached verification key can be used.
   * @returns the digest, as a hex string
   */
  static digest() {
    let methodData = this.analyzeMethods();
    let hash2 = Poseidon.hash(Object.values(methodData).map((d) => Field(BigInt("0x" + d.digest))), false);
    return hash2.toBigInt().toString(16);
  }
  /**
   * Deploys a {@link SmartContract}.
   *
   * ```ts
   * let tx = await Mina.transaction(feePayer, () => {
   *    AccountUpdate.fundNewAccount(feePayer, { initialBalance });
   *    zkapp.deploy({ zkappKey });
   * });
   * ```
   */
  deploy({ verificationKey, zkappKey } = {}) {
    let accountUpdate = this.newSelf();
    verificationKey ?? (verificationKey = this.constructor._verificationKey);
    if (verificationKey === void 0 && !getProofsEnabled()) {
      verificationKey = Pickles.dummyVerificationKey();
    }
    if (verificationKey !== void 0) {
      let { hash: hash_, data } = verificationKey;
      let hash2 = typeof hash_ === "string" ? Field(hash_) : hash_;
      accountUpdate.account.verificationKey.set({ hash: hash2, data });
    }
    accountUpdate.account.permissions.set(Permissions.default());
    accountUpdate.sign(zkappKey);
    AccountUpdate2.attachToTransaction(accountUpdate);
    let shouldInit = !hasAccount(this.address) || getAccount(this.address).zkapp?.verificationKey === void 0;
    if (!shouldInit)
      return;
    if (zkappKey)
      this.init(zkappKey);
    else
      this.init();
    let initUpdate = this.self;
    (0, import_tslib3.__classPrivateFieldSet)(this, _SmartContract_executionState, {
      transactionId: (0, import_tslib3.__classPrivateFieldGet)(this, _SmartContract_executionState, "f").transactionId,
      accountUpdate
    }, "f");
    let isFirstRun = currentTransaction()?.numberOfRuns === 0;
    if (!isFirstRun)
      return;
    Circuit.asProver(() => {
      if (initUpdate.update.appState.some(({ isSome }) => !isSome.toBoolean())) {
        console.warn(`WARNING: the \`init()\` method was called without overwriting the entire state. This means that your zkApp will lack
the \`provedState === true\` status which certifies that the current state was verifiably produced by proofs (and not arbitrarily set by the zkApp developer).
To make sure the entire state is reset, consider adding this line to the beginning of your \`init()\` method:
super.init();
`);
      }
    });
  }
  // TODO make this a @method and create a proof during `zk deploy` (+ add mechanism to skip this)
  /**
   * `SmartContract.init()` will be called only when a {@link SmartContract} will be first deployed, not for redeployment.
   * This method can be overridden as follows
   * ```
   * class MyContract extends SmartContract {
   *  init() {
   *    super.init();
   *    this.account.permissions.set(...);
   *    this.x.set(Field(1));
   *  }
   * }
   * ```
   */
  init(zkappKey) {
    zkappKey?.toPublicKey().assertEquals(this.address);
    let accountUpdate = this.self;
    for (let i2 = 0; i2 < ZkappStateLength; i2++) {
      AccountUpdate2.setValue(accountUpdate.body.update.appState[i2], Field(0));
    }
    AccountUpdate2.attachToTransaction(accountUpdate);
  }
  /**
   * Use this command if the account update created by this SmartContract should be signed by the account owner,
   * instead of authorized with a proof.
   *
   * Note that the smart contract's {@link Permissions} determine which updates have to be (can be) authorized by a signature.
   *
   * If you only want to avoid creating proofs for quicker testing, we advise you to
   * use `LocalBlockchain({ proofsEnabled: false })` instead of `requireSignature()`. Setting
   * `proofsEnabled` to `false` allows you to test your transactions with the same authorization flow as in production,
   * with the only difference being that quick mock proofs are filled in instead of real proofs.
   */
  requireSignature() {
    this.self.requireSignature();
  }
  /**
   * @deprecated `this.sign()` is deprecated in favor of `this.requireSignature()`
   */
  sign(zkappKey) {
    this.self.sign(zkappKey);
  }
  /**
   * Use this command if the account update created by this SmartContract should have no authorization on it,
   * instead of being authorized with a proof.
   *
   * WARNING: This is a method that should rarely be useful. If you want to disable proofs for quicker testing, take a look
   * at `LocalBlockchain({ proofsEnabled: false })`, which causes mock proofs to be created and doesn't require changing the
   * authorization flow.
   */
  skipAuthorization() {
    Authorization.setLazyNone(this.self);
  }
  /**
   * Returns the current {@link AccountUpdate} associated to this {@link SmartContract}.
   */
  get self() {
    let inTransaction = currentTransaction.has();
    let inSmartContract = smartContractContext.has();
    if (!inTransaction && !inSmartContract) {
      return selfAccountUpdate(this);
    }
    let transactionId = inTransaction ? currentTransaction.id() : NaN;
    if (inSmartContract && smartContractContext.get().this === this) {
      let accountUpdate2 = smartContractContext.get().selfUpdate;
      (0, import_tslib3.__classPrivateFieldSet)(this, _SmartContract_executionState, { accountUpdate: accountUpdate2, transactionId }, "f");
      return accountUpdate2;
    }
    let executionState = (0, import_tslib3.__classPrivateFieldGet)(this, _SmartContract_executionState, "f");
    if (executionState !== void 0 && executionState.transactionId === transactionId) {
      return executionState.accountUpdate;
    }
    let accountUpdate = selfAccountUpdate(this);
    (0, import_tslib3.__classPrivateFieldSet)(this, _SmartContract_executionState, { transactionId, accountUpdate }, "f");
    return accountUpdate;
  }
  // same as this.self, but explicitly creates a _new_ account update
  /**
   * Same as `SmartContract.self` but explicitly creates a new {@link AccountUpdate}.
   */
  newSelf() {
    let inTransaction = currentTransaction.has();
    let transactionId = inTransaction ? currentTransaction.id() : NaN;
    let accountUpdate = selfAccountUpdate(this);
    (0, import_tslib3.__classPrivateFieldSet)(this, _SmartContract_executionState, { transactionId, accountUpdate }, "f");
    return accountUpdate;
  }
  /**
   * The public key of the current transaction's sender account.
   *
   * Throws an error if not inside a transaction, or the sender wasn't passed in.
   *
   * **Warning**: The fact that this public key equals the current sender is not part of the proof.
   * A malicious prover could use any other public key without affecting the validity of the proof.
   */
  get sender() {
    if (!currentTransaction.has()) {
      throw Error(`this.sender is not available outside a transaction. Make sure you only use it within \`Mina.transaction\` blocks or smart contract methods.`);
    }
    let transactionId = currentTransaction.id();
    if ((0, import_tslib3.__classPrivateFieldGet)(this, _SmartContract__senderState, "f")?.transactionId === transactionId) {
      return (0, import_tslib3.__classPrivateFieldGet)(this, _SmartContract__senderState, "f").sender;
    } else {
      let sender2 = Circuit.witness(PublicKey2, () => sender());
      (0, import_tslib3.__classPrivateFieldSet)(this, _SmartContract__senderState, { transactionId, sender: sender2 }, "f");
      return sender2;
    }
  }
  /**
   * Current account of the {@link SmartContract}.
   */
  get account() {
    return this.self.account;
  }
  /**
   * Current network state of the {@link SmartContract}.
   */
  get network() {
    return this.self.network;
  }
  /**
   * Current global slot on the network. This is the slot at which this transaction is included in a block. Since we cannot know this value
   * at the time of transaction construction, this only has the `assertBetween()` method but no `get()` (impossible to implement)
   * or `assertEquals()` (confusing, because the developer can't know the exact slot at which this will be included either)
   */
  get currentSlot() {
    return this.self.currentSlot;
  }
  /**
   * Token of the {@link SmartContract}.
   */
  get token() {
    return this.self.token();
  }
  /**
   * Approve an account update or callback. This will include the account update in the zkApp's public input,
   * which means it allows you to read and use its content in a proof, make assertions about it, and modify it.
   *
   * If this is called with a callback as the first parameter, it will first extract the account update produced by that callback.
   * The extracted account update is returned.
   *
   * ```ts
   * \@method myApprovingMethod(callback: Callback) {
   *   let approvedUpdate = this.approve(callback);
   * }
   * ```
   *
   * Under the hood, "approving" just means that the account update is made a child of the zkApp in the
   * tree of account updates that forms the transaction.
   * The second parameter `layout` allows you to also make assertions about the approved update's _own_ children,
   * by specifying a certain expected layout of children. See {@link AccountUpdate.Layout}.
   *
   * @param updateOrCallback
   * @param layout
   * @returns The account update that was approved (needed when passing in a Callback)
   */
  approve(updateOrCallback, layout) {
    let accountUpdate = updateOrCallback instanceof AccountUpdate2 ? updateOrCallback : Circuit.witness(AccountUpdate2, () => updateOrCallback.accountUpdate);
    this.self.approve(accountUpdate, layout);
    return accountUpdate;
  }
  send(args) {
    return this.self.send(args);
  }
  /**
   * @deprecated use `this.account.tokenSymbol`
   */
  get tokenSymbol() {
    return this.self.tokenSymbol;
  }
  /**
   * Balance of this {@link SmartContract}.
   */
  get balance() {
    return this.self.balance;
  }
  // TODO: not able to type event such that it is inferred correctly so far
  /**
   * Emits an event. Events will be emitted as a part of the transaction and can be collected by archive nodes.
   */
  emitEvent(type, event) {
    let accountUpdate = this.self;
    let eventTypes = Object.keys(this.events);
    if (eventTypes.length === 0)
      throw Error(`emitEvent: You are trying to emit an event without having declared the types of your events.
Make sure to add a property \`events\` on ${this.constructor.name}, for example: 
class ${this.constructor.name} extends SmartContract {
  events = { 'my-event': Field }
}`);
    let eventNumber = eventTypes.sort().indexOf(type);
    if (eventNumber === -1)
      throw Error(`emitEvent: Unknown event type "${type}". The declared event types are: ${eventTypes.join(", ")}.`);
    let eventType = this.events[type];
    let eventFields;
    if (eventTypes.length === 1) {
      eventFields = eventType.toFields(event);
    } else {
      eventFields = [Field(eventNumber), ...eventType.toFields(event)];
    }
    accountUpdate.body.events = Events.pushEvent(accountUpdate.body.events, eventFields);
  }
  /**
   * Asynchronously fetches events emitted by this {@link SmartContract} and returns an array of events with their corresponding types.
   * @async
   * @param [start=UInt32.from(0)] - The start height of the events to fetch.
   * @param end - The end height of the events to fetch. If not provided, fetches events up to the latest height.
   * @returns A promise that resolves to an array of objects, each containing the event type and event data for the specified range.
   * @throws If there is an error fetching events from the Mina network.
   * @example
   * const startHeight = UInt32.from(1000);
   * const endHeight = UInt32.from(2000);
   * const events = await myZkapp.fetchEvents(startHeight, endHeight);
   * console.log(events);
   */
  async fetchEvents(start = UInt322.from(0), end) {
    let events = (await fetchEvents2(this.address, this.self.body.tokenId, {
      from: start,
      to: end
    })).filter((eventData) => {
      let height = UInt322.from(eventData.blockHeight);
      return end === void 0 ? start.lessThanOrEqual(height).toBoolean() : start.lessThanOrEqual(height).toBoolean() && height.lessThanOrEqual(end).toBoolean();
    }).map((event) => {
      return event.events.map((eventData) => {
        let { events: events2, ...rest } = event;
        return {
          ...rest,
          event: eventData
        };
      });
    }).flat();
    let sortedEventTypes = Object.keys(this.events).sort();
    return events.map((eventData) => {
      if (sortedEventTypes.length === 1) {
        let type = sortedEventTypes[0];
        let event = this.events[type].fromFields(eventData.event.data.map((f) => Field(f)));
        return {
          ...eventData,
          type,
          event: {
            data: event,
            transactionInfo: {
              transactionHash: eventData.event.transactionInfo.hash,
              transactionStatus: eventData.event.transactionInfo.status,
              transactionMemo: eventData.event.transactionInfo.memo
            }
          }
        };
      } else {
        let eventObjectIndex = Number(eventData.event.data[0]);
        let type = sortedEventTypes[eventObjectIndex];
        let eventProps = eventData.event.data.slice(1);
        let event = this.events[type].fromFields(eventProps.map((f) => Field(f)));
        return {
          ...eventData,
          type,
          event: {
            data: event,
            transactionInfo: {
              transactionHash: eventData.event.transactionInfo.hash,
              transactionStatus: eventData.event.transactionInfo.status,
              transactionMemo: eventData.event.transactionInfo.memo
            }
          }
        };
      }
    });
  }
  static runOutsideCircuit(run) {
    if (currentTransaction()?.isFinalRunOutsideCircuit || inProver())
      Circuit.asProver(run);
  }
  // TODO: this could also be used to quickly perform any invariant checks on account updates construction
  /**
   * This function is run internally before compiling a smart contract, to collect metadata about what each of your
   * smart contract methods does.
   *
   * For external usage, this function can be handy because calling it involves running all methods in the same "mode" as `compile()` does,
   * so it serves as a quick-to-run check for whether your contract can be compiled without errors, which can greatly speed up iterating.
   *
   * `analyzeMethods()` will also return the number of `rows` of each of your method circuits (i.e., the number of constraints in the underlying proof system),
   * which is a good indicator for circuit size and the time it will take to create proofs.
   * To inspect the created circuit in detail, you can look at the returned `gates`.
   *
   * Note: If this function was already called before, it will short-circuit and just return the metadata collected the first time.
   *
   * @returns an object, keyed by method name, each entry containing:
   *  - `rows` the size of the constraint system created by this method
   *  - `digest` a digest of the method circuit
   *  - `hasReturn` a boolean indicating whether the method returns a value
   *  - `actions` the number of actions the method dispatches
   *  - `gates` the constraint system, represented as an array of gates
   */
  static analyzeMethods() {
    let methodMetaData = this._methodMetadata;
    let ZkappClass = this;
    let methodIntfs = ZkappClass._methods ?? [];
    if (!methodIntfs.every((m) => m.methodName in methodMetaData) && !inAnalyze()) {
      if (snarkContext.get().inRunAndCheck) {
        let err = new Error("Can not analyze methods inside Circuit.runAndCheck, because this creates a circuit nested in another circuit");
        err.bootstrap = () => ZkappClass.analyzeMethods();
        throw err;
      }
      for (let methodIntf of methodIntfs) {
        let accountUpdate;
        let { rows, digest, result, gates } = analyzeMethod(ZkappPublicInput, methodIntf, (publicInput, publicKey, tokenId, ...args) => {
          let instance = new ZkappClass(publicKey, tokenId);
          let result2 = instance[methodIntf.methodName](publicInput, ...args);
          accountUpdate = (0, import_tslib3.__classPrivateFieldGet)(instance, _SmartContract_executionState, "f").accountUpdate;
          return result2;
        });
        ZkappClass._methodMetadata[methodIntf.methodName] = {
          actions: accountUpdate.body.actions.data.length,
          rows,
          digest,
          hasReturn: result !== void 0,
          gates
        };
      }
    }
    return ZkappClass._methodMetadata;
  }
  /**
   * @deprecated use `this.account.<field>.set()`
   */
  setValue(maybeValue, value) {
    AccountUpdate2.setValue(maybeValue, value);
  }
  /**
   * @deprecated use `this.account.permissions.set()`
   */
  setPermissions(permissions) {
    this.self.account.permissions.set(permissions);
  }
};
_SmartContract_executionState = /* @__PURE__ */ new WeakMap(), _SmartContract__senderState = /* @__PURE__ */ new WeakMap();
SmartContract._methodMetadata = {};
function getReducer(contract) {
  var _a;
  let reducer = ((_a = contract)._ ?? (_a._ = {})).reducer;
  if (reducer === void 0)
    throw Error(`You are trying to use a reducer without having declared its type.
Make sure to add a property \`reducer\` on ${contract.constructor.name}, for example:
class ${contract.constructor.name} extends SmartContract {
  reducer = { actionType: Field };
}`);
  return {
    dispatch(action) {
      let accountUpdate = contract.self;
      let eventFields = reducer.actionType.toFields(action);
      accountUpdate.body.actions = Actions.pushEvent(accountUpdate.body.actions, eventFields);
    },
    reduce(actionLists, stateType, reduce, { state: state2, actionsHash }, { maxTransactionsWithActions = 32 } = {}) {
      if (actionLists.length > maxTransactionsWithActions) {
        throw Error(`reducer.reduce: Exceeded the maximum number of lists of actions, ${maxTransactionsWithActions}.
Use the optional \`maxTransactionsWithActions\` argument to increase this number.`);
      }
      let methodData = contract.constructor.analyzeMethods();
      let possibleActionsPerTransaction = [
        ...new Set(Object.values(methodData).map((o) => o.actions)).add(0)
      ].sort((x, y) => x - y);
      let possibleActionTypes = possibleActionsPerTransaction.map((n) => circuitArray(reducer.actionType, n));
      for (let i2 = 0; i2 < maxTransactionsWithActions; i2++) {
        let actions = i2 < actionLists.length ? actionLists[i2] : [];
        let length = actions.length;
        let lengths = possibleActionsPerTransaction.map((n) => Circuit.witness(Bool, () => Bool(length === n)));
        let actionss = possibleActionsPerTransaction.map((n, i3) => {
          let type = possibleActionTypes[i3];
          return Circuit.witness(type, () => length === n ? actions : emptyValue(type));
        });
        let eventsHashes = actionss.map((actions2) => {
          let events = actions2.map((a) => reducer.actionType.toFields(a));
          return Actions.hash(events);
        });
        let eventsHash = Circuit.switch(lengths, Field, eventsHashes);
        let newActionsHash = Actions.updateSequenceState(actionsHash, eventsHash);
        let isEmpty = lengths[0];
        actionsHash = Circuit.if(isEmpty, actionsHash, newActionsHash);
        let newStates = actionss.map((actions2) => {
          let newState = Circuit.witness(stateType, () => state2);
          Circuit.assertEqual(stateType, newState, state2);
          [...actions2].reverse().forEach((action) => {
            newState = reduce(newState, action);
          });
          return newState;
        });
        state2 = Circuit.switch(lengths, stateType, newStates);
      }
      contract.account.actionState.assertEquals(actionsHash);
      return { state: state2, actionsHash };
    },
    getActions({ fromActionState, endActionState }) {
      let actionsForAccount = [];
      Circuit.asProver(() => {
        let actions = getActions(contract.address, { fromActionState, endActionState }, contract.self.tokenId);
        actionsForAccount = actions.map((event) => // putting our string-Fields back into the original action type
        event.actions.map((action) => reducer.actionType.fromFields(action.map(Field))));
      });
      return actionsForAccount;
    },
    async fetchActions({ fromActionState, endActionState }) {
      let result = await fetchActions2(contract.address, { fromActionState, endActionState }, contract.self.tokenId);
      if ("error" in result) {
        throw Error(JSON.stringify(result));
      }
      return result.map((event) => // putting our string-Fields back into the original action type
      event.actions.map((action) => reducer.actionType.fromFields(action.map(Field))));
    }
  };
}
var VerificationKey = class extends Struct({
  ...provable2({ data: String, hash: Field }),
  toJSON({ data }) {
    return data;
  }
}) {
};
function selfAccountUpdate(zkapp, methodName) {
  let body = Body.keepAll(zkapp.address, zkapp.tokenId);
  let update = new AccountUpdate2(body, {}, true);
  update.label = methodName ? `${zkapp.constructor.name}.${methodName}()` : `${zkapp.constructor.name}, no method`;
  return update;
}
function Account4(address, tokenId) {
  if (smartContractContext.has()) {
    return AccountUpdate2.create(address, tokenId).account;
  } else {
    return AccountUpdate2.defaultAccountUpdate(address, tokenId).account;
  }
}
function signFeePayer(transactionJson, feePayerKey, { transactionFee = 0, feePayerNonce = void 0, memo: feePayerMemo = void 0 }) {
  let zkappCommand = JSON.parse(transactionJson);
  if (typeof feePayerKey === "string")
    feePayerKey = PrivateKey2.fromBase58(feePayerKey);
  let senderAddress = feePayerKey.toPublicKey();
  if (feePayerNonce === void 0) {
    let senderAccount = getAccount(senderAddress, TokenId3.default);
    feePayerNonce = senderAccount.nonce.toString();
  }
  if (feePayerMemo)
    zkappCommand.memo = Ledger.memoToBase58(feePayerMemo);
  zkappCommand.feePayer.body.nonce = `${feePayerNonce}`;
  zkappCommand.feePayer.body.publicKey = Ledger.publicKeyToString(senderAddress);
  zkappCommand.feePayer.body.fee = `${transactionFee}`;
  return signJsonTransaction(JSON.stringify(zkappCommand), feePayerKey);
}
function declareMethods(SmartContract2, methodArguments) {
  for (let key in methodArguments) {
    let argumentTypes = methodArguments[key];
    let target = SmartContract2.prototype;
    Reflect.metadata("design:paramtypes", argumentTypes)(target, key);
    let descriptor = Object.getOwnPropertyDescriptor(target, key);
    method(SmartContract2.prototype, key, descriptor);
    Object.defineProperty(target, key, descriptor);
  }
}
var Reducer = Object.defineProperty(function(reducer) {
  return reducer;
}, "initialActionsHash", { get: Actions.emptyActionState });
var DEBUG_PUBLIC_INPUT_CHECK = false;

// dist/node/mina-signer/src/memo.js
function fromString(memo) {
  let length = stringLengthInBytes(memo);
  if (length > 32)
    throw Error("Memo.fromString: string too long");
  return `${String.fromCharCode(length)}${memo}` + "\0".repeat(32 - length);
}
function toString(memo) {
  let totalLength = stringLengthInBytes(memo);
  if (totalLength !== 34) {
    throw Error(`Memo.toString: length ${totalLength} does not equal 34`);
  }
  if (memo[0] !== "") {
    throw Error("Memo.toString: expected memo to start with 0x01 byte");
  }
  let length = memo.charCodeAt(1);
  if (length > 32)
    throw Error("Memo.toString: invalid length encoding");
  let bytes = stringToBytes(memo).slice(2, 2 + length);
  return stringFromBytes(bytes);
}
function hash(memo) {
  let bits2 = Memo.toBits(memo);
  let fields = packToFieldsLegacy(HashInputLegacy.bits(bits2));
  return hashWithPrefix2(prefixes.zkappMemo, fields);
}
var SIZE = 34;
var Binable = defineBinable({
  toBytes(memo) {
    return stringToBytes(memo);
  },
  readBytes(bytes, start) {
    let end = start + SIZE;
    let memo = stringFromBytes(bytes.slice(start, end));
    return [memo, end];
  }
});
var Memo = {
  fromString,
  toString,
  hash,
  ...withBits(Binable, SIZE * 8),
  ...base58(Binable, versionBytes.userCommandMemo),
  sizeInBytes() {
    return SIZE;
  },
  emptyValue() {
    return Memo.fromString("");
  },
  toValidString(memo = "") {
    if (stringLengthInBytes(memo) > 32)
      throw Error("Memo: string too long");
    return memo;
  }
};

// dist/node/lib/errors.js
var ErrorHandlers = {
  Invalid_fee_excess({ transaction: { accountUpdates }, isFeePayer, accountCreationFee: accountCreationFee2 }) {
    if (isFeePayer)
      return;
    let balances = accountUpdates.map(({ body }) => {
      if (body.tokenId.equals(TokenId3.default).toBoolean()) {
        return Number(Int64.fromObject(body.balanceChange).toString()) * 1e-9;
      }
    });
    let sum = balances.reduce((a = 0, b2 = 0) => a + b2) ?? 0;
    return `Invalid fee excess.
This means that balance changes in your transaction do not sum up to the amount of fees needed.
Here's the list of balance changes:

${balances.map((balance, i2) => {
      return `Account update #${i2 + 1}) ${balance === void 0 ? "not a MINA account" : `${balance.toFixed(2)} MINA`}`;
    }).join(`
`)}

Total change: ${sum.toFixed(2)} MINA

If there are no new accounts created in your transaction, then this sum should be equal to 0.00 MINA.
If you are creating new accounts -- by updating accounts that didn't exist yet --
then keep in mind the ${(Number(accountCreationFee2) * 1e-9).toFixed(2)} MINA account creation fee, and make sure that the sum equals
${(-Number(accountCreationFee2) * 1e-9).toFixed(2)} times the number of newly created accounts.`;
  }
};
function invalidTransactionError(transaction2, errors, additionalContext) {
  let errorMessages = [];
  let rawErrors = JSON.stringify(errors);
  let errorsForFeePayer = errors[0];
  for (let [error] of errorsForFeePayer) {
    let message = ErrorHandlers[error]?.({
      transaction: transaction2,
      accountUpdateIndex: NaN,
      isFeePayer: true,
      ...additionalContext
    });
    if (message)
      errorMessages.push(message);
  }
  let n = transaction2.accountUpdates.length;
  for (let i2 = 0; i2 < n; i2++) {
    let errorsForUpdate = errors[i2 + 1];
    for (let [error] of errorsForUpdate) {
      let message = ErrorHandlers[error]?.({
        transaction: transaction2,
        accountUpdateIndex: i2,
        isFeePayer: false,
        ...additionalContext
      });
      if (message)
        errorMessages.push(message);
    }
  }
  if (errorMessages.length > 1) {
    return [
      "There were multiple errors when applying your transaction:",
      ...errorMessages.map((msg, i2) => `${i2 + 1}.) ${msg}`),
      `Raw list of errors: ${rawErrors}`
    ].join("\n\n");
  }
  if (errorMessages.length === 1) {
    return `${errorMessages[0]}

Raw list of errors: ${rawErrors}`;
  }
  return rawErrors;
}
function Bug(message) {
  return Error(`${message}
This shouldn't have happened and indicates an internal bug.`);
}
function assert(condition, message = "Failed assertion.") {
  if (!condition)
    throw Bug(message);
}

// dist/node/lib/account_update.js
var ZkappStateLength = 8;
var smartContractContext = Context.create();
var zkAppProver = Prover();
var True = () => Bool(true);
var False = () => Bool(false);
var Permission = {
  /**
   * Modification is impossible.
   */
  impossible: () => ({
    constant: True(),
    signatureNecessary: True(),
    signatureSufficient: False()
  }),
  /**
   * Modification is always permitted
   */
  none: () => ({
    constant: True(),
    signatureNecessary: False(),
    signatureSufficient: True()
  }),
  /**
   * Modification is permitted by zkapp proofs only
   */
  proof: () => ({
    constant: False(),
    signatureNecessary: False(),
    signatureSufficient: False()
  }),
  /**
   * Modification is permitted by signatures only, using the private key of the zkapp account
   */
  signature: () => ({
    constant: False(),
    signatureNecessary: True(),
    signatureSufficient: True()
  }),
  /**
   * Modification is permitted by zkapp proofs or signatures
   */
  proofOrSignature: () => ({
    constant: False(),
    signatureNecessary: False(),
    signatureSufficient: True()
  })
};
var Permissions = {
  ...Permission,
  /**
   * Default permissions are:
   *
   *   {@link Permissions.editState} = {@link Permission.proof}
   *
   *   {@link Permissions.send} = {@link Permission.signature}
   *
   *   {@link Permissions.receive} = {@link Permission.none}
   *
   *   {@link Permissions.setDelegate} = {@link Permission.signature}
   *
   *   {@link Permissions.setPermissions} = {@link Permission.signature}
   *
   *   {@link Permissions.setVerificationKey} = {@link Permission.signature}
   *
   *   {@link Permissions.setZkappUri} = {@link Permission.signature}
   *
   *   {@link Permissions.editActionState} = {@link Permission.proof}
   *
   *   {@link Permissions.setTokenSymbol} = {@link Permission.signature}
   *
   */
  default: () => ({
    editState: Permission.proof(),
    send: Permission.proof(),
    receive: Permission.none(),
    setDelegate: Permission.signature(),
    setPermissions: Permission.signature(),
    setVerificationKey: Permission.signature(),
    setZkappUri: Permission.signature(),
    editActionState: Permission.proof(),
    setTokenSymbol: Permission.signature(),
    incrementNonce: Permission.signature(),
    setVotingFor: Permission.signature(),
    setTiming: Permission.signature(),
    access: Permission.none()
  }),
  initial: () => ({
    editState: Permission.signature(),
    send: Permission.signature(),
    receive: Permission.none(),
    setDelegate: Permission.signature(),
    setPermissions: Permission.signature(),
    setVerificationKey: Permission.signature(),
    setZkappUri: Permission.signature(),
    editActionState: Permission.signature(),
    setTokenSymbol: Permission.signature(),
    incrementNonce: Permission.signature(),
    setVotingFor: Permission.signature(),
    setTiming: Permission.signature(),
    access: Permission.none()
  }),
  dummy: () => ({
    editState: Permission.none(),
    send: Permission.none(),
    receive: Permission.none(),
    access: Permission.none(),
    setDelegate: Permission.none(),
    setPermissions: Permission.none(),
    setVerificationKey: Permission.none(),
    setZkappUri: Permission.none(),
    editActionState: Permission.none(),
    setTokenSymbol: Permission.none(),
    incrementNonce: Permission.none(),
    setVotingFor: Permission.none(),
    setTiming: Permission.none()
  }),
  fromString: (permission) => {
    switch (permission) {
      case "None":
        return Permission.none();
      case "Either":
        return Permission.proofOrSignature();
      case "Proof":
        return Permission.proof();
      case "Signature":
        return Permission.signature();
      case "Impossible":
        return Permission.impossible();
      default:
        throw Error(`Cannot parse invalid permission. ${permission} does not exist.`);
    }
  },
  fromJSON: (permissions) => {
    return Object.fromEntries(Object.entries(permissions).map(([k, v]) => [
      k,
      Permissions.fromString(v)
    ]));
  }
};
var Body = {
  /**
   * A body that doesn't change the underlying account record
   */
  keepAll(publicKey, tokenId, mayUseToken) {
    let { body } = transaction_exports.AccountUpdate.emptyValue();
    body.publicKey = publicKey;
    if (tokenId) {
      body.tokenId = tokenId;
      body.mayUseToken = Circuit.if(tokenId.equals(TokenId3.default), AccountUpdate2.MayUseToken.type, AccountUpdate2.MayUseToken.No, AccountUpdate2.MayUseToken.ParentsOwnToken);
    }
    if (mayUseToken) {
      body.mayUseToken = mayUseToken;
    }
    return body;
  },
  dummy() {
    return transaction_exports.AccountUpdate.emptyValue().body;
  }
};
var FeePayerBody = {
  keepAll(publicKey, nonce) {
    return {
      publicKey,
      nonce,
      fee: UInt642.zero,
      validUntil: void 0
    };
  }
};
var NetworkPrecondition = {
  ignoreAll() {
    let stakingEpochData = {
      ledger: { hash: ignore(Field(0)), totalCurrency: ignore(uint64()) },
      seed: ignore(Field(0)),
      startCheckpoint: ignore(Field(0)),
      lockCheckpoint: ignore(Field(0)),
      epochLength: ignore(uint32())
    };
    let nextEpochData = cloneCircuitValue(stakingEpochData);
    return {
      snarkedLedgerHash: ignore(Field(0)),
      blockchainLength: ignore(uint32()),
      minWindowDensity: ignore(uint32()),
      totalCurrency: ignore(uint64()),
      globalSlotSinceGenesis: ignore(uint32()),
      stakingEpochData,
      nextEpochData
    };
  }
};
function ignore(dummy) {
  return { isSome: Bool(false), value: dummy };
}
var uint32 = () => ({ lower: UInt322.from(0), upper: UInt322.MAXINT() });
var uint64 = () => ({ lower: UInt642.from(0), upper: UInt642.MAXINT() });
var AccountPrecondition = {
  ignoreAll() {
    let appState = [];
    for (let i2 = 0; i2 < ZkappStateLength; ++i2) {
      appState.push(ignore(Field(0)));
    }
    return {
      balance: ignore(uint64()),
      nonce: ignore(uint32()),
      receiptChainHash: ignore(Field(0)),
      delegate: ignore(PublicKey2.empty()),
      state: appState,
      actionState: ignore(Actions.emptyActionState()),
      provedState: ignore(Bool(false)),
      isNew: ignore(Bool(false))
    };
  },
  nonce(nonce) {
    let p3 = AccountPrecondition.ignoreAll();
    AccountUpdate2.assertEquals(p3.nonce, nonce);
    return p3;
  }
};
var GlobalSlotPrecondition = {
  ignoreAll() {
    return ignore(uint32());
  }
};
var Preconditions = {
  ignoreAll() {
    return {
      account: AccountPrecondition.ignoreAll(),
      network: NetworkPrecondition.ignoreAll(),
      validWhile: GlobalSlotPrecondition.ignoreAll()
    };
  }
};
var TokenId3 = {
  ...transaction_exports.TokenId,
  ...TokenId2,
  get default() {
    return Field(1);
  }
};
var Token = class {
  static getId(tokenOwner, parentTokenId = TokenId3.default) {
    if (tokenOwner.isConstant() && parentTokenId.isConstant()) {
      return Ledger.customTokenId(tokenOwner, parentTokenId);
    } else {
      return Ledger.customTokenIdChecked(tokenOwner, parentTokenId);
    }
  }
  constructor({ tokenOwner, parentTokenId = TokenId3.default }) {
    this.parentTokenId = parentTokenId;
    this.tokenOwner = tokenOwner;
    try {
      this.id = Token.getId(tokenOwner, parentTokenId);
    } catch (e) {
      throw new Error(`Could not create a custom token id:
Error: ${e.message}`);
    }
  }
};
Token.Id = TokenId3;
var AccountUpdate2 = class {
  constructor(body, authorization = {}, isSelf = false) {
    this.label = "";
    this.lazyAuthorization = void 0;
    this.children = {
      callsType: { type: "None" },
      accountUpdates: []
    };
    this.parent = void 0;
    this.id = Math.random();
    this.body = body;
    this.authorization = authorization;
    let { account, network, currentSlot: currentSlot2 } = preconditions(this, isSelf);
    this.account = account;
    this.network = network;
    this.currentSlot = currentSlot2;
    this.isSelf = isSelf;
  }
  /**
   * Clones the {@link AccountUpdate}.
   */
  static clone(accountUpdate) {
    let body = cloneCircuitValue(accountUpdate.body);
    let authorization = cloneCircuitValue(accountUpdate.authorization);
    let cloned = new AccountUpdate2(body, authorization, accountUpdate.isSelf);
    cloned.lazyAuthorization = accountUpdate.lazyAuthorization;
    cloned.children.callsType = accountUpdate.children.callsType;
    cloned.children.accountUpdates = accountUpdate.children.accountUpdates.map(AccountUpdate2.clone);
    cloned.id = accountUpdate.id;
    cloned.label = accountUpdate.label;
    cloned.parent = accountUpdate.parent;
    return cloned;
  }
  token() {
    let thisAccountUpdate = this;
    let customToken = new Token({
      tokenOwner: thisAccountUpdate.body.publicKey,
      parentTokenId: thisAccountUpdate.body.tokenId
    });
    return {
      id: customToken.id,
      parentTokenId: customToken.parentTokenId,
      tokenOwner: customToken.tokenOwner,
      mint({ address, amount }) {
        let receiver = AccountUpdate2.defaultAccountUpdate(address, this.id);
        thisAccountUpdate.approve(receiver);
        receiver.body.balanceChange = Int64.fromObject(receiver.body.balanceChange).add(amount);
        return receiver;
      },
      burn({ address, amount }) {
        let sender2 = AccountUpdate2.defaultAccountUpdate(address, this.id);
        thisAccountUpdate.approve(sender2);
        sender2.body.useFullCommitment = Bool(true);
        sender2.body.implicitAccountCreationFee = Bool(false);
        sender2.body.balanceChange = Int64.fromObject(sender2.body.balanceChange).sub(amount);
        Authorization.setLazySignature(sender2);
      },
      send({ from, to, amount }) {
        let sender2 = AccountUpdate2.defaultAccountUpdate(from, this.id);
        thisAccountUpdate.approve(sender2);
        sender2.body.useFullCommitment = Bool(true);
        sender2.body.implicitAccountCreationFee = Bool(false);
        sender2.body.balanceChange = Int64.fromObject(sender2.body.balanceChange).sub(amount);
        Authorization.setLazySignature(sender2);
        let receiverAccountUpdate = createChildAccountUpdate(thisAccountUpdate, to, this.id);
        let i1 = receiverAccountUpdate.body.balanceChange;
        receiverAccountUpdate.body.balanceChange = new Int64(i1.magnitude, i1.sgn).add(amount);
        return receiverAccountUpdate;
      }
    };
  }
  get tokenId() {
    return this.body.tokenId;
  }
  /**
   * @deprecated use `this.account.tokenSymbol`
   */
  get tokenSymbol() {
    let accountUpdate = this;
    return {
      set(tokenSymbol) {
        accountUpdate.account.tokenSymbol.set(tokenSymbol);
      }
    };
  }
  send({ to, amount }) {
    let receiver;
    if (to instanceof AccountUpdate2) {
      receiver = to;
      receiver.body.tokenId.assertEquals(this.body.tokenId);
    } else if (to instanceof SmartContract) {
      receiver = to.self;
      receiver.body.tokenId.assertEquals(this.body.tokenId);
    } else {
      receiver = AccountUpdate2.defaultAccountUpdate(to, this.body.tokenId);
      this.approve(receiver);
    }
    this.body.balanceChange = Int64.fromObject(this.body.balanceChange).sub(amount);
    receiver.body.balanceChange = Int64.fromObject(receiver.body.balanceChange).add(amount);
    return receiver;
  }
  /**
   * Makes an {@link AccountUpdate} a child-{@link AccountUpdate} of this and
   * approves it.
   */
  approve(childUpdate, layout = AccountUpdate2.Layout.NoChildren) {
    makeChildAccountUpdate(this, childUpdate);
    AccountUpdate2.witnessChildren(childUpdate, layout, { skipCheck: true });
  }
  get balance() {
    let accountUpdate = this;
    return {
      addInPlace(x) {
        let { magnitude, sgn } = accountUpdate.body.balanceChange;
        accountUpdate.body.balanceChange = new Int64(magnitude, sgn).add(x);
      },
      subInPlace(x) {
        let { magnitude, sgn } = accountUpdate.body.balanceChange;
        accountUpdate.body.balanceChange = new Int64(magnitude, sgn).sub(x);
      }
    };
  }
  get update() {
    return this.body.update;
  }
  static setValue(maybeValue, value) {
    maybeValue.isSome = Bool(true);
    maybeValue.value = value;
  }
  /**
   * Constrain a property to lie between lower and upper bounds.
   *
   * @param property The property to constrain
   * @param lower The lower bound
   * @param upper The upper bound
   *
   * Example: To constrain the account balance of a SmartContract to lie between
   * 0 and 20 MINA, you can use
   *
   * ```ts
   * \@method onlyRunsWhenBalanceIsLow() {
   *   let lower = UInt64.zero;
   *   let upper = UInt64.from(20e9);
   *   AccountUpdate.assertBetween(this.self.body.preconditions.account.balance, lower, upper);
   *   // ...
   * }
   * ```
   */
  static assertBetween(property, lower, upper) {
    property.isSome = Bool(true);
    property.value.lower = lower;
    property.value.upper = upper;
  }
  // TODO: assertGreaterThan, assertLowerThan?
  /**
   * Fix a property to a certain value.
   *
   * @param property The property to constrain
   * @param value The value it is fixed to
   *
   * Example: To fix the account nonce of a SmartContract to 0, you can use
   *
   * ```ts
   * \@method onlyRunsWhenNonceIsZero() {
   *   AccountUpdate.assertEquals(this.self.body.preconditions.account.nonce, UInt32.zero);
   *   // ...
   * }
   * ```
   */
  static assertEquals(property, value) {
    property.isSome = Bool(true);
    if ("lower" in property.value && "upper" in property.value) {
      property.value.lower = value;
      property.value.upper = value;
    } else {
      property.value = value;
    }
  }
  get publicKey() {
    return this.body.publicKey;
  }
  /**
   * Use this command if this account update should be signed by the account
   * owner, instead of not having any authorization.
   *
   * If you use this and are not relying on a wallet to sign your transaction,
   * then you should use the following code before sending your transaction:
   *
   * ```ts
   * let tx = Mina.transaction(...); // create transaction as usual, using `requireSignature()` somewhere
   * tx.sign([privateKey]); // pass the private key of this account to `sign()`!
   * ```
   *
   * Note that an account's {@link Permissions} determine which updates have to
   * be (can be) authorized by a signature.
   */
  requireSignature() {
    this.sign();
  }
  /**
   * @deprecated `.sign()` is deprecated in favor of `.requireSignature()`
   */
  sign(privateKey) {
    let { nonce, isSameAsFeePayer } = AccountUpdate2.getSigningInfo(this);
    this.body.useFullCommitment = isSameAsFeePayer;
    this.body.implicitAccountCreationFee = Bool(false);
    let doIncrementNonce = isSameAsFeePayer.not();
    this.body.incrementNonce = doIncrementNonce;
    let lower = Circuit.if(doIncrementNonce, UInt322, nonce, UInt322.zero);
    let upper = Circuit.if(doIncrementNonce, UInt322, nonce, UInt322.MAXINT());
    this.body.preconditions.account.nonce.isSome = doIncrementNonce;
    this.body.preconditions.account.nonce.value.lower = lower;
    this.body.preconditions.account.nonce.value.upper = upper;
    Authorization.setLazySignature(this, { privateKey });
  }
  static signFeePayerInPlace(feePayer, privateKey) {
    feePayer.body.nonce = this.getNonce(feePayer);
    feePayer.authorization = Ledger.dummySignature();
    feePayer.lazyAuthorization = { kind: "lazy-signature", privateKey };
  }
  static getNonce(accountUpdate) {
    return AccountUpdate2.getSigningInfo(accountUpdate).nonce;
  }
  static getSigningInfo(accountUpdate) {
    return memoizeWitness(AccountUpdate2.signingInfo, () => AccountUpdate2.getSigningInfoUnchecked(accountUpdate));
  }
  static getSigningInfoUnchecked(update) {
    let publicKey = update.body.publicKey;
    let tokenId = update instanceof AccountUpdate2 ? update.body.tokenId : TokenId3.default;
    let nonce = Number(getAccountPreconditions(update.body).nonce.toString());
    let isFeePayer = currentTransaction()?.sender?.equals(publicKey);
    let isSameAsFeePayer = !!isFeePayer?.and(tokenId.equals(TokenId3.default)).toBoolean();
    if (isSameAsFeePayer)
      nonce++;
    CallForest.forEachPredecessor(currentTransaction.get().accountUpdates, update, (otherUpdate) => {
      let shouldIncreaseNonce = otherUpdate.publicKey.equals(publicKey).and(otherUpdate.tokenId.equals(tokenId)).and(otherUpdate.body.incrementNonce);
      if (shouldIncreaseNonce.toBoolean())
        nonce++;
    });
    return {
      nonce: UInt322.from(nonce),
      isSameAsFeePayer: Bool(isSameAsFeePayer)
    };
  }
  toJSON() {
    return transaction_exports.AccountUpdate.toJSON(this);
  }
  static toJSON(a) {
    return transaction_exports.AccountUpdate.toJSON(a);
  }
  static fromJSON(json) {
    let accountUpdate = transaction_exports.AccountUpdate.fromJSON(json);
    return new AccountUpdate2(accountUpdate.body, accountUpdate.authorization);
  }
  hash() {
    if (inCheckedComputation()) {
      let input = transaction_exports.AccountUpdate.toInput(this);
      return hashWithPrefix(prefixes.body, packToFields(input));
    } else {
      let json = transaction_exports.AccountUpdate.toJSON(this);
      return Ledger.hashAccountUpdateFromJson(JSON.stringify(json));
    }
  }
  toPublicInput() {
    let accountUpdate = this.hash();
    let calls = CallForest.hashChildren(this);
    return { accountUpdate, calls };
  }
  static defaultAccountUpdate(address, tokenId) {
    return new AccountUpdate2(Body.keepAll(address, tokenId));
  }
  static dummy() {
    return new AccountUpdate2(Body.dummy());
  }
  isDummy() {
    return this.body.publicKey.isEmpty();
  }
  static defaultFeePayer(address, nonce) {
    let body = FeePayerBody.keepAll(address, nonce);
    return {
      body,
      authorization: Ledger.dummySignature(),
      lazyAuthorization: { kind: "lazy-signature" }
    };
  }
  static dummyFeePayer() {
    let body = FeePayerBody.keepAll(PublicKey2.empty(), UInt322.zero);
    return { body, authorization: Ledger.dummySignature() };
  }
  /**
   * Creates an account update. If this is inside a transaction, the account
   * update becomes part of the transaction. If this is inside a smart contract
   * method, the account update will not only become part of the transaction,
   * but also becomes available for the smart contract to modify, in a way that
   * becomes part of the proof.
   */
  static create(publicKey, tokenId) {
    let accountUpdate = AccountUpdate2.defaultAccountUpdate(publicKey, tokenId);
    if (smartContractContext.has()) {
      smartContractContext.get().this.self.approve(accountUpdate);
    } else {
      currentTransaction()?.accountUpdates.push(accountUpdate);
    }
    return accountUpdate;
  }
  /**
   * Attach account update to the current transaction
   * -- if in a smart contract, to its children
   */
  static attachToTransaction(accountUpdate) {
    if (smartContractContext.has()) {
      let selfUpdate = smartContractContext.get().this.self;
      if (selfUpdate === accountUpdate)
        return;
      smartContractContext.get().this.self.approve(accountUpdate);
    } else {
      if (!currentTransaction.has())
        return;
      let updates = currentTransaction.get().accountUpdates;
      if (!updates.find((update) => update.id === accountUpdate.id)) {
        updates.push(accountUpdate);
      }
    }
  }
  /**
   * Disattach an account update from where it's currently located in the transaction
   */
  static unlink(accountUpdate) {
    let siblings = accountUpdate.parent?.children.accountUpdates ?? currentTransaction()?.accountUpdates;
    if (siblings === void 0)
      return;
    let i2 = siblings?.findIndex((update) => update.id === accountUpdate.id);
    if (i2 !== void 0 && i2 !== -1) {
      siblings.splice(i2, 1);
    }
    accountUpdate.parent === void 0;
  }
  static createSigned(signer, tokenId) {
    let publicKey = signer instanceof PrivateKey2 ? signer.toPublicKey() : signer;
    let accountUpdate = AccountUpdate2.create(publicKey, tokenId);
    if (signer instanceof PrivateKey2) {
      accountUpdate.sign(signer);
    } else {
      accountUpdate.requireSignature();
    }
    return accountUpdate;
  }
  static fundNewAccount(feePayer, numberOfAccounts) {
    let accountUpdate = AccountUpdate2.createSigned(feePayer);
    let fee = accountCreationFee();
    numberOfAccounts ?? (numberOfAccounts = 1);
    if (typeof numberOfAccounts === "number")
      fee = fee.mul(numberOfAccounts);
    else
      fee = fee.add(UInt642.from(numberOfAccounts.initialBalance ?? 0));
    accountUpdate.balance.subInPlace(fee);
    return accountUpdate;
  }
  static toAuxiliary(a) {
    let aux = transaction_exports.AccountUpdate.toAuxiliary(a);
    let children = {
      callsType: { type: "None" },
      accountUpdates: []
    };
    let lazyAuthorization = a && a.lazyAuthorization;
    if (a) {
      children.callsType = a.children.callsType;
      children.accountUpdates = a.children.accountUpdates.map(AccountUpdate2.clone);
    }
    let parent = a?.parent;
    let id = a?.id ?? Math.random();
    let label = a?.label ?? "";
    return [{ lazyAuthorization, children, parent, id, label }, aux];
  }
  static fromFields(fields, [other, aux]) {
    let accountUpdate = transaction_exports.AccountUpdate.fromFields(fields, aux);
    return Object.assign(new AccountUpdate2(accountUpdate.body, accountUpdate.authorization), other);
  }
  static witness(type, compute, { skipCheck = false } = {}) {
    let accountUpdateType = skipCheck ? { ...provable2(AccountUpdate2), check() {
    } } : AccountUpdate2;
    let combinedType = provable2({
      accountUpdate: accountUpdateType,
      result: type
    });
    return Circuit.witness(combinedType, compute);
  }
  static witnessChildren(accountUpdate, childLayout, options) {
    if (childLayout === AccountUpdate2.Layout.AnyChildren) {
      accountUpdate.children.callsType = { type: "Witness" };
      return;
    }
    if (childLayout === AccountUpdate2.Layout.NoDelegation) {
      accountUpdate.children.callsType = { type: "Witness" };
      accountUpdate.body.mayUseToken.parentsOwnToken.assertFalse();
      accountUpdate.body.mayUseToken.inheritFromParent.assertFalse();
      return;
    }
    let childArray = typeof childLayout === "number" ? Array(childLayout).fill(AccountUpdate2.Layout.NoChildren) : childLayout;
    let n = childArray.length;
    for (let i2 = 0; i2 < n; i2++) {
      accountUpdate.children.accountUpdates[i2] = AccountUpdate2.witnessTree(provable2(null), childArray[i2], () => ({
        accountUpdate: accountUpdate.children.accountUpdates[i2] ?? AccountUpdate2.dummy(),
        result: null
      }), options).accountUpdate;
    }
    if (n === 0) {
      accountUpdate.children.callsType = {
        type: "Equals",
        value: CallForest.emptyHash()
      };
    }
  }
  /**
   * Like AccountUpdate.witness, but lets you specify a layout for the
   * accountUpdate's children, which also get witnessed
   */
  static witnessTree(resultType, childLayout, compute, options) {
    let { accountUpdate, result } = AccountUpdate2.witness(resultType, compute, options);
    AccountUpdate2.witnessChildren(accountUpdate, childLayout, options);
    return { accountUpdate, result };
  }
  static get MayUseToken() {
    return {
      type: provablePure({ parentsOwnToken: Bool, inheritFromParent: Bool }, { customObjectKeys: ["parentsOwnToken", "inheritFromParent"] }),
      No: { parentsOwnToken: Bool(false), inheritFromParent: Bool(false) },
      ParentsOwnToken: {
        parentsOwnToken: Bool(true),
        inheritFromParent: Bool(false)
      },
      InheritFromParent: {
        parentsOwnToken: Bool(false),
        inheritFromParent: Bool(true)
      },
      isNo({ body: { mayUseToken: { parentsOwnToken, inheritFromParent } } }) {
        return parentsOwnToken.or(inheritFromParent).not();
      },
      isParentsOwnToken(a) {
        return a.body.mayUseToken.parentsOwnToken;
      },
      isInheritFromParent(a) {
        return a.body.mayUseToken.inheritFromParent;
      }
    };
  }
  /**
   * Returns a JSON representation of only the fields that differ from the
   * default {@link AccountUpdate}.
   */
  toPretty() {
    function short(s) {
      return ".." + s.slice(-4);
    }
    let jsonUpdate = toJSONEssential(jsLayout.AccountUpdate, this);
    let body = jsonUpdate.body;
    delete body.callData;
    body.publicKey = short(body.publicKey);
    if (body.balanceChange?.magnitude === "0")
      delete body.balanceChange;
    if (body.tokenId === TokenId3.toBase58(TokenId3.default)) {
      delete body.tokenId;
    } else {
      body.tokenId = short(body.tokenId);
    }
    if (body.callDepth === 0)
      delete body.callDepth;
    if (body.incrementNonce === false)
      delete body.incrementNonce;
    if (body.useFullCommitment === false)
      delete body.useFullCommitment;
    if (body.implicitAccountCreationFee === false)
      delete body.implicitAccountCreationFee;
    if (body.events?.length === 0)
      delete body.events;
    if (body.actions?.length === 0)
      delete body.actions;
    if (body.preconditions?.account) {
      body.preconditions.account = JSON.stringify(body.preconditions.account);
    }
    if (body.preconditions?.network) {
      body.preconditions.network = JSON.stringify(body.preconditions.network);
    }
    if (body.preconditions?.validWhile) {
      body.preconditions.validWhile = JSON.stringify(body.preconditions.validWhile);
    }
    if (jsonUpdate.authorization?.proof) {
      jsonUpdate.authorization.proof = short(jsonUpdate.authorization.proof);
    }
    if (jsonUpdate.authorization?.signature) {
      jsonUpdate.authorization.signature = short(jsonUpdate.authorization.signature);
    }
    if (body.update?.verificationKey) {
      body.update.verificationKey = JSON.stringify({
        data: short(body.update.verificationKey.data),
        hash: short(body.update.verificationKey.hash)
      });
    }
    for (let key of ["permissions", "appState", "timing"]) {
      if (body.update?.[key]) {
        body.update[key] = JSON.stringify(body.update[key]);
      }
    }
    for (let key of ["events", "actions"]) {
      if (body[key]) {
        body[key] = JSON.stringify(body[key]);
      }
    }
    if (jsonUpdate.authorization !== void 0 || body.authorizationKind?.isProved === true || body.authorizationKind?.isSigned === true) {
      body.authorization = jsonUpdate.authorization;
    }
    body.mayUseToken = {
      parentsOwnToken: this.body.mayUseToken.parentsOwnToken.toBoolean(),
      inheritFromParent: this.body.mayUseToken.inheritFromParent.toBoolean()
    };
    let pretty = { ...body };
    let withId = false;
    if (withId)
      pretty = { id: Math.floor(this.id * 1e3), ...pretty };
    if (this.label)
      pretty = { label: this.label, ...pretty };
    return pretty;
  }
};
AccountUpdate2.Actions = Actions;
AccountUpdate2.signingInfo = provable2({
  nonce: UInt322,
  isSameAsFeePayer: Bool
});
AccountUpdate2.sizeInFields = transaction_exports.AccountUpdate.sizeInFields;
AccountUpdate2.toFields = transaction_exports.AccountUpdate.toFields;
AccountUpdate2.toInput = transaction_exports.AccountUpdate.toInput;
AccountUpdate2.check = transaction_exports.AccountUpdate.check;
AccountUpdate2.Layout = {
  StaticChildren: (...args) => {
    if (args.length === 1 && typeof args[0] === "number")
      return args[0];
    if (args.length === 0)
      return 0;
    return args;
  },
  NoChildren: 0,
  AnyChildren: "AnyChildren",
  NoDelegation: "NoDelegation"
};
var CallForest = {
  // similar to Mina_base.ZkappCommand.Call_forest.to_account_updates_list
  // takes a list of accountUpdates, which each can have children, so they form a "forest" (list of trees)
  // returns a flattened list, with `accountUpdate.body.callDepth` specifying positions in the forest
  // also removes any "dummy" accountUpdates
  toFlatList(forest, mutate = true, depth = 0) {
    let accountUpdates = [];
    for (let accountUpdate of forest) {
      if (accountUpdate.isDummy().toBoolean())
        continue;
      if (mutate)
        accountUpdate.body.callDepth = depth;
      let children = accountUpdate.children.accountUpdates;
      accountUpdates.push(accountUpdate, ...CallForest.toFlatList(children, mutate, depth + 1));
    }
    return accountUpdates;
  },
  // Mina_base.Zkapp_command.Digest.Forest.empty
  emptyHash() {
    return Field(0);
  },
  // similar to Mina_base.Zkapp_command.Call_forest.accumulate_hashes
  // hashes a accountUpdate's children (and their children, and ...) to compute
  // the `calls` field of ZkappPublicInput
  hashChildren(update) {
    let { callsType } = update.children;
    if (callsType.type === "Witness") {
      return Circuit.witness(Field, () => CallForest.hashChildrenBase(update));
    }
    let calls = CallForest.hashChildrenBase(update);
    if (callsType.type === "Equals" && inCheckedComputation()) {
      calls.assertEquals(callsType.value);
    }
    return calls;
  },
  hashChildrenBase({ children }) {
    let stackHash = CallForest.emptyHash();
    for (let accountUpdate of [...children.accountUpdates].reverse()) {
      let calls = CallForest.hashChildren(accountUpdate);
      let nodeHash = hashWithPrefix(prefixes.accountUpdateNode, [
        accountUpdate.hash(),
        calls
      ]);
      let newHash = hashWithPrefix(prefixes.accountUpdateCons, [
        nodeHash,
        stackHash
      ]);
      stackHash = Circuit.if(accountUpdate.isDummy(), stackHash, newHash);
    }
    return stackHash;
  },
  // Mina_base.Zkapp_command.Call_forest.add_callers
  // TODO: currently unused, but could come back when we add caller to the
  // public input
  addCallers(updates, context = {
    self: TokenId3.default,
    caller: TokenId3.default
  }) {
    let withCallers = [];
    for (let update of updates) {
      let { mayUseToken } = update.body;
      let caller = Circuit.if(mayUseToken.parentsOwnToken, context.self, Circuit.if(mayUseToken.inheritFromParent, context.caller, TokenId3.default));
      let self = Token.getId(update.body.publicKey, update.body.tokenId);
      let childContext = { caller, self };
      withCallers.push({
        accountUpdate: update,
        caller,
        children: CallForest.addCallers(update.children.accountUpdates, childContext)
      });
    }
    return withCallers;
  },
  /**
   * Used in the prover to witness the context from which to compute its caller
   *
   * TODO: currently unused, but could come back when we add caller to the
   * public input
   */
  computeCallerContext(update) {
    let current = update;
    let ancestors = [];
    while (true) {
      let parent = current.parent;
      if (parent === void 0)
        break;
      ancestors.unshift(parent);
      current = parent;
    }
    let context = { self: TokenId3.default, caller: TokenId3.default };
    for (let update2 of ancestors) {
      if (update2.body.mayUseToken.parentsOwnToken.toBoolean()) {
        context.caller = context.self;
      } else if (!update2.body.mayUseToken.inheritFromParent.toBoolean()) {
        context.caller = TokenId3.default;
      }
      context.self = Token.getId(update2.body.publicKey, update2.body.tokenId);
    }
    return context;
  },
  callerContextType: provablePure({ self: Field, caller: Field }),
  computeCallDepth(update) {
    for (let callDepth = 0; ; callDepth++) {
      if (update.parent === void 0)
        return callDepth;
      update = update.parent;
    }
  },
  map(updates, map) {
    let newUpdates = [];
    for (let update of updates) {
      let newUpdate = map(update);
      newUpdate.children.accountUpdates = CallForest.map(update.children.accountUpdates, map);
      newUpdates.push(newUpdate);
    }
    return newUpdates;
  },
  forEach(updates, callback) {
    for (let update of updates) {
      callback(update);
      CallForest.forEach(update.children.accountUpdates, callback);
    }
  },
  forEachPredecessor(updates, update, callback) {
    let isPredecessor = true;
    CallForest.forEach(updates, (otherUpdate) => {
      if (otherUpdate.id === update.id)
        isPredecessor = false;
      if (isPredecessor)
        callback(otherUpdate);
    });
  }
};
function createChildAccountUpdate(parent, childAddress, tokenId) {
  let child = AccountUpdate2.defaultAccountUpdate(childAddress, tokenId);
  makeChildAccountUpdate(parent, child);
  return child;
}
function makeChildAccountUpdate(parent, child) {
  child.body.callDepth = parent.body.callDepth + 1;
  let wasChildAlready = parent.children.accountUpdates.find((update) => update.id === child.id);
  if (!wasChildAlready) {
    parent.children.accountUpdates.push(child);
    AccountUpdate2.unlink(child);
  }
  child.parent = parent;
}
var ZkappCommand2 = {
  toPretty(transaction2) {
    let feePayer = ZkappCommand2.toJSON(transaction2).feePayer;
    feePayer.body.publicKey = ".." + feePayer.body.publicKey.slice(-4);
    feePayer.body.authorization = ".." + feePayer.authorization.slice(-4);
    if (feePayer.body.validUntil === null)
      delete feePayer.body.validUntil;
    return [
      feePayer.body,
      ...transaction2.accountUpdates.map((a) => a.toPretty())
    ];
  },
  fromJSON(json) {
    let { feePayer } = transaction_exports.ZkappCommand.fromJSON({
      feePayer: json.feePayer,
      accountUpdates: [],
      memo: json.memo
    });
    let memo = Memo.toString(Memo.fromBase58(json.memo));
    let accountUpdates = json.accountUpdates.map(AccountUpdate2.fromJSON);
    return { feePayer, accountUpdates, memo };
  },
  toJSON({ feePayer, accountUpdates, memo }) {
    memo = Ledger.memoToBase58(memo);
    return transaction_exports.ZkappCommand.toJSON({ feePayer, accountUpdates, memo });
  }
};
var Authorization = {
  hasLazyProof(accountUpdate) {
    return accountUpdate.lazyAuthorization?.kind === "lazy-proof";
  },
  hasAny(accountUpdate) {
    let { authorization: auth, lazyAuthorization: lazyAuth } = accountUpdate;
    return !!(lazyAuth || "proof" in auth || "signature" in auth);
  },
  setSignature(accountUpdate, signature) {
    accountUpdate.authorization = { signature };
    accountUpdate.lazyAuthorization = void 0;
  },
  setProof(accountUpdate, proof) {
    accountUpdate.authorization = { proof };
    accountUpdate.lazyAuthorization = void 0;
  },
  setLazySignature(accountUpdate, signature) {
    signature ?? (signature = {});
    accountUpdate.body.authorizationKind.isSigned = Bool(true);
    accountUpdate.body.authorizationKind.isProved = Bool(false);
    accountUpdate.authorization = {};
    accountUpdate.lazyAuthorization = { ...signature, kind: "lazy-signature" };
  },
  setProofAuthorizationKind({ body, id }, priorAccountUpdates) {
    body.authorizationKind.isSigned = Bool(false);
    body.authorizationKind.isProved = Bool(true);
    let hash2 = Circuit.witness(Field, () => {
      let proverData = zkAppProver.getData();
      let isProver = proverData !== void 0;
      assert(isProver || priorAccountUpdates !== void 0, "Called `setProofAuthorizationKind()` outside the prover without passing in `priorAccountUpdates`.");
      let myAccountUpdateId = isProver ? proverData.accountUpdate.id : id;
      priorAccountUpdates ?? (priorAccountUpdates = proverData.transaction.accountUpdates);
      priorAccountUpdates = priorAccountUpdates.filter((a) => a.id !== myAccountUpdateId);
      let priorAccountUpdatesFlat = CallForest.toFlatList(priorAccountUpdates, false);
      let accountUpdate = [...priorAccountUpdatesFlat].reverse().find((body_) => body_.update.verificationKey.isSome.and(body_.tokenId.equals(body.tokenId)).and(body_.publicKey.equals(body.publicKey)).toBoolean());
      if (accountUpdate !== void 0) {
        return accountUpdate.body.update.verificationKey.value.hash;
      }
      try {
        let account = getAccount(body.publicKey, body.tokenId);
        return account.zkapp?.verificationKey?.hash ?? Field(0);
      } catch {
        return Field(0);
      }
    });
    body.authorizationKind.verificationKeyHash = hash2;
  },
  setLazyProof(accountUpdate, proof, priorAccountUpdates) {
    Authorization.setProofAuthorizationKind(accountUpdate, priorAccountUpdates);
    accountUpdate.authorization = {};
    accountUpdate.lazyAuthorization = { ...proof, kind: "lazy-proof" };
  },
  setLazyNone(accountUpdate) {
    accountUpdate.body.authorizationKind.isSigned = Bool(false);
    accountUpdate.body.authorizationKind.isProved = Bool(false);
    accountUpdate.authorization = {};
    accountUpdate.lazyAuthorization = { kind: "lazy-none" };
  }
};
function addMissingSignatures(zkappCommand, additionalKeys = []) {
  let additionalPublicKeys = additionalKeys.map((sk) => sk.toPublicKey());
  let { commitment, fullCommitment } = Ledger.transactionCommitments(JSON.stringify(ZkappCommand2.toJSON(zkappCommand)));
  function addFeePayerSignature(accountUpdate) {
    let { body, authorization, lazyAuthorization } = cloneCircuitValue(accountUpdate);
    if (lazyAuthorization === void 0)
      return { body, authorization };
    let { privateKey } = lazyAuthorization;
    if (privateKey === void 0) {
      let i2 = additionalPublicKeys.findIndex((pk) => pk.equals(accountUpdate.body.publicKey).toBoolean());
      if (i2 === -1) {
        let pk = PublicKey2.toBase58(accountUpdate.body.publicKey);
        throw Error(`addMissingSignatures: Cannot add signature for fee payer (${pk}), private key is missing.`);
      }
      privateKey = additionalKeys[i2];
    }
    let signature = Ledger.signFieldElement(fullCommitment, privateKey, false);
    return { body, authorization: signature };
  }
  function addSignature(accountUpdate) {
    accountUpdate = AccountUpdate2.clone(accountUpdate);
    if (accountUpdate.lazyAuthorization?.kind !== "lazy-signature") {
      return accountUpdate;
    }
    let { privateKey } = accountUpdate.lazyAuthorization;
    if (privateKey === void 0) {
      let i2 = additionalPublicKeys.findIndex((pk) => pk.equals(accountUpdate.body.publicKey).toBoolean());
      if (i2 === -1)
        throw Error(`addMissingSignatures: Cannot add signature for ${accountUpdate.publicKey.toBase58()}, private key is missing.`);
      privateKey = additionalKeys[i2];
    }
    let transactionCommitment = accountUpdate.body.useFullCommitment.toBoolean() ? fullCommitment : commitment;
    let signature = Ledger.signFieldElement(transactionCommitment, privateKey, false);
    Authorization.setSignature(accountUpdate, signature);
    return accountUpdate;
  }
  let { feePayer, accountUpdates, memo } = zkappCommand;
  return {
    feePayer: addFeePayerSignature(feePayer),
    accountUpdates: accountUpdates.map(addSignature),
    memo
  };
}
var ZkappPublicInput = provablePure({ accountUpdate: Field, calls: Field }, { customObjectKeys: ["accountUpdate", "calls"] });
async function addMissingProofs(zkappCommand, { proofsEnabled = true }) {
  async function addProof(index, accountUpdate) {
    accountUpdate = AccountUpdate2.clone(accountUpdate);
    if (accountUpdate.lazyAuthorization?.kind !== "lazy-proof") {
      return {
        accountUpdateProved: accountUpdate,
        proof: void 0
      };
    }
    if (!proofsEnabled) {
      Authorization.setProof(accountUpdate, Pickles.dummyBase64Proof());
      return {
        accountUpdateProved: accountUpdate,
        proof: void 0
      };
    }
    let { methodName, args, previousProofs, ZkappClass, memoized, blindingValue } = accountUpdate.lazyAuthorization;
    let publicInput = accountUpdate.toPublicInput();
    let publicInputFields = ZkappPublicInput.toFields(publicInput);
    if (ZkappClass._provers === void 0)
      throw Error(`Cannot prove execution of ${methodName}(), no prover found. Try calling \`await ${ZkappClass.name}.compile()\` first, this will cache provers in the background.`);
    let provers = ZkappClass._provers;
    let methodError2 = `Error when computing proofs: Method ${methodName} not found. Make sure your environment supports decorators, and annotate with \`@method ${methodName}\`.`;
    if (ZkappClass._methods === void 0)
      throw Error(methodError2);
    let i2 = ZkappClass._methods.findIndex((m) => m.methodName === methodName);
    if (i2 === -1)
      throw Error(methodError2);
    let [, [, proof]] = await zkAppProver.run([accountUpdate.publicKey, accountUpdate.tokenId, ...args], { transaction: zkappCommand, accountUpdate, index }, () => memoizationContext.runWithAsync({ memoized, currentIndex: 0, blindingValue }, async () => {
      try {
        return await provers[i2](publicInputFields, previousProofs);
      } catch (err) {
        console.error(`Error when proving ${ZkappClass.name}.${methodName}()`);
        throw err;
      }
    }));
    Authorization.setProof(accountUpdate, Pickles.proofToBase64Transaction(proof));
    let maxProofsVerified = ZkappClass._maxProofsVerified;
    const Proof2 = ZkappClass.Proof();
    return {
      accountUpdateProved: accountUpdate,
      proof: new Proof2({ publicInput, proof, maxProofsVerified })
    };
  }
  let { feePayer, accountUpdates, memo } = zkappCommand;
  let accountUpdatesProved = [];
  let proofs = [];
  for (let i2 = 0; i2 < accountUpdates.length; i2++) {
    let { accountUpdateProved, proof } = await addProof(i2, accountUpdates[i2]);
    accountUpdatesProved.push(accountUpdateProved);
    proofs.push(proof);
  }
  return {
    zkappCommand: { feePayer, accountUpdates: accountUpdatesProved, memo },
    proofs
  };
}
function signJsonTransaction(transactionJson, privateKey) {
  if (typeof privateKey === "string")
    privateKey = PrivateKey2.fromBase58(privateKey);
  let publicKey = privateKey.toPublicKey().toBase58();
  let zkappCommand = JSON.parse(transactionJson);
  let feePayer = zkappCommand.feePayer;
  if (feePayer.body.publicKey === publicKey) {
    zkappCommand = JSON.parse(Ledger.signFeePayer(JSON.stringify(zkappCommand), privateKey));
  }
  for (let i2 = 0; i2 < zkappCommand.accountUpdates.length; i2++) {
    let accountUpdate = zkappCommand.accountUpdates[i2];
    if (accountUpdate.body.publicKey === publicKey && accountUpdate.authorization.proof === null) {
      zkappCommand = JSON.parse(Ledger.signOtherAccountUpdate(JSON.stringify(zkappCommand), privateKey, i2));
    }
  }
  return JSON.stringify(zkappCommand);
}

// dist/node/lib/mina.js
var Transaction = {
  fromJSON(json) {
    let transaction2 = ZkappCommand2.fromJSON(json);
    return newTransaction(transaction2, activeInstance.proofsEnabled);
  }
};
var currentTransaction = Context.create();
function reportGetAccountError(publicKey, tokenId) {
  if (tokenId === TokenId3.toBase58(TokenId3.default)) {
    return `getAccount: Could not find account for public key ${publicKey}`;
  } else {
    return `getAccount: Could not find account for public key ${publicKey} with the tokenId ${tokenId}`;
  }
}
function createTransaction(feePayer, f, numberOfRuns, { fetchMode = "cached", isFinalRunOutsideCircuit = true, proofsEnabled = true } = {}) {
  if (currentTransaction.has()) {
    throw new Error("Cannot start new transaction within another transaction");
  }
  let feePayerSpec;
  if (feePayer === void 0) {
    feePayerSpec = {};
  } else if (feePayer instanceof PrivateKey2) {
    feePayerSpec = { feePayerKey: feePayer, sender: feePayer.toPublicKey() };
  } else if (feePayer instanceof PublicKey2) {
    feePayerSpec = { sender: feePayer };
  } else {
    feePayerSpec = feePayer;
    if (feePayerSpec.sender === void 0)
      feePayerSpec.sender = feePayerSpec.feePayerKey?.toPublicKey();
  }
  let { feePayerKey, sender: sender2, fee, memo = "", nonce } = feePayerSpec;
  let transactionId = currentTransaction.enter({
    sender: sender2,
    accountUpdates: [],
    fetchMode,
    isFinalRunOutsideCircuit,
    numberOfRuns
  });
  try {
    let err;
    while (true) {
      if (err !== void 0)
        err.bootstrap();
      try {
        if (fetchMode === "test") {
          Circuit.runUnchecked(() => {
            f();
            Circuit.asProver(() => {
              let tx = currentTransaction.get();
              tx.accountUpdates = CallForest.map(tx.accountUpdates, (a) => toConstant(AccountUpdate2, a));
            });
          });
        } else {
          f();
        }
        break;
      } catch (err_) {
        if (err_?.bootstrap)
          err = err_;
        else
          throw err_;
      }
    }
  } catch (err) {
    currentTransaction.leave(transactionId);
    throw err;
  }
  let accountUpdates = currentTransaction.get().accountUpdates;
  accountUpdates = CallForest.toFlatList(accountUpdates);
  try {
    for (let accountUpdate of accountUpdates) {
      assertPreconditionInvariants(accountUpdate);
    }
  } catch (err) {
    currentTransaction.leave(transactionId);
    throw err;
  }
  let feePayerAccountUpdate;
  if (sender2 !== void 0) {
    let nonce_;
    let senderAccount = getAccount(sender2, TokenId3.default);
    if (nonce === void 0) {
      nonce_ = senderAccount.nonce;
    } else {
      nonce_ = UInt322.from(nonce);
      senderAccount.nonce = nonce_;
      addCachedAccount(senderAccount);
    }
    feePayerAccountUpdate = AccountUpdate2.defaultFeePayer(sender2, nonce_);
    if (feePayerKey !== void 0)
      feePayerAccountUpdate.lazyAuthorization.privateKey = feePayerKey;
    if (fee !== void 0) {
      feePayerAccountUpdate.body.fee = fee instanceof UInt642 ? fee : UInt642.from(String(fee));
    }
  } else {
    feePayerAccountUpdate = AccountUpdate2.dummyFeePayer();
  }
  let transaction2 = {
    accountUpdates,
    feePayer: feePayerAccountUpdate,
    memo
  };
  currentTransaction.leave(transactionId);
  return newTransaction(transaction2, proofsEnabled);
}
function newTransaction(transaction2, proofsEnabled) {
  let self = {
    transaction: transaction2,
    sign(additionalKeys) {
      self.transaction = addMissingSignatures(self.transaction, additionalKeys);
      return self;
    },
    async prove() {
      let { zkappCommand, proofs } = await addMissingProofs(self.transaction, {
        proofsEnabled
      });
      self.transaction = zkappCommand;
      return proofs;
    },
    toJSON() {
      let json = ZkappCommand2.toJSON(self.transaction);
      return JSON.stringify(json);
    },
    toPretty() {
      return ZkappCommand2.toPretty(self.transaction);
    },
    toGraphqlQuery() {
      return sendZkappQuery(self.toJSON());
    },
    async send() {
      return await sendTransaction(self);
    }
  };
  return self;
}
var defaultAccountCreationFee = 1e9;
function LocalBlockchain({ accountCreationFee: accountCreationFee2 = defaultAccountCreationFee, proofsEnabled = true, enforceTransactionLimits = true } = {}) {
  const slotTime = 3 * 60 * 1e3;
  const startTime = Date.now();
  const genesisTimestamp = UInt642.from(startTime);
  const ledger = Ledger.create([]);
  let networkState = defaultNetworkState();
  function addAccount(pk, balance) {
    ledger.addAccount(pk, balance);
  }
  let testAccounts = [];
  for (let i2 = 0; i2 < 10; ++i2) {
    let MINA = 10n ** 9n;
    const largeValue = 1000n * MINA;
    const k = PrivateKey2.random();
    const pk = k.toPublicKey();
    addAccount(pk, largeValue.toString());
    testAccounts.push({ privateKey: k, publicKey: pk });
  }
  const events = {};
  const actions = {};
  return {
    proofsEnabled,
    accountCreationFee: () => UInt642.from(accountCreationFee2),
    getNetworkConstants() {
      return {
        genesisTimestamp,
        accountCreationFee: UInt642.from(accountCreationFee2),
        slotTime: UInt642.from(slotTime)
      };
    },
    currentSlot() {
      return UInt322.from(Math.ceil((new Date().valueOf() - startTime) / slotTime));
    },
    hasAccount(publicKey, tokenId = TokenId3.default) {
      return !!ledger.getAccount(publicKey, tokenId);
    },
    getAccount(publicKey, tokenId = TokenId3.default) {
      let accountJson = ledger.getAccount(publicKey, tokenId);
      if (accountJson === void 0) {
        throw new Error(reportGetAccountError(publicKey.toBase58(), TokenId3.toBase58(tokenId)));
      }
      return transaction_exports.Account.fromJSON(accountJson);
    },
    getNetworkState() {
      return networkState;
    },
    async sendTransaction(txn) {
      txn.sign();
      let commitments = Ledger.transactionCommitments(JSON.stringify(ZkappCommand2.toJSON(txn.transaction)));
      if (enforceTransactionLimits)
        verifyTransactionLimits(txn.transaction.accountUpdates);
      for (const update of txn.transaction.accountUpdates) {
        let accountJson = ledger.getAccount(update.body.publicKey, update.body.tokenId);
        if (accountJson) {
          let account = Account3.fromJSON(accountJson);
          await verifyAccountUpdate(account, update, commitments, proofsEnabled);
        }
      }
      let zkappCommandJson = ZkappCommand2.toJSON(txn.transaction);
      try {
        ledger.applyJsonTransaction(JSON.stringify(zkappCommandJson), String(accountCreationFee2), JSON.stringify(networkState));
      } catch (err) {
        try {
          let errors = JSON.parse(err.message);
          err.message = invalidTransactionError(txn.transaction, errors, {
            accountCreationFee: accountCreationFee2
          });
        } finally {
          throw err;
        }
      }
      txn.transaction.accountUpdates.forEach((p3, i2) => {
        var _a, _b;
        let pJson = zkappCommandJson.accountUpdates[i2];
        let addr = pJson.body.publicKey;
        let tokenId = pJson.body.tokenId;
        events[addr] ?? (events[addr] = {});
        if (p3.body.events.data.length > 0) {
          (_a = events[addr])[tokenId] ?? (_a[tokenId] = []);
          let updatedEvents = p3.body.events.data.map((data) => {
            return {
              data,
              transactionInfo: {
                transactionHash: "",
                transactionStatus: "",
                transactionMemo: ""
              }
            };
          });
          events[addr][tokenId].push({
            events: updatedEvents,
            blockHeight: networkState.blockchainLength,
            globalSlot: networkState.globalSlotSinceGenesis,
            // The following fields are fetched from the Mina network. For now, we mock these values out
            // since networkState does not contain these fields.
            blockHash: "",
            parentBlockHash: "",
            chainStatus: ""
          });
        }
        let storedActions = actions[addr]?.[tokenId];
        let latestActionState_ = storedActions?.[storedActions.length - 1]?.hash;
        let latestActionState = latestActionState_ !== void 0 ? Field(latestActionState_) : Actions.emptyActionState();
        actions[addr] ?? (actions[addr] = {});
        if (p3.body.actions.data.length > 0) {
          let newActionState = Actions.updateSequenceState(latestActionState, p3.body.actions.hash);
          (_b = actions[addr])[tokenId] ?? (_b[tokenId] = []);
          actions[addr][tokenId].push({
            actions: pJson.body.actions,
            hash: newActionState.toString()
          });
        }
      });
      return {
        isSuccess: true,
        wait: async (_options) => {
          console.log("Info: Waiting for inclusion in a block is not supported for LocalBlockchain.");
        },
        hash: () => {
          const message = "Info: Txn Hash retrieving is not supported for LocalBlockchain.";
          console.log(message);
          return message;
        }
      };
    },
    async transaction(sender2, f) {
      let tx = createTransaction(sender2, f, 0, {
        isFinalRunOutsideCircuit: false,
        proofsEnabled,
        fetchMode: "test"
      });
      let hasProofs = tx.transaction.accountUpdates.some(Authorization.hasLazyProof);
      return createTransaction(sender2, f, 1, {
        isFinalRunOutsideCircuit: !hasProofs,
        proofsEnabled
      });
    },
    applyJsonTransaction(json) {
      return ledger.applyJsonTransaction(json, String(accountCreationFee2), JSON.stringify(networkState));
    },
    async fetchEvents(publicKey, tokenId = TokenId3.default) {
      return events?.[publicKey.toBase58()]?.[TokenId3.toBase58(tokenId)] ?? [];
    },
    async fetchActions(publicKey, actionStates, tokenId = TokenId3.default) {
      return this.getActions(publicKey, actionStates, tokenId);
    },
    getActions(publicKey, actionStates, tokenId = TokenId3.default) {
      let currentActions = actions?.[publicKey.toBase58()]?.[TokenId3.toBase58(tokenId)] ?? [];
      let { fromActionState, endActionState } = actionStates ?? {};
      let start = fromActionState?.equals(Actions.emptyActionState()).toBoolean() ? void 0 : fromActionState?.toString();
      let end = endActionState?.toString();
      let startIndex = 0;
      if (start) {
        let i2 = currentActions.findIndex((e) => e.hash === start);
        if (i2 === -1)
          throw Error(`getActions: fromActionState not found.`);
        startIndex = i2 + 1;
      }
      let endIndex;
      if (end) {
        let i2 = currentActions.findIndex((e) => e.hash === end);
        if (i2 === -1)
          throw Error(`getActions: endActionState not found.`);
        endIndex = i2 + 1;
      }
      return currentActions.slice(startIndex, endIndex);
    },
    addAccount,
    /**
     * An array of 10 test accounts that have been pre-filled with
     * 30000000000 units of currency.
     */
    testAccounts,
    setGlobalSlot(slot) {
      networkState.globalSlotSinceGenesis = UInt322.from(slot);
      let difference = networkState.globalSlotSinceGenesis.sub(slot);
    },
    incrementGlobalSlot(increment) {
      networkState.globalSlotSinceGenesis = networkState.globalSlotSinceGenesis.add(increment);
    },
    setBlockchainLength(height) {
      networkState.blockchainLength = height;
    },
    setTotalCurrency(currency) {
      networkState.totalCurrency = currency;
    },
    setProofsEnabled(newProofsEnabled) {
      proofsEnabled = newProofsEnabled;
    }
  };
}
function Network2(input) {
  let accountCreationFee2 = UInt642.from(defaultAccountCreationFee);
  let graphqlEndpoint;
  let archiveEndpoint;
  if (input && typeof input === "string") {
    graphqlEndpoint = input;
    setGraphqlEndpoint(graphqlEndpoint);
  } else if (input && typeof input === "object") {
    graphqlEndpoint = input.mina;
    archiveEndpoint = input.archive;
    setGraphqlEndpoint(graphqlEndpoint);
    setArchiveGraphqlEndpoint(archiveEndpoint);
  } else {
    throw new Error("Network: malformed input. Please provide a string or an object with 'mina' and 'archive' endpoints.");
  }
  const genesisTimestampString = "2023-02-23T20:00:01Z";
  const genesisTimestamp = UInt642.from(Date.parse(genesisTimestampString.slice(0, -1) + "+00:00"));
  const slotTime = UInt642.from(3 * 60 * 1e3);
  return {
    accountCreationFee: () => accountCreationFee2,
    getNetworkConstants() {
      return {
        genesisTimestamp,
        slotTime,
        accountCreationFee: accountCreationFee2
      };
    },
    currentSlot() {
      throw Error("currentSlot() is not implemented yet for remote blockchains.");
    },
    hasAccount(publicKey, tokenId = TokenId3.default) {
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        return !!getCachedAccount(publicKey, tokenId, graphqlEndpoint);
      }
      return false;
    },
    getAccount(publicKey, tokenId = TokenId3.default) {
      if (currentTransaction()?.fetchMode === "test") {
        markAccountToBeFetched(publicKey, tokenId, graphqlEndpoint);
        let account = getCachedAccount(publicKey, tokenId, graphqlEndpoint);
        return account ?? dummyAccount(publicKey);
      }
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        let account = getCachedAccount(publicKey, tokenId, graphqlEndpoint);
        if (account !== void 0)
          return account;
      }
      throw Error(`${reportGetAccountError(publicKey.toBase58(), TokenId3.toBase58(tokenId))}
Graphql endpoint: ${graphqlEndpoint}`);
    },
    getNetworkState() {
      if (currentTransaction()?.fetchMode === "test") {
        markNetworkToBeFetched(graphqlEndpoint);
        let network = getCachedNetwork(graphqlEndpoint);
        return network ?? defaultNetworkState();
      }
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        let network = getCachedNetwork(graphqlEndpoint);
        if (network !== void 0)
          return network;
      }
      throw Error(`getNetworkState: Could not fetch network state from graphql endpoint ${graphqlEndpoint}`);
    },
    async sendTransaction(txn) {
      txn.sign();
      verifyTransactionLimits(txn.transaction.accountUpdates);
      let [response, error] = await sendZkapp(txn.toJSON());
      let errors;
      if (error === void 0) {
        if (response.data === null && response.errors?.length > 0) {
          console.log("got graphql errors", JSON.stringify(response.errors, null, 2));
          errors = response.errors;
        }
      } else {
        console.log("got fetch error", error);
        errors = [error];
      }
      let isSuccess = errors === void 0;
      let maxAttempts;
      let attempts = 0;
      let interval;
      return {
        isSuccess,
        data: response?.data,
        errors,
        async wait(options) {
          if (!isSuccess) {
            console.warn("Transaction.wait(): returning immediately because the transaction was not successful.");
            return;
          }
          maxAttempts = options?.maxAttempts ?? 45;
          interval = options?.interval ?? 2e4;
          const executePoll = async (resolve, reject) => {
            let txId = response?.data?.sendZkapp?.zkapp?.id;
            let res;
            try {
              res = await fetchTransactionStatus(txId);
            } catch (error2) {
              return reject(error2);
            }
            attempts++;
            if (res === "INCLUDED") {
              return resolve();
            } else if (maxAttempts && attempts === maxAttempts) {
              return reject(new Error(`Exceeded max attempts. TransactionId: ${txId}, attempts: ${attempts}, last received status: ${res}`));
            } else {
              setTimeout(executePoll, interval, resolve, reject);
            }
          };
          return new Promise(executePoll);
        },
        hash() {
          return response?.data?.sendZkapp?.zkapp?.hash;
        }
      };
    },
    async transaction(sender2, f) {
      let tx = createTransaction(sender2, f, 0, {
        fetchMode: "test",
        isFinalRunOutsideCircuit: false
      });
      await fetchMissingData(graphqlEndpoint, archiveEndpoint);
      let hasProofs = tx.transaction.accountUpdates.some(Authorization.hasLazyProof);
      return createTransaction(sender2, f, 1, {
        fetchMode: "cached",
        isFinalRunOutsideCircuit: !hasProofs
      });
    },
    async fetchEvents(publicKey, tokenId = TokenId3.default, filterOptions = {}) {
      let pubKey = publicKey.toBase58();
      let token = TokenId3.toBase58(tokenId);
      return fetchEvents({ publicKey: pubKey, tokenId: token }, archiveEndpoint, filterOptions);
    },
    async fetchActions(publicKey, actionStates, tokenId = TokenId3.default) {
      let pubKey = publicKey.toBase58();
      let token = TokenId3.toBase58(tokenId);
      let { fromActionState, endActionState } = actionStates ?? {};
      let fromActionStateBase58 = fromActionState ? fromActionState.toString() : void 0;
      let endActionStateBase58 = endActionState ? endActionState.toString() : void 0;
      return fetchActions({
        publicKey: pubKey,
        actionStates: {
          fromActionState: fromActionStateBase58,
          endActionState: endActionStateBase58
        },
        tokenId: token
      }, archiveEndpoint);
    },
    getActions(publicKey, actionStates, tokenId = TokenId3.default) {
      if (currentTransaction()?.fetchMode === "test") {
        markActionsToBeFetched(publicKey, tokenId, archiveEndpoint, actionStates);
        let actions = getCachedActions(publicKey, tokenId);
        return actions ?? [];
      }
      if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
        let actions = getCachedActions(publicKey, tokenId);
        if (actions !== void 0)
          return actions;
      }
      throw Error(`getActions: Could not find actions for the public key ${publicKey}`);
    },
    proofsEnabled: true
  };
}
function BerkeleyQANet(graphqlEndpoint) {
  return Network2(graphqlEndpoint);
}
var activeInstance = {
  accountCreationFee: () => UInt642.from(defaultAccountCreationFee),
  getNetworkConstants() {
    throw new Error("must call Mina.setActiveInstance first");
  },
  currentSlot: () => {
    throw new Error("must call Mina.setActiveInstance first");
  },
  hasAccount(publicKey, tokenId = TokenId3.default) {
    if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
      return !!getCachedAccount(publicKey, tokenId, defaultGraphqlEndpoint);
    }
    return false;
  },
  getAccount(publicKey, tokenId = TokenId3.default) {
    if (currentTransaction()?.fetchMode === "test") {
      markAccountToBeFetched(publicKey, tokenId, defaultGraphqlEndpoint);
      return dummyAccount(publicKey);
    }
    if (!currentTransaction.has() || currentTransaction.get().fetchMode === "cached") {
      let account = getCachedAccount(publicKey, tokenId, defaultGraphqlEndpoint);
      if (account === void 0)
        throw Error(`${reportGetAccountError(publicKey.toBase58(), TokenId3.toBase58(tokenId))}

Either call Mina.setActiveInstance first or explicitly add the account with addCachedAccount`);
      return account;
    }
    throw new Error("must call Mina.setActiveInstance first");
  },
  getNetworkState() {
    throw new Error("must call Mina.setActiveInstance first");
  },
  sendTransaction() {
    throw new Error("must call Mina.setActiveInstance first");
  },
  async transaction(sender2, f) {
    return createTransaction(sender2, f, 0);
  },
  fetchEvents(_publicKey, _tokenId = TokenId3.default) {
    throw Error("must call Mina.setActiveInstance first");
  },
  fetchActions(_publicKey, _actionStates, _tokenId = TokenId3.default) {
    throw Error("must call Mina.setActiveInstance first");
  },
  getActions(_publicKey, _actionStates, _tokenId = TokenId3.default) {
    throw Error("must call Mina.setActiveInstance first");
  },
  proofsEnabled: true
};
function setActiveInstance(m) {
  activeInstance = m;
}
function transaction(senderOrF, fOrUndefined) {
  let sender2;
  let f;
  if (fOrUndefined !== void 0) {
    sender2 = senderOrF;
    f = fOrUndefined;
  } else {
    sender2 = void 0;
    f = senderOrF;
  }
  return activeInstance.transaction(sender2, f);
}
function sender() {
  let tx = currentTransaction();
  if (tx === void 0)
    throw Error(`The sender is not available outside a transaction. Make sure you only use it within \`Mina.transaction\` blocks or smart contract methods.`);
  let sender2 = currentTransaction()?.sender;
  if (sender2 === void 0)
    throw Error(`The sender is not available, because the transaction block was created without the optional \`sender\` argument.
Here's an example for how to pass in the sender and make it available:

Mina.transaction(sender, // <-- pass in sender's public key here
() => {
  // methods can use this.sender
});
`);
  return sender2;
}
function currentSlot() {
  return activeInstance.currentSlot();
}
function getAccount(publicKey, tokenId) {
  return activeInstance.getAccount(publicKey, tokenId);
}
function hasAccount(publicKey, tokenId) {
  return activeInstance.hasAccount(publicKey, tokenId);
}
function getNetworkState() {
  return activeInstance.getNetworkState();
}
function getBalance(publicKey, tokenId) {
  return activeInstance.getAccount(publicKey, tokenId).balance;
}
function accountCreationFee() {
  return activeInstance.accountCreationFee();
}
async function sendTransaction(txn) {
  return await activeInstance.sendTransaction(txn);
}
async function fetchEvents2(publicKey, tokenId, filterOptions = {}) {
  return await activeInstance.fetchEvents(publicKey, tokenId, filterOptions);
}
async function fetchActions2(publicKey, actionStates, tokenId) {
  return await activeInstance.fetchActions(publicKey, actionStates, tokenId);
}
function getActions(publicKey, actionStates, tokenId) {
  return activeInstance.getActions(publicKey, actionStates, tokenId);
}
function getProofsEnabled() {
  return activeInstance.proofsEnabled;
}
function dummyAccount(pubkey) {
  let dummy = transaction_exports.Account.emptyValue();
  if (pubkey)
    dummy.publicKey = pubkey;
  return dummy;
}
function defaultNetworkState() {
  let epochData = {
    ledger: { hash: Field(0), totalCurrency: UInt642.zero },
    seed: Field(0),
    startCheckpoint: Field(0),
    lockCheckpoint: Field(0),
    epochLength: UInt322.zero
  };
  return {
    snarkedLedgerHash: Field(0),
    blockchainLength: UInt322.zero,
    minWindowDensity: UInt322.zero,
    totalCurrency: UInt642.zero,
    globalSlotSinceGenesis: UInt322.zero,
    stakingEpochData: epochData,
    nextEpochData: cloneCircuitValue(epochData)
  };
}
async function verifyAccountUpdate(account, accountUpdate, transactionCommitments, proofsEnabled) {
  if (accountUpdate.body.callDepth === 0 && !AccountUpdate2.MayUseToken.isNo(accountUpdate).toBoolean()) {
    throw Error("Top-level account update can not use or pass on token permissions. Make sure that\naccountUpdate.body.mayUseToken = AccountUpdate.MayUseToken.No;");
  }
  let perm = account.permissions;
  let { commitment, fullCommitment } = transactionCommitments;
  function includesChange(val) {
    if (Array.isArray(val)) {
      return !val.every((v) => v === null);
    } else {
      return val !== null;
    }
  }
  function permissionForUpdate(key) {
    switch (key) {
      case "appState":
        return perm.editState;
      case "delegate":
        return perm.setDelegate;
      case "verificationKey":
        return perm.setVerificationKey;
      case "permissions":
        return perm.setPermissions;
      case "zkappUri":
        return perm.setZkappUri;
      case "tokenSymbol":
        return perm.setTokenSymbol;
      case "timing":
        return perm.setTiming;
      case "votingFor":
        return perm.setVotingFor;
      case "actions":
        return perm.editActionState;
      case "incrementNonce":
        return perm.incrementNonce;
      case "send":
        return perm.send;
      case "receive":
        return perm.receive;
      default:
        throw Error(`Invalid permission for field ${key}: does not exist.`);
    }
  }
  const update = accountUpdate.toJSON().body.update;
  let errorTrace = "";
  let isValidProof = false;
  let isValidSignature = false;
  if (!proofsEnabled)
    isValidProof = true;
  if (accountUpdate.authorization.proof && proofsEnabled) {
    try {
      let publicInput = accountUpdate.toPublicInput();
      let publicInputFields = ZkappPublicInput.toFields(publicInput);
      const proof = SmartContract.Proof().fromJSON({
        maxProofsVerified: 2,
        proof: accountUpdate.authorization.proof,
        publicInput: publicInputFields.map((f) => f.toString())
      });
      let verificationKey = account.zkapp?.verificationKey?.data;
      isValidProof = await verify(proof.toJSON(), verificationKey);
      if (!isValidProof) {
        throw Error(`Invalid proof for account update
${JSON.stringify(update)}`);
      }
    } catch (error) {
      errorTrace += "\n\n" + error.message;
      isValidProof = false;
    }
  }
  if (accountUpdate.authorization.signature) {
    let txC = accountUpdate.body.useFullCommitment.toBoolean() ? fullCommitment : commitment;
    try {
      isValidSignature = Ledger.checkAccountUpdateSignature(JSON.stringify(accountUpdate.toJSON()), txC);
    } catch (error) {
      errorTrace += "\n\n" + error.message;
      isValidSignature = false;
    }
  }
  let verified = false;
  function checkPermission(p0, field) {
    let p3 = transaction_exports.AuthRequired.toJSON(p0);
    if (p3 === "None")
      return;
    if (p3 === "Impossible") {
      throw Error(`Transaction verification failed: Cannot update field '${field}' because permission for this field is '${p3}'`);
    }
    if (p3 === "Signature" || p3 === "Either") {
      verified || (verified = isValidSignature);
    }
    if (p3 === "Proof" || p3 === "Either") {
      verified || (verified = isValidProof);
    }
    if (!verified) {
      throw Error(`Transaction verification failed: Cannot update field '${field}' because permission for this field is '${p3}', but the required authorization was not provided or is invalid.
        ${errorTrace !== "" ? "Error trace: " + errorTrace : ""}`);
    }
  }
  Object.entries(update).forEach(([key, value]) => {
    if (includesChange(value)) {
      let p3 = permissionForUpdate(key);
      checkPermission(p3, key);
    }
  });
  if (accountUpdate.body.actions.data.length > 0) {
    let p3 = permissionForUpdate("actions");
    checkPermission(p3, "actions");
  }
  if (accountUpdate.body.incrementNonce.toBoolean()) {
    let p3 = permissionForUpdate("incrementNonce");
    checkPermission(p3, "incrementNonce");
  }
  if (errorTrace && !verified) {
    throw Error(`One or more proofs were invalid and no other form of authorization was provided.
${errorTrace}`);
  }
}
function verifyTransactionLimits(accountUpdates) {
  const proofCost = 10.26;
  const signedPairCost = 10.08;
  const signedSingleCost = 9.14;
  const costLimit = 69.45;
  const maxActionElements = 16;
  const maxEventElements = 16;
  let eventElements = { events: 0, actions: 0 };
  let authTypes = filterGroups(accountUpdates.map((update) => {
    let json = update.toJSON();
    eventElements.events += countEventElements(update.body.events);
    eventElements.actions += countEventElements(update.body.actions);
    return json.body.authorizationKind;
  }));
  let totalTimeRequired = proofCost * authTypes.proof + signedPairCost * authTypes.signedPair + signedSingleCost * authTypes.signedSingle;
  let isWithinCostLimit = totalTimeRequired < costLimit;
  let isWithinEventsLimit = eventElements.events <= maxEventElements;
  let isWithinActionsLimit = eventElements.actions <= maxActionElements;
  let error = "";
  if (!isWithinCostLimit) {
    error += `Error: The transaction is too expensive, try reducing the number of AccountUpdates that are attached to the transaction.
Each transaction needs to be processed by the snark workers on the network.
Certain layouts of AccountUpdates require more proving time than others, and therefore are too expensive.

${JSON.stringify(authTypes)}


`;
  }
  if (!isWithinEventsLimit) {
    error += `Error: The account updates in your transaction are trying to emit too much event data. The maximum allowed number of field elements in events is ${maxEventElements}, but you tried to emit ${eventElements.events}.

`;
  }
  if (!isWithinActionsLimit) {
    error += `Error: The account updates in your transaction are trying to emit too much action data. The maximum allowed number of field elements in actions is ${maxActionElements}, but you tried to emit ${eventElements.actions}.

`;
  }
  if (error)
    throw Error("Error during transaction sending:\n\n" + error);
}
function countEventElements({ data }) {
  return data.reduce((acc, ev) => acc + ev.length, 0);
}
var isPair = (a, b2) => !a.isProved && !b2.isProved;
function filterPairs(xs) {
  if (xs.length <= 1)
    return { xs, pairs: 0 };
  if (isPair(xs[0], xs[1])) {
    let rec = filterPairs(xs.slice(2));
    return { xs: rec.xs, pairs: rec.pairs + 1 };
  } else {
    let rec = filterPairs(xs.slice(1));
    return { xs: [xs[0]].concat(rec.xs), pairs: rec.pairs };
  }
}
function filterGroups(xs) {
  let pairs = filterPairs(xs);
  xs = pairs.xs;
  let singleCount = 0;
  let proofCount = 0;
  xs.forEach((t) => {
    if (t.isProved)
      proofCount++;
    else
      singleCount++;
  });
  return {
    signedPair: pairs.pairs,
    signedSingle: singleCount,
    proof: proofCount
  };
}
async function waitForFunding(address) {
  let attempts = 0;
  let maxAttempts = 30;
  let interval = 3e4;
  const executePoll = async (resolve, reject) => {
    let { account } = await fetchAccount({ publicKey: address });
    attempts++;
    if (account) {
      return resolve();
    } else if (maxAttempts && attempts === maxAttempts) {
      return reject(new Error(`Exceeded max attempts`));
    } else {
      setTimeout(executePoll, interval, resolve, reject);
    }
  };
  return new Promise(executePoll);
}
async function faucet(pub, network = "berkeley-qanet") {
  let address = pub.toBase58();
  let response = await fetch("https://faucet.minaprotocol.com/api/v1/faucet", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      network,
      address
    })
  });
  response = await response.json();
  if (response.status.toString() !== "success") {
    throw new Error(`Error funding account ${address}, got response status: ${response.status}, text: ${response.statusText}`);
  }
  await waitForFunding(address);
}

// dist/node/lib/encryption.js
var encryption_exports = {};
__export(encryption_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt
});
function encrypt(message, otherPublicKey) {
  let privateKey = Circuit.witness(Scalar, () => Scalar.random());
  let publicKey = Group.generator.scale(privateKey);
  let sharedSecret = otherPublicKey.toGroup().scale(privateKey);
  let sponge = new Poseidon2.Sponge();
  sponge.absorb(sharedSecret.x);
  let cipherText = [];
  for (let i2 = 0; i2 < message.length; i2++) {
    let keyStream = sponge.squeeze();
    let encryptedChunk = message[i2].add(keyStream);
    cipherText.push(encryptedChunk);
    if (i2 % 2 === 1)
      sponge.absorb(cipherText[i2 - 1]);
    if (i2 % 2 === 1 || i2 === message.length - 1)
      sponge.absorb(cipherText[i2]);
  }
  let authenticationTag = sponge.squeeze();
  cipherText.push(authenticationTag);
  return { publicKey, cipherText };
}
function decrypt({ publicKey, cipherText }, privateKey) {
  let sharedSecret = publicKey.scale(privateKey.s);
  let sponge = new Poseidon2.Sponge();
  sponge.absorb(sharedSecret.x);
  let authenticationTag = cipherText.pop();
  let message = [];
  for (let i2 = 0; i2 < cipherText.length; i2++) {
    let keyStream = sponge.squeeze();
    let messageChunk = cipherText[i2].sub(keyStream);
    message.push(messageChunk);
    if (i2 % 2 === 1)
      sponge.absorb(cipherText[i2 - 1]);
    if (i2 % 2 === 1 || i2 === cipherText.length - 1)
      sponge.absorb(cipherText[i2]);
  }
  sponge.squeeze().assertEquals(authenticationTag);
  return message;
}

// dist/node/lib/string.js
var import_tslib4 = require("tslib");
var DEFAULT_STRING_LENGTH = 128;
var Character = class extends CircuitValue {
  isNull() {
    return this.equals(NullCharacter());
  }
  toField() {
    return this.value;
  }
  toString() {
    const charCode = Number(this.value.toString());
    return String.fromCharCode(charCode);
  }
  static fromString(str) {
    const char = Field(str.charCodeAt(0));
    return new Character(char);
  }
  // TODO: Add support for more character sets
  // right now it's 16 bits because 8 not supported :/
  static check(c) {
    c.value.rangeCheckHelper(16).assertEquals(c.value);
  }
};
(0, import_tslib4.__decorate)([
  prop,
  (0, import_tslib4.__metadata)("design:type", Field)
], Character.prototype, "value", void 0);
var CircuitString = class extends CircuitValue {
  // constructor is private because
  // * we do not want extra logic inside CircuitValue constructors, as a general pattern (to be able to create them generically)
  // * here, not running extra logic to fill up the characters would be wrong
  constructor(values) {
    super(values);
  }
  // this is the publicly accessible constructor
  static fromCharacters(chars) {
    return new CircuitString(fillWithNull(chars, this.maxLength));
  }
  maxLength() {
    return this.constructor.maxLength;
  }
  // some O(n) computation that should be only done once in the circuit
  computeLengthAndMask() {
    let n = this.values.length;
    let length = Field(0);
    let mask = [];
    let wasntNullAlready = Bool(true);
    for (let i2 = 0; i2 < n; i2++) {
      let isNull = this.values[i2].isNull();
      mask[i2] = isNull.and(wasntNullAlready);
      wasntNullAlready = isNull.not().and(wasntNullAlready);
      length.add(wasntNullAlready.toField());
    }
    mask[n] = wasntNullAlready;
    this._length = length;
    this._mask = mask;
    return { mask, length };
  }
  lengthMask() {
    return this._mask ?? this.computeLengthAndMask().mask;
  }
  length() {
    return this._length ?? this.computeLengthAndMask().length;
  }
  /**
   * appends another string to this one, returns the result and proves that it fits
   * within the `maxLength` of this string (the other string can have a different maxLength)
   */
  append(str) {
    let n = this.maxLength();
    this.length().add(str.length()).assertLessThan(n);
    let chars = this.values;
    let otherChars = fillWithNull(str.values, n);
    let possibleResults = [];
    for (let length = 0; length < n + 1; length++) {
      possibleResults[length] = chars.slice(0, length).concat(otherChars.slice(0, n - length));
    }
    let result = [];
    let mask = this.lengthMask();
    for (let i2 = 0; i2 < n; i2++) {
      let possibleCharsAtI = possibleResults.map((r) => r[i2]);
      result[i2] = Circuit.switch(mask, Character, possibleCharsAtI);
    }
    return CircuitString.fromCharacters(result);
  }
  // TODO
  /**
   * returns true if `str` is found in this `CircuitString`
   */
  // contains(str: CircuitString): Bool {
  //   // only succeed if the dynamic length is smaller
  //   let otherLength = str.length();
  //   otherLength.assertLessThan(this.length());
  // }
  hash() {
    return Poseidon2.hash(this.values.map((x) => x.value));
  }
  substring(start, end) {
    return CircuitString.fromCharacters(this.values.slice(start, end));
  }
  toString() {
    return this.values.map((x) => x.toString()).join("").replace(/[^ -~]+/g, "");
  }
  static fromString(str) {
    if (str.length > this.maxLength) {
      throw Error("CircuitString.fromString: input string exceeds max length!");
    }
    let characters = str.split("").map((x) => Character.fromString(x));
    return CircuitString.fromCharacters(characters);
  }
};
CircuitString.maxLength = DEFAULT_STRING_LENGTH;
(0, import_tslib4.__decorate)([
  arrayProp(Character, DEFAULT_STRING_LENGTH),
  (0, import_tslib4.__metadata)("design:type", Array)
], CircuitString.prototype, "values", void 0);
var NullCharacter = () => new Character(Field(0));
function fillWithNull([...values], length) {
  let nullChar = NullCharacter();
  for (let i2 = values.length; i2 < length; i2++) {
    values[i2] = nullChar;
  }
  return values;
}

// dist/node/lib/merkle_tree.js
var MerkleTree = class {
  /**
   * Creates a new, empty [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree).
   * @param height The height of Merkle Tree.
   * @returns A new MerkleTree
   */
  constructor(height) {
    this.height = height;
    this.nodes = {};
    this.zeroes = [Field(0)];
    for (let i2 = 1; i2 < height; i2++) {
      this.zeroes.push(Poseidon2.hash([this.zeroes[i2 - 1], this.zeroes[i2 - 1]]));
    }
  }
  /**
   * Returns a node which lives at a given index and level.
   * @param level Level of the node.
   * @param index Index of the node.
   * @returns The data of the node.
   */
  getNode(level, index) {
    return this.nodes[level]?.[index.toString()] ?? this.zeroes[level];
  }
  /**
   * Returns the root of the [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree).
   * @returns The root of the Merkle Tree.
   */
  getRoot() {
    return this.getNode(this.height - 1, 0n);
  }
  // TODO: this allows to set a node at an index larger than the size. OK?
  setNode(level, index, value) {
    var _a;
    ((_a = this.nodes)[level] ?? (_a[level] = {}))[index.toString()] = value;
  }
  // TODO: if this is passed an index bigger than the max, it will set a couple of out-of-bounds nodes but not affect the real Merkle root. OK?
  /**
   * Sets the value of a leaf node at a given index to a given value.
   * @param index Position of the leaf node.
   * @param leaf New value.
   */
  setLeaf(index, leaf) {
    if (index >= this.leafCount) {
      throw new Error(`index ${index} is out of range for ${this.leafCount} leaves.`);
    }
    this.setNode(0, index, leaf);
    let currIndex = index;
    for (let level = 1; level < this.height; level++) {
      currIndex /= 2n;
      const left = this.getNode(level - 1, currIndex * 2n);
      const right = this.getNode(level - 1, currIndex * 2n + 1n);
      this.setNode(level, currIndex, Poseidon2.hash([left, right]));
    }
  }
  /**
   * Returns the witness (also known as [Merkle Proof or Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof)) for the leaf at the given index.
   * @param index Position of the leaf node.
   * @returns The witness that belongs to the leaf.
   */
  getWitness(index) {
    if (index >= this.leafCount) {
      throw new Error(`index ${index} is out of range for ${this.leafCount} leaves.`);
    }
    const witness = [];
    for (let level = 0; level < this.height - 1; level++) {
      const isLeft = index % 2n === 0n;
      const sibling = this.getNode(level, isLeft ? index + 1n : index - 1n);
      witness.push({ isLeft, sibling });
      index /= 2n;
    }
    return witness;
  }
  // TODO: this will always return true if the merkle tree was constructed normally; seems to be only useful for testing. remove?
  /**
   * Checks if the witness that belongs to the leaf at the given index is a valid witness.
   * @param index Position of the leaf node.
   * @returns True if the witness for the leaf node is valid.
   */
  validate(index) {
    const path = this.getWitness(index);
    let hash2 = this.getNode(0, index);
    for (const node of path) {
      hash2 = Poseidon2.hash(node.isLeft ? [hash2, node.sibling] : [node.sibling, hash2]);
    }
    return hash2.toString() === this.getRoot().toString();
  }
  // TODO: should this take an optional offset? should it fail if the array is too long?
  /**
   * Fills all leaves of the tree.
   * @param leaves Values to fill the leaves with.
   */
  fill(leaves) {
    leaves.forEach((value, index) => {
      this.setLeaf(BigInt(index), value);
    });
  }
  /**
   * Returns the amount of leaf nodes.
   * @returns Amount of leaf nodes.
   */
  get leafCount() {
    return 2n ** BigInt(this.height - 1);
  }
};
var BaseMerkleWitness = class extends CircuitValue {
  height() {
    return this.constructor.height;
  }
  /**
   * Takes a {@link Witness} and turns it into a circuit-compatible Witness.
   * @param witness Witness.
   * @returns A circuit-compatible Witness.
   */
  constructor(witness) {
    super();
    let height = witness.length + 1;
    if (height !== this.height()) {
      throw Error(`Length of witness ${height}-1 doesn't match static tree height ${this.height()}.`);
    }
    this.path = witness.map((item) => item.sibling);
    this.isLeft = witness.map((item) => Bool(item.isLeft));
  }
  /**
   * Calculates a root depending on the leaf value.
   * @param leaf Value of the leaf node that belongs to this Witness.
   * @returns The calculated root.
   */
  calculateRoot(leaf) {
    let hash2 = leaf;
    let n = this.height();
    for (let i2 = 1; i2 < n; ++i2) {
      let isLeft = this.isLeft[i2 - 1];
      const [left, right] = maybeSwap(isLeft, hash2, this.path[i2 - 1]);
      hash2 = Poseidon2.hash([left, right]);
    }
    return hash2;
  }
  /**
   * Calculates a root depending on the leaf value.
   * @deprecated This is a less efficient version of {@link calculateRoot} which was added for compatibility with existing deployed contracts
   */
  calculateRootSlow(leaf) {
    let hash2 = leaf;
    let n = this.height();
    for (let i2 = 1; i2 < n; ++i2) {
      let isLeft = this.isLeft[i2 - 1];
      const [left, right] = maybeSwapBad(isLeft, hash2, this.path[i2 - 1]);
      hash2 = Poseidon2.hash([left, right]);
    }
    return hash2;
  }
  /**
   * Calculates the index of the leaf node that belongs to this Witness.
   * @returns Index of the leaf.
   */
  calculateIndex() {
    let powerOfTwo = Field(1);
    let index = Field(0);
    let n = this.height();
    for (let i2 = 1; i2 < n; ++i2) {
      index = Circuit.if(this.isLeft[i2 - 1], index, index.add(powerOfTwo));
      powerOfTwo = powerOfTwo.mul(2);
    }
    return index;
  }
};
function MerkleWitness(height) {
  class MerkleWitness_ extends BaseMerkleWitness {
  }
  MerkleWitness_.height = height;
  arrayProp(Field, height - 1)(MerkleWitness_.prototype, "path");
  arrayProp(Bool, height - 1)(MerkleWitness_.prototype, "isLeft");
  return MerkleWitness_;
}
function maybeSwapBad(b2, x, y) {
  const x_ = Circuit.if(b2, x, y);
  const y_ = Circuit.if(b2, y, x);
  return [x_, y_];
}
function maybeSwap(b2, x, y) {
  let m = b2.toField().mul(x.sub(y));
  const x_ = y.add(m);
  const y_ = x.sub(m);
  return [x_, y_];
}

// dist/node/lib/merkle_map.js
var import_tslib5 = require("tslib");
var bits = 255;
var printDebugs = false;
var MerkleMap = class {
  // ------------------------------------------------
  /**
   * Creates a new, empty Merkle Map.
   * @returns A new MerkleMap
   */
  constructor() {
    if (bits > 255) {
      throw Error("bits must be <= 255");
    }
    if (bits !== 255) {
      console.warn("bits set to", bits + ". Should be set to 255 in production to avoid collisions");
    }
    this.tree = new MerkleTree(bits + 1);
  }
  // ------------------------------------------------
  _keyToIndex(key) {
    let keyBits = key.toBits().slice(0, bits).reverse().map((b2) => b2.toBoolean());
    let n = 0n;
    for (let i2 = 0; i2 < keyBits.length; i2++) {
      const b2 = keyBits[i2] ? 1 : 0;
      n += 2n ** BigInt(i2) * BigInt(b2);
    }
    return n;
  }
  // ------------------------------------------------
  /**
   * Sets a key of the merkle map to a given value.
   * @param key The key to set in the map.
   * @param key The value to set.
   */
  set(key, value) {
    const index = this._keyToIndex(key);
    this.tree.setLeaf(index, value);
  }
  // ------------------------------------------------
  /**
   * Returns a value given a key. Values are by default Field(0).
   * @param key The key to get the value from.
   * @returns The value stored at the key.
   */
  get(key) {
    const index = this._keyToIndex(key);
    return this.tree.getNode(0, index);
  }
  // ------------------------------------------------
  /**
   * Returns the root of the Merkle Map.
   * @returns The root of the Merkle Map.
   */
  getRoot() {
    return this.tree.getRoot();
  }
  /**
   * Returns a circuit-compatible witness (also known as [Merkle Proof or Merkle Witness](https://computersciencewiki.org/index.php/Merkle_proof)) for the given key.
   * @param key The key to make a witness for.
   * @returns A MerkleMapWitness, which can be used to assert changes to the MerkleMap, and the witness's key.
   */
  getWitness(key) {
    const index = this._keyToIndex(key);
    class MyMerkleWitness extends MerkleWitness(bits + 1) {
    }
    const witness = new MyMerkleWitness(this.tree.getWitness(index));
    if (printDebugs) {
      console.log("witness bits", witness.isLeft.map((l) => l.toBoolean() ? "0" : "1").join(", "));
      console.log("key bits", key.toBits().slice(0, bits).map((l) => l.toBoolean() ? "1" : "0").join(", "));
    }
    return new MerkleMapWitness(witness.isLeft, witness.path);
  }
};
var MerkleMapWitness = class extends CircuitValue {
  constructor(isLefts, siblings) {
    super();
    this.isLefts = isLefts;
    this.siblings = siblings;
  }
  /**
   * computes the merkle tree root for a given value and the key for this witness
   * @param value The value to compute the root for.
   * @returns A tuple of the computed merkle root, and the key that is connected to the path updated by this witness.
   */
  computeRootAndKey(value) {
    let hash2 = value;
    const isLeft = this.isLefts;
    const siblings = this.siblings;
    let key = Field(0);
    for (let i2 = 0; i2 < bits; i2++) {
      const left = Circuit.if(isLeft[i2], hash2, siblings[i2]);
      const right = Circuit.if(isLeft[i2], siblings[i2], hash2);
      hash2 = Poseidon2.hash([left, right]);
      const bit = Circuit.if(isLeft[i2], Field(0), Field(1));
      key = key.mul(2).add(bit);
    }
    return [hash2, key];
  }
};
(0, import_tslib5.__decorate)([
  arrayProp(Bool, bits),
  (0, import_tslib5.__metadata)("design:type", Array)
], MerkleMapWitness.prototype, "isLefts", void 0);
(0, import_tslib5.__decorate)([
  arrayProp(Field, bits),
  (0, import_tslib5.__metadata)("design:type", Array)
], MerkleMapWitness.prototype, "siblings", void 0);

// dist/node/index.js
var Experimental_ = {
  Callback,
  createChildAccountUpdate,
  memoizeWitness,
  ZkProgram
};
var Experimental;
(function(Experimental2) {
  Experimental2.ZkProgram = Experimental_.ZkProgram;
  Experimental2.createChildAccountUpdate = Experimental_.createChildAccountUpdate;
  Experimental2.memoizeWitness = Experimental_.memoizeWitness;
  Experimental2.Callback = Experimental_.Callback;
})(Experimental || (Experimental = {}));
Error.stackTraceLimit = 1e3;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Account,
  AccountUpdate,
  Bool,
  Character,
  Circuit,
  CircuitString,
  CircuitValue,
  Encoding,
  Encryption,
  Experimental,
  Field,
  Group,
  Int64,
  Ledger,
  MerkleMap,
  MerkleMapWitness,
  MerkleTree,
  MerkleWitness,
  Mina,
  Permissions,
  Poseidon,
  PrivateKey,
  Proof,
  PublicKey,
  Reducer,
  Scalar,
  SelfProof,
  Sign,
  Signature,
  SmartContract,
  State,
  Struct,
  Token,
  TokenSymbol,
  Types,
  UInt32,
  UInt64,
  VerificationKey,
  ZkappPublicInput,
  addCachedAccount,
  arrayProp,
  circuitMain,
  declareMethods,
  declareState,
  fetchAccount,
  fetchEvents,
  fetchLastBlock,
  fetchTransactionStatus,
  getSrs,
  isReady,
  matrixProp,
  method,
  prop,
  provable,
  provablePure,
  public_,
  recoverVerificationKey,
  sendZkapp,
  serializeVerificationKey,
  setArchiveGraphqlEndpoint,
  setGraphqlEndpoint,
  shutdown,
  signFeePayer,
  state,
  verify
});
